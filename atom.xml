<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>问道IT</title>
  
  <subtitle>       敬畏      Stay Hungry Stay Foolish</subtitle>
  <link href="https://wendaoit.github.io/atom.xml" rel="self"/>
  
  <link href="https://wendaoit.github.io/"/>
  <updated>2023-03-07T06:53:39.086Z</updated>
  <id>https://wendaoit.github.io/</id>
  
  <author>
    <name>zxh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>位运算</title>
    <link href="https://wendaoit.github.io/2023/03/07/java%E4%B8%AD%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://wendaoit.github.io/2023/03/07/java%E4%B8%AD%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>java 中位运算 ^,&,<<,>>,<<<,>>> 总结</center><span id="more"></span><h3 id="位运算都是基于二进制的"><a href="#位运算都是基于二进制的" class="headerlink" title="位运算都是基于二进制的"></a>位运算都是基于二进制的</h3><h4 id="1-亦或运算-，针对二进制，相同的为-0，不同的为-1"><a href="#1-亦或运算-，针对二进制，相同的为-0，不同的为-1" class="headerlink" title="1.^(亦或运算) ，针对二进制，相同的为 0，不同的为 1"></a><strong>1.^(亦或运算) ，</strong>针对二进制，相同的为 0，不同的为 1</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2^3运算的结果是 :&quot;</span>+(<span class="number">2</span>^<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//打印的结果是:   2^3运算的结果是 :1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>2 =======&gt;0010</p><p>3 =======&gt;0011</p><p>2^3 就为 0001，结果就是 1</p><h4 id="2-amp-（与运算）-针对二进制，只要有一个为-0，就为-0"><a href="#2-amp-（与运算）-针对二进制，只要有一个为-0，就为-0" class="headerlink" title="2.&amp;（与运算） 针对二进制，只要有一个为 0，就为 0"></a><strong>2.&amp;（与运算）</strong> 针对二进制，只要有一个为 0，就为 0</h4><p>还是上述的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">&quot;2&amp;3 运算的结果是 :&quot;</span>+(<span class="number">2</span>&amp;<span class="number">3</span>));</span><br><span class="line">     <span class="comment">// 打印的结果是:  2&amp;3 运算的结果是 :2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>0010 &amp; 0011 =0010 也就是2</p><h4 id="3-lt-lt-向左位移"><a href="#3-lt-lt-向左位移" class="headerlink" title="3.&lt;&lt;(向左位移)"></a><strong>3.&lt;&lt;(向左位移)</strong></h4><h5 id="针对二进制，转换成二进制后向左移动-3-位，后面用-0-补齐"><a href="#针对二进制，转换成二进制后向左移动-3-位，后面用-0-补齐" class="headerlink" title="针对二进制，转换成二进制后向左移动 3 位，后面用 0 补齐"></a>针对二进制，转换成二进制后向左移动 3 位，后面用 0 补齐</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">&quot;2&lt;&lt;3 运算的结果是 :&quot;</span>+(<span class="number">2</span>&lt;&lt;<span class="number">3</span>));</span><br><span class="line">     <span class="comment">// 打印的结果是:  2&lt;&lt;3 运算的结果是 :16</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>0010 左移三位 10000  相当于2*2^3 =16</p></blockquote><h4 id="4-gt-gt-向右位移"><a href="#4-gt-gt-向右位移" class="headerlink" title="4.&gt;&gt;(向右位移)"></a><strong>4.&gt;&gt;(向右位移)</strong></h4><p>针对二进制，转换成二进制后向右移动 3 位，</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">&quot;2&gt;&gt;3 运算的结果是 :&quot;</span>+(<span class="number">2</span>&gt;&gt;<span class="number">3</span>));</span><br><span class="line">     <span class="comment">// 打印的结果是:  2&gt;&gt;3 运算的结果是 :0</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="5-gt-gt-gt-无符号右移"><a href="#5-gt-gt-gt-无符号右移" class="headerlink" title="5.&gt;&gt;&gt;(无符号右移)"></a><strong>5.&gt;&gt;&gt;(无符号右移)</strong></h4><p>无符号右移，忽略符号位，空位都以 0 补齐</p><p>10 进制转二进制的时候，因为二进制数一般分 8 位、 16 位、32 位以及 64 位 表示一个十进制数，所以在转换过程中，最高位会补零。</p><p>在计算机中负数采用二进制的补码表示，10 进制转为二进制得到的是原码，将原码按位取反得到的是反码，反码加 1 得到补码</p><p>二进制的最高位是符号位，0 表示正，1 表示负。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;与&gt;&gt;唯一的不同是它无论原来的最左边是什么数，统统都用<span class="number">0</span>填充。</span><br><span class="line">——比如，<span class="keyword">byte</span>是<span class="number">8</span>位的，<span class="number">-1</span>表示为<span class="keyword">byte</span>型是<span class="number">11111111</span>(补码表示法）</span><br><span class="line">b&gt;&gt;&gt;<span class="number">4</span>就是无符号右移<span class="number">4</span>位，即<span class="number">00001111</span>，这样结果就是<span class="number">15</span>。</span><br></pre></td></tr></table></figure><p>下面看代码</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>的<span class="number">2</span>进制表示 <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;    System.out.println (<span class="string">&quot;16&gt;&gt;2 运算的结果是 :&quot;</span>+((<span class="number">16</span>)&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;    <span class="comment">// 打印的结果是:  16&gt;&gt;2 运算的结果是 :4</span></span><br><span class="line">&gt; &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;      System.out.println (<span class="string">&quot;-16&gt;&gt;2 运算的结果是 :&quot;</span>+((-<span class="number">16</span>)&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;      <span class="comment">// 打印的结果是:  -16&gt;&gt;2 运算的结果是 :-4</span></span><br><span class="line">&gt;    &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;      System.out.println (<span class="string">&quot;16&gt;&gt;&gt;2 运算的结果是 :&quot;</span>+((<span class="number">16</span>)&gt;&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;      <span class="comment">// 打印的结果是:  16&gt;&gt;&gt;2 运算的结果是 :4</span></span><br><span class="line">&gt;    &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;     System.out.println (<span class="string">&quot;-16&gt;&gt;&gt;2 运算的结果是 :&quot;</span>+((-<span class="number">16</span>)&gt;&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;     <span class="comment">// 打印的结果是:  -16&gt;&gt;&gt;2 运算的结果是 :1073741820</span></span><br><span class="line">&gt;    &#125;</span><br></pre></td></tr></table></figure></blockquote><p>可见正数做 &gt;&gt;&gt; 运算的时候和 &gt;&gt; 是一样的。区别在于负数运算</p><h3 id="others："><a href="#others：" class="headerlink" title="others："></a>others：</h3><ul><li>参考上一篇文章HashMap底层原理 </li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;java 中位运算 ^,&amp;,&lt;&lt;,&gt;&gt;,&lt;&lt;&lt;,&gt;&gt;&gt; 总结&lt;/center&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://wendaoit.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://wendaoit.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Think in Java 第四版 读书笔记</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E3%80%8AThink%20in%20Java%20%E7%AC%AC%E5%9B%9B%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E3%80%8AThink%20in%20Java%20%E7%AC%AC%E5%9B%9B%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Think-in-Java-第四版-读书笔记"><a href="#Think-in-Java-第四版-读书笔记" class="headerlink" title="Think in Java 第四版 读书笔记"></a><center>Think in Java 第四版 读书笔记</center></h1><span id="more"></span><p>本书基于jdk1.5 有些许老旧</p><p>面向对象程序的挑战之一就是在问题空间的元素和解空间的对象之间创建一对一的映射。</p><p>UML统一建模语言，每个类用一个方框表示，类名在方框顶部，任何数据成员在中间，方法行为在底部；</p><h1 id="第8章多态"><a href="#第8章多态" class="headerlink" title="第8章多态"></a>第8章多态</h1><ol><li>子类想要获取父类的属性时，必须显式的使用super<ol><li>因为子类转换为父类时，任何域的操作都是由编译器决定的，不是多态的；子类默认的域是自己的域；</li></ol></li><li>什么是多态？<ol><li>子类可以向上转型为父类，父类在调用传进来的方法时，无法判断是哪个子类（只有在编译中才能确定），这就是java的多态性；</li></ol></li><li>向下转型时可能会出现类型转换异常ClassCastException</li><li>尽量避免子类和父类中出现同样的命名；</li></ol><h1 id="第九章-接口"><a href="#第九章-接口" class="headerlink" title="第九章 接口"></a>第九章 接口</h1><ol><li>包含抽象方法的类是抽象类</li><li>创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，被称为策略设计模式；</li><li>适配器设计模式——适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。（类型转换?）</li><li>同时继承一个类和多个接口时，必须把类放在前面，否则会报错；</li><li>同名同返回类型的多个继承，不会报错，会覆写；but同名不同返回类型的继承会报错；</li><li>接口可以包含域，但是是隐式static和final的</li><li>接口和工厂——复用性</li><li>优先选择类而不是接口，必要的时候才对接口进行重构；</li></ol><h1 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章 内部类"></a>第十章 内部类</h1><ol><li>接口内部类，因为接口中的类都是public、static的，所以可以在接口内实现外围的接口，单独进行main方法测试；</li><li>内部类单独生成一个.class文件</li><li>内部类和匿名内部类的区别P214</li></ol><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><ol><li>通过使用泛型，可以在编译器避免将错误的类型放置到容器中；</li><li>Object中默认的toString方法，打印的是类名+@+hashCode产生的该对象的散列码的无符号十六进制；</li><li></li></ol><h1 id="第十二章-通过异常处理错误"><a href="#第十二章-通过异常处理错误" class="headerlink" title="第十二章 通过异常处理错误"></a>第十二章 通过异常处理错误</h1><ol><li>理解异常处理的两种模型——终止模型和回复模型。<ol><li>终止模型：将错误视为不能继续运行的错误，抛出异常；</li><li>恢复模型：try块中处理程序的工作是修正错误，然后重新尝试调用；（eg：执行job失败时的多次重试、把try放在while循环中）</li></ol></li><li></li></ol><h2 id="与C-的区别"><a href="#与C-的区别" class="headerlink" title="与C++ 的区别"></a>与C++ 的区别</h2><ol><li>数组的使用<ol><li>java更加安全，c++直接操作内存块；</li></ol></li><li>代码作用域不同</li><li>C++创建对象后，需要销毁对象，而java具有垃圾回收机制；</li><li>c++没有变量初始化功能；</li><li>C++中组合多个接口的类的行为是多重继承；</li><li>java统一了异常处理</li></ol><!--more-->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Think-in-Java-第四版-读书笔记&quot;&gt;&lt;a href=&quot;#Think-in-Java-第四版-读书笔记&quot; class=&quot;headerlink&quot; title=&quot;Think in Java 第四版 读书笔记&quot;&gt;&lt;/a&gt;&lt;center&gt;Think in Java 第四版 读书笔记&lt;/center&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="-Java -书籍" scheme="https://wendaoit.github.io/categories/Java-%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="-Java" scheme="https://wendaoit.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>公司融资知识科普</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E5%85%AC%E5%8F%B8%E8%9E%8D%E8%B5%84%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E5%85%AC%E5%8F%B8%E8%9E%8D%E8%B5%84%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>双创科普知识</center><span id="more"></span><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>最近在找公司面试，发现有的公司不需要融资，有的还分为天使、ABCD等</p><p>了解一点关于投融资的知识；</p><p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820151547131.png" alt="image-20210820151547131"></p><p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820151737303.png" alt="image-20210820151737303"></p><p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820152018932.png" alt="image-20210820152018932"></p><!-- more -->]]></content>
    
    
    <summary type="html">&lt;center&gt;双创科普知识&lt;/center&gt;</summary>
    
    
    
    <category term="公司" scheme="https://wendaoit.github.io/categories/%E5%85%AC%E5%8F%B8/"/>
    
    
    <category term="-投融资 -公司" scheme="https://wendaoit.github.io/tags/%E6%8A%95%E8%9E%8D%E8%B5%84-%E5%85%AC%E5%8F%B8/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>数据结构之哈希表</center><center>思想：用空间换取时间；</center><span id="more"></span><p> <strong>定义</strong>：每一个字符都和一个索引相对应；</p><p>查找的复杂度O(1)；</p><p><strong>哈希函数</strong>：“键”转换成索引的<strong>转换函数</strong>；</p><p><strong>哈希冲突</strong>：两个不同的键对应一个索引；</p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826093503314.png" alt="image-20210826093503314" style="zoom:50%;" /><p>哈希函数的设计是很重要的；</p><p>  键通过哈希函数得到的索引的索引越均匀越好</p><p><strong>哈希函数的设计</strong>：转成整型（并不是唯一的办法）</p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826094043955.png" alt="image-20210826094043955" style="zoom:67%;" /><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826094304154.png" alt="image-20210826094304154" style="zoom:67%;" /><p>大整数取模一个素数，让分布更均匀 ；<strong>选一个合适的素数</strong><a href="https://planetmath.org/goodhashtableprimes">参考网站</a></p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826094531867.png" alt="image-20210826094531867" style="zoom:80%;" /><p><strong>字符串设计</strong></p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826095605810.png" alt="image-20210826095605810" style="zoom:80%;" /><p> 复合类型转换–和字符串类似</p><p><strong>性质</strong>：</p><ol><li>一致性：如果a==b,则hash(a)=hash(b);</li><li>高效性：计算高校简便；</li><li>均匀性：哈希值均匀分布；</li></ol><h4 id="JAVA中的hashCode"><a href="#JAVA中的hashCode" class="headerlink" title="JAVA中的hashCode"></a>JAVA中的hashCode</h4><p> Java中每个Object自带hashCode是根据对象地址生成的，同样的内容不同的对象地址也不一样；</p><p>我们可以自定义覆盖hashCode计算方法；</p><p><strong>通常要比较两个类是否相等</strong>：覆盖hashcode和equals</p><ul><li>hashcode相等证明他们的内容相等</li><li>同时如果equals相等证明地址也相同，是用一个类</li></ul><h4 id="哈希冲突的处理-链地址法-Seperate-Chaining"><a href="#哈希冲突的处理-链地址法-Seperate-Chaining" class="headerlink" title="哈希冲突的处理 链地址法 Seperate Chaining"></a>哈希冲突的处理 链地址法 Seperate Chaining</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826105524706.png" alt="image-20210826105524706" style="zoom:50%;" /><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826105804004.png" alt="image-20210826105804004" style="zoom:80%;" /><h4 id="自己做一个哈希表"><a href="#自己做一个哈希表" class="headerlink" title="自己做一个哈希表"></a>自己做一个哈希表</h4><p><strong>设计思想</strong>： </p><ul><li>表：顾名思义有行有列</li><li>设计一个用户自定义大小的数组列</li><li>每个列中的行设计链表，成TreeMap；（TreeMap的底层实现是红黑树）</li></ul><h4 id="定义一个表"><a href="#定义一个表" class="headerlink" title="定义一个表"></a>定义一个表<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826111205963.png" alt="image-20210826111205963" style="zoom:80%;" /></h4><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826111704766.png" alt="image-20210826111704766"></p><h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove()"></a>Remove()</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826112241539.png" alt="image-20210826112241539" style="zoom:67%;" /><h4 id="Set-Contains"><a href="#Set-Contains" class="headerlink" title="Set() Contains()"></a>Set() Contains()</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826112414906.png" alt="image-20210826112414906" style="zoom:67%;" /><h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826113246371.png" alt="image-20210826113246371" style="zoom:67%;" /><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826140549596.png" alt="image-20210826140549596" style="zoom:67%;" /><p>为实现O(1)级别的复杂度，和静态数组一样，需要reSize</p><h6 id="动态空间处理"><a href="#动态空间处理" class="headerlink" title="动态空间处理"></a>动态空间处理</h6><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826140834209.png" alt="image-20210826140834209" style="zoom:50%;" /><h4 id="reSize"><a href="#reSize" class="headerlink" title="reSize()"></a>reSize()</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826142745265.png" alt="image-20210826142745265" style="zoom:67%;" /><p>哈希碰撞攻击（了解）</p><h4 id="Other"><a href="#Other" class="headerlink" title="Other:"></a>Other:</h4><ul><li>leetcode第378题字符串中的第一个唯一的字符</li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;数据结构之哈希表&lt;/center&gt;

&lt;center&gt;思想：用空间换取时间；&lt;/center&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wendaoit.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="哈希表" scheme="https://wendaoit.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="红黑树" scheme="https://wendaoit.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="链表" scheme="https://wendaoit.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="TreeMap" scheme="https://wendaoit.github.io/tags/TreeMap/"/>
    
  </entry>
  
  <entry>
    <title>意外收获 HEXO 阅读全文</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E6%84%8F%E5%A4%96%E6%94%B6%E8%8E%B7-HEXO-%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E6%84%8F%E5%A4%96%E6%94%B6%E8%8E%B7-HEXO-%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>hexo more折叠失效问题</center><p>ps：因为hexo默认index展示全文，我根据官方三种办法配置了都没有达到我想要的效果；显得我的首页很冗余；某天下午上传文章时突然想到试一下多写几个more试试，没想到成功了；</p><span id="more"></span><p><strong>自己配置问题</strong>：</p><p>我们可以把自己想要折叠的部分放在两个more之间，就可以了</p><h4 id="看效果："><a href="#看效果：" class="headerlink" title="看效果："></a>看效果：</h4><ul><li>这是没有解决之前的效果</li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825144754934.png" alt="image-20210825144754934" style="zoom:50%;" /></li><li>加了两行之后<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825144841763.png" alt="image-20210825144841763" style="zoom:50%;" /></li><li>实现了我想要的折叠</li></ul><p><strong>感悟</strong>：多试一试，这个错误可能是因为我对前端知识不是很了解导致的；不过我查了很多博客都没有说这种方法；</p><!--more--><center>希望对大家能有帮助</center>]]></content>
    
    
    <summary type="html">&lt;center&gt;hexo more折叠失效问题&lt;/center&gt;

&lt;p&gt;ps：因为hexo默认index展示全文，我根据官方三种办法配置了都没有达到我想要的效果；显得我的首页很冗余；某天下午上传文章时突然想到试一下多写几个more试试，没想到成功了；&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://wendaoit.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://wendaoit.github.io/tags/hexo/"/>
    
    <category term="意外收获" scheme="https://wendaoit.github.io/tags/%E6%84%8F%E5%A4%96%E6%94%B6%E8%8E%B7/"/>
    
    <category term="前端" scheme="https://wendaoit.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Day2/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Day2/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>链表</center><span id="more"></span><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组和链表的对比：<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820090218843.png" alt="image-20210820090218843" style="zoom:67%;" /></p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>​            真正的动态；头插方便</p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820151148173.png" alt="image-20210820151148173" style="zoom:67%;" /><h3 id="在链表中插入元素："><a href="#在链表中插入元素：" class="headerlink" title="在链表中插入元素："></a>在链表中插入元素：</h3><p>顺序很重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node(e)</span><br><span class="line">node.next = prev.next;</span><br><span class="line">prev.next = node;</span><br></pre></td></tr></table></figure><h3 id="在链表中删除某个节点："><a href="#在链表中删除某个节点：" class="headerlink" title="在链表中删除某个节点："></a>在链表中删除某个节点：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node(e)</span><br><span class="line">Node delNode = prev.next;</span><br><span class="line">prev.next=delNode.next;</span><br><span class="line">delNode.next = <span class="keyword">null</span>;</span><br><span class="line">size --;</span><br></pre></td></tr></table></figure><h3 id="链表的时间复杂度："><a href="#链表的时间复杂度：" class="headerlink" title="链表的时间复杂度："></a>链表的时间复杂度：</h3><ol><li><h5 id="添加、删除操作"><a href="#添加、删除操作" class="headerlink" title="添加、删除操作"></a>添加、删除操作</h5><ul><li>addLast(e) ——-O(n)</li><li>addFirst(e)——–O(1)</li><li>add(index,e)——-O(n/2)=O(n)</li></ul></li><li><h5 id="查找操作O-n"><a href="#查找操作O-n" class="headerlink" title="查找操作O(n)"></a>查找操作O(n)<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820103315983.png" alt="image-20210820103315983" style="zoom: 50%;" /></h5></li></ol><p>链表的应用</p><ul><li>用链表实现栈</li><li>用链表实现队列 </li></ul><h3 id="删除元素递归的微观机制解读："><a href="#删除元素递归的微观机制解读：" class="headerlink" title="删除元素递归的微观机制解读："></a>删除元素递归的微观机制解读：</h3><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820143125372.png" alt="image-20210820143125372" style="zoom: 50%;" /><p> <img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820143157544.png" alt="image-20210820143157544"></p><p>递归调用的代价：函数调用+系统栈空间</p><!-- more -->]]></content>
    
    
    <summary type="html">&lt;center&gt;链表&lt;/center&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wendaoit.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="链表" scheme="https://wendaoit.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数组、stack、queue</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0Day1/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0Day1/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>摘要：数组、stack、queue</center><span id="more"></span><h4 id="线性结构—数组"><a href="#线性结构—数组" class="headerlink" title="线性结构—数组"></a>线性结构—数组</h4><p>栈的底层操作——&gt;数组</p><h4 id="线性结构—栈"><a href="#线性结构—栈" class="headerlink" title="线性结构—栈"></a>线性结构—栈</h4><h5 id="特点：后进先出LIFO"><a href="#特点：后进先出LIFO" class="headerlink" title="特点：后进先出LIFO"></a>特点：后进先出LIFO</h5><p>只能从栈顶添加，取出；（操作的是数组的子集）</p><p>eg:撤销操作</p><h5 id="栈的复杂度"><a href="#栈的复杂度" class="headerlink" title="栈的复杂度"></a>栈的复杂度</h5> <img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210819151959688.png" alt="image-20210819151959688" style="zoom:67%;" /><h4 id="线性结构—队列Queue"><a href="#线性结构—队列Queue" class="headerlink" title="线性结构—队列Queue"></a>线性结构—队列Queue</h4><h5 id="特点：先进先出FIFO"><a href="#特点：先进先出FIFO" class="headerlink" title="特点：先进先出FIFO"></a>特点：先进先出FIFO</h5><p>eg:办理业务</p><h5 id="队列复杂度"><a href="#队列复杂度" class="headerlink" title="队列复杂度"></a>队列复杂度</h5><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210819161236293.png" alt="image-20210819161236293" style="zoom:67%;" />  <h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>​        ——解决dequeue复杂度为O(n)的问题，首尾相接，复杂度变为O(1)</p><p>tail溢出是发生在入队操作中，解决办法：tail = (tail + 1) % capacity</p><p>参：<a href="https://juejin.cn/post/6844903805264347149">Java版-数据结构-队列（循环队列</a></p><p>代码分析两个队列花费时间的差距</p><p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210819232113828.png" alt="image-20210819232113828"></p><p>性能差距100倍！</p><!-- more -->]]></content>
    
    
    <summary type="html">&lt;center&gt;摘要：数组、stack、queue&lt;/center&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wendaoit.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数组" scheme="https://wendaoit.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="栈" scheme="https://wendaoit.github.io/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://wendaoit.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java业务开发常见错误100例</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E6%B5%85%E5%AD%A6Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E6%B5%85%E5%AD%A6Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>极客时间</center><span id="more"></span><h1 id="Java业务开发常见错误100例"><a href="#Java业务开发常见错误100例" class="headerlink" title="Java业务开发常见错误100例"></a>Java业务开发常见错误100例</h1><h2 id="代码篇"><a href="#代码篇" class="headerlink" title="代码篇"></a>代码篇</h2><h4 id="线程安全错误"><a href="#线程安全错误" class="headerlink" title="线程安全错误"></a>线程安全错误</h4><p>原因：错用或者不会用集合导致的oom</p><p>解决方案：</p><h3 id="代码加锁的问题"><a href="#代码加锁的问题" class="headerlink" title="代码加锁的问题"></a>代码加锁的问题</h3><p>第一，使用 synchronized  加锁虽然简单，但我们首先要弄清楚共享资源是类还是实例级别的、会被哪些线程操作，synchronized 关联的锁对象或方法又是什么范围的。 </p><p>第二，加锁尽可能要考虑粒度和场景，锁保护的代码意味着无法进行多线程操作。对于 Web  类型的天然多线程项目，对方法进行大范围加锁会显著降级并发能力，要考虑尽可能地只为必要的代码块加锁，降低锁的粒度；而对于要求超高性能的业务，还要细化考虑锁的读写场景，以及悲观优先还是乐观优先，尽可能针对明确场景精细化加锁方案，可以在适当的场景下考虑使用 ReentrantReadWriteLock、StampedLock 等高级的锁工具类。 </p><p>第三，业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是，避免无限等待和循环等待。 此外，如果业务逻辑中锁的实现比较复杂的话，要仔细看看加锁和释放是否配对，是否有遗漏释放或重复释放的可能性；并且对于分布式锁要考虑锁自动超时释放了，而业务逻辑却还在进行的情况下，如果别的线线程或进程拿到了相同的锁，可能会导致重复执行。</p><p>​    必要的压测——如果你的业务代码涉及复杂的锁操作，强烈建议  Mock 相关外部接口或数据库操作后对应用代码进行压测，通过压测排除锁误用带来的性能问题和死锁问题。</p><h3 id="管理宝贵的资源——线程"><a href="#管理宝贵的资源——线程" class="headerlink" title="管理宝贵的资源——线程"></a>管理宝贵的资源——线程</h3><p>原因：线程池的使用</p><p>注意：</p><ol><li>线程池过多造成OOM 因为活跃线程过多和线程池不会被回收 </li><li>Java Stream Api异步分流 公用一个默认forkjion线程池，使用时要注意</li><li>线程池创建时要分析执行任务是IO资源型还是CPU资源型 </li><li>IO资源型或者说执行较长时间任务，并且拒绝策略为Call时，会在线程池满状态后交给<strong>调用者</strong>线程执行，如果是Web服务跑在tomcat⬆️的话，就导致整体吞吐量下降</li></ol><h3 id="管理宝贵的资源——连接池"><a href="#管理宝贵的资源——连接池" class="headerlink" title="管理宝贵的资源——连接池"></a>管理宝贵的资源——连接池</h3><ol><li>池化技术的核心在于，在鱼塘养好一群鱼，需要的时候就从里面拿一条，用完再放回去。而不是自己生产一条鱼，然后用完就销毁。从而减少了开销。</li><li>大多已经实现的连接池，都是有线程安全处理的。通常比个人创建管理连接更加安全。 </li><li>使用了连接池技术，就要保证连接池能够被有效复用。频繁创建连接池比频繁创建链接更加耗费资源。 </li><li>连接池的参数配置要根据实际情况，并不存在多多益善</li><li>连接池的主要好处：（1）减少资源消耗，（2）利用现有的线城安全实现，（3）提升并发量</li></ol><h3 id="Http调用超时、重试、并发问题"><a href="#Http调用超时、重试、并发问题" class="headerlink" title="Http调用超时、重试、并发问题"></a>Http调用超时、重试、并发问题</h3><ol><li>超时：<ol><li>连接超时代表建立 TCP 连接的时间</li><li>读取超时代表了等待远端返回数据的时间，也包括远端程序处理的时间。</li><li>在解决问题时，要考虑清楚连接的对象是谁（用户一般连接的是nginx），根据下游服务和自身服务设定合适的读取超时时间；</li><li>根据FeignClient配置规则修改配置后，检验是否生效</li></ol></li><li>重试：<ol><li>原因：网络丢包是比较常见的、查询是无状态的；</li><li>注意：考虑上下游接口的幂等性是否关闭自动重试；</li></ol></li><li>并发：包括 HttpClient 在内的 HTTP 客户端以及浏览器，都会限制客户端调用的最大并发数。</li></ol><h3 id="Spring声明式事务的使用"><a href="#Spring声明式事务的使用" class="headerlink" title="Spring声明式事务的使用"></a>Spring声明式事务的使用</h3><p>总结: ① 事务不生效的情况，事务注解加在private方法上、事务方法中调用的是内部this调用的方法而不是self     ②事务生效却出异常不回滚的情况，事务异常没有被传播出注解方法而是被捕获了、被事务注解的方法抛出的是受检异常导致不回滚 ③主方法提交，子方法出错不提交的做法: 子方法上注解加上 propagation = Propagation.REQUIRES_NEW 来设置 REQUIRES_NEW 方式的事务传播策略，也就是执行到这个方法时需要开启新的事务，并挂起当前事务</p><h3 id="数据库索引问题"><a href="#数据库索引问题" class="headerlink" title="数据库索引问题"></a>数据库索引问题</h3><p>过早的优化，是万恶之源。不需要提前考虑建立索引。等性能出现问题，真正的需求降临的时候再考虑优化。 建立索引之前，需要考虑索引带来的副作用：维护成本，空间成本，回表成本。 更重要的是还要考虑，你的查询是否能用到索引。如果花费大量成本建立的索引，最后还用不上。那就赔了夫人又折兵了。 索引又牵扯到了很多注意事项，例如：尽量使用前缀匹配，而避免使用后缀匹配。因为后缀匹配会使得索引失效，走全表匹配。</p><h3 id="数值计算的精度、舍入和溢出问题"><a href="#数值计算的精度、舍入和溢出问题" class="headerlink" title="数值计算的精度、舍入和溢出问题"></a>数值计算的精度、舍入和溢出问题</h3><p>手机计算器把 10%+10% 算成了 0.11 而不是 0.2。 出现这种问题的原因在于，国外的计算程序使用的是单步计算法。在单步计算法中，a+b% 代表的是 a*(1+b%)。所以，手机计算器计算 10%+10% 时，其实计算的是 10%*（1+10%），所以得到的是 0.11 而不是 0.2。</p><ol><li>使用 BigDecimal 表示和计算浮点数，应该使用 String 入参的构造方法或者 BigDecimal.valueOf 方法来初始化。</li><li>对于浮点数的格式化</li><li>如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法;如果结合 HashSet 或 HashMap 使用的话,使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。</li></ol><h3 id="文件读写中的问题"><a href="#文件读写中的问题" class="headerlink" title="文件读写中的问题"></a>文件读写中的问题</h3><p>第一，如果需要读写字符流，那么需要确保文件中字符的字符集和字符流的字符集是一致的，否则可能产生乱码。 </p><p>第二，使用 Files 类的一些流式处理操作，注意使用 try-with-resources 包装 Stream，确保底层文件资源可以释放，避免产生 too many open files 的问题。 </p><p>第三，进行文件字节流操作的时候，一般情况下不考虑进行逐字节操作，使用缓冲区进行批量读写减少 IO 次数，性能会好很多。一般可以考虑直接使用缓冲输入输出流 BufferedXXXStream，追求极限性能的话可以考虑使用 FileChannel 进行流转发。</p><h3 id="OOM有关的问题"><a href="#OOM有关的问题" class="headerlink" title="OOM有关的问题"></a>OOM有关的问题</h3><ol><li>我们的程序确实需要超出 JVM 配置的内存上限的内存。</li><li>内存泄漏，其实就是我们认为没有用的对象最终会被 GC，但却没有。强引用的选择使用；</li><li>不合理的资源需求配置，在业务量小的时候可能不会出现问题，但业务量一大可能很快就会撑爆内存。Tomacat</li></ol><p>解决办法：为生产系统的程序配置 JVM 参数启用详细的 GC 日志，方便观察垃圾收集器的行为，并开启 HeapDumpOnOutOfMemoryError，以便在出现 OOM 时能自动 Dump 留下第一问题现场。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">XX:+HeapDumpOnOutOfMemoryError</span> <span class="string">-XX:HeapDumpPath=.</span> <span class="string">-XX:+PrintGCDateStamps</span> <span class="string">-XX:+PrintGCDetails</span> <span class="string">-Xloggc:gc.log</span> <span class="string">-XX:+UseGCLogFileRotation</span> <span class="string">-XX:NumberOfGCLogFiles=10</span> <span class="string">-XX:GCLogFileSize=100M</span></span><br></pre></td></tr></table></figure><h3 id="反射、注解、泛型的坑"><a href="#反射、注解、泛型的坑" class="headerlink" title="反射、注解、泛型的坑"></a>反射、注解、泛型的坑</h3><ol><li></li></ol><h3 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h3><ol><li>spring容器管理对象默认是单例模式，可能会导致内存泄露问题；</li></ol><h2 id="设计篇"><a href="#设计篇" class="headerlink" title="设计篇"></a>设计篇</h2><h3 id="解决代码重复"><a href="#解决代码重复" class="headerlink" title="解决代码重复"></a>解决代码重复</h3><ol><li><p>利用工厂设计模式和模版设计方法</p><p>​        我们可以考虑提取相同逻辑在父类中实现，差异逻辑通过抽象方法留给子类实现。</p></li><li><p>通过反射+注解的方式</p><p>​        使用硬编码的方式重复实现相同的数据处理算法。我们可以考虑把规则转换为自定义注解，作为元数据对类或对字段、方法进行描述，然后通过反射动态读取这些元数据、字段或调用方法，实现规则参数和规则定义的分离。也就是说，把变化的部分也就是规则的参数放入注解，规则的定义统一处理。</p></li><li><p>利用属性拷贝工具消除重复代码</p></li></ol><p>注意：可以把代码重复度作为评估一个项目质量的重要指标，如果一个项目几乎没有任何重复代码，那么它内部的抽象一定是非常好的。在做项目重构的时候，可以以消除重复为第一目标去考虑实现。</p><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。</p><ol><li>针对响应体的设计混乱、响应结果的不明确问题，服务端需要明确响应体每一个字段的意义，以一致的方式进行处理，并确保不透传下游服务的错误。</li><li>接口版本控制问题。解决不兼容问题</li><li>针对接口的处理方式，需要明确要么是同步要么是异步。</li></ol><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><ol><li>不要把Redis作为数据库使用；Redis 的特点是，处理请求很快，但无法保存超过内存大小的数据。</li><li>把reids作为缓存使用时的注意事项：<ol><li>从客户端的角度来说，缓存数据的特点一定是有原始数据来源，且允许丢失；当数据丢失后，我们需要从原始数据重新加载数据，不能认为缓存系统是绝对可靠的，更不能认为缓存系统不会删除没有过期的数据。</li><li>从 Redis 服务端的角度来说，缓存系统可以保存的数据量一定是小于原始数据的。首先，我们应该限制 Redis 对内存的使用量，也就是设置 maxmemory 参数；其次，我们应该根据数据特点，明确 Redis 应该以怎样的算法来驱逐数据。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20230306151954911.png" alt="image-20230306151954911" style="zoom:30%;" /></li></ol></li><li><strong>缓存雪崩问题</strong><ul><li>原因：第一是缓存系统本身不可用；第二是应用设计层面大量的 Key 在同一时间过期，导致大量的数据回源。</li><li>解决办法：<ul><li>方案一：差异化设置缓存TTL。增加扰动值；</li><li>方案二：让缓存永不过期。设置一个后台进程，30s一次把全量数据更新到缓存</li></ul></li><li>注意：不管是方案一还是方案二，在把数据从数据库加入缓存的时候，都需要判断来自数据库的数据是否合法，比如进行最基本的判空检查。生产事故eg：DBA归档数据库（类似删除），从数据库中查询到了空数据加入缓存，爆发了大面积的事故。</li></ul></li><li><strong>缓存击穿问题</strong><ul><li>原因：某个热点key失效，大量并发请求昂贵回源；</li><li>方案：<ul><li>方案一，使用进程内的锁进行限制，这样每一个节点都可以以一个并发回源数据库； </li><li>方案二，不使用锁进行限制，而是使用类似 Semaphore 的工具限制并发数，比如限制为 10，这样既限制了回源并发数不至于太大，又能使得一定量的线程可以同时回源。</li></ul></li></ul></li><li><strong>缓存穿透问题</strong><ul><li>原因：缓存没有起到压力缓冲的作用；</li><li>方案：<ul><li>方案一：对于不存在的数据，设置一个特殊的 Value 到缓存中；但是可能会导致大量无效key。</li><li>方案二：我们需要同步所有可能存在的值并加入布隆过滤器，这是比较麻烦的地方。如果业务规则明确的话，你也可以考虑直接根据业务规则判断值是否存在。</li></ul></li></ul></li><li><strong>缓存数据同步问题</strong><ul><li>原因：更新缓存信息/和更新数据库先后顺序？</li><li>注意：考虑数据一致性问题；删除、更新操作的幂等性；</li><li>方案：缓存中的数据不由数据更新操作主动触发，统一在需要使用的时候按需加载，数据更新后及时删除缓存中的数据即可。</li></ul></li><li>使用缓存系统的时候，要监控缓存系统的内存使用量、命中率、对象平均过期时间等重要指标，以便评估系统的有效性，并及时发现问题。</li></ol><h3 id="业务上生产线的问题"><a href="#业务上生产线的问题" class="headerlink" title="业务上生产线的问题"></a>业务上生产线的问题</h3><p>完整的应用监控体系一般由三个方面构成，包括日志 Logging、指标 Metrics 和追踪 Tracing。</p><p>管理者 ：面向过程管理——背结果</p><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ol><li><p>直接运行课件代码：</p><ol><li>pom文件：删除spring-boot-starter-actuator 依赖；redisson-spring-boot-starter 里exclude redisson-spring-boot-starter 依赖。</li><li>对应的@SpringBootApplication 注解上添加exclude = { DataSourceAutoConfiguration.class, RedissonAutoConfiguration.class }</li></ol></li><li><p>解决IDEA配置.gitignore不生效的问题</p><ol><li><p>原因：**.gitignore只能忽略未被track的文件，<strong>而git本地缓存。</strong>如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的**。</p></li><li><p>解决办法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r <span class="comment">--cached .</span></span><br><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure></li></ol></li><li></li></ol><!-- more -->]]></content>
    
    
    <summary type="html">&lt;center&gt;极客时间&lt;/center&gt;</summary>
    
    
    
    <category term="-JAVA" scheme="https://wendaoit.github.io/categories/JAVA/"/>
    
    
    <category term="-JAVA -学习" scheme="https://wendaoit.github.io/tags/JAVA-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>线段树（区间树）</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>线段树（区间树）</center><p>​        为什么要有线段树？比如现在有一个数组，要计算和查赵这个数组中某个区间的值的和，那么它的时间复杂度就是O(n),要遍历数组；而如果使用树结构，他的时间复杂度为O(logn)；差距还是很大的</p><span id="more"></span><h3 id="什么是线段树？"><a href="#什么是线段树？" class="headerlink" title="什么是线段树？"></a>什么是线段树？</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823134438439.png" alt="image-20210823134438439" style="zoom:50%;" /><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li><p>​    线段树不是完全二叉树<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823135312682.png" alt="image-20210823135312682" style="zoom:50%;" /></p></li><li><p>线段树也是平衡二叉树</p></li></ul><h3 id="用数组实现，开辟空间，定义左子树和右子树"><a href="#用数组实现，开辟空间，定义左子树和右子树" class="headerlink" title="用数组实现，开辟空间，定义左子树和右子树"></a>用数组实现，开辟空间，定义左子树和右子树</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824101136411.png" alt="image-20210824101136411" style="zoom:50%;" /><h3 id="创建线段树："><a href="#创建线段树：" class="headerlink" title="创建线段树："></a>创建线段树：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824093203026.png" style="zoom:50%;" /></h3><h3 id="线段树的区间查询操作"><a href="#线段树的区间查询操作" class="headerlink" title="线段树的区间查询操作"></a>线段树的区间查询操作</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824093607084.png" alt="image-20210824093607084" style="zoom:50%;" /><h3 id="线段树的更新操作"><a href="#线段树的更新操作" class="headerlink" title="线段树的更新操作"></a>线段树的更新操作</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824095553046.png" alt="image-20210824095553046" style="zoom:80%;" /><p>​    Lazy更新</p><h4 id="链式动态线段树"><a href="#链式动态线段树" class="headerlink" title="链式动态线段树"></a>链式动态线段树</h4><p>不浪费空间</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824095756869.png" alt="image-20210824095756869" style="zoom:50%;" /><h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul><li>leetcode第303题区域和检查</li><li>leetcode第307题区域和检查美版UPDATe</li><li>树状数组（了解）BIT</li><li>RMQ问题</li></ul><!-- more -->]]></content>
    
    
    <summary type="html">&lt;center&gt;线段树（区间树）&lt;/center&gt;

&lt;p&gt;​        为什么要有线段树？比如现在有一个数组，要计算和查赵这个数组中某个区间的值的和，那么它的时间复杂度就是O(n),要遍历数组；而如果使用树结构，他的时间复杂度为O(logn)；差距还是很大的&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wendaoit.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="二叉树" scheme="https://wendaoit.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="链表" scheme="https://wendaoit.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="线段树" scheme="https://wendaoit.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>经典红黑树</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E7%BB%8F%E5%85%B8%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E7%BB%8F%E5%85%B8%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>红黑树</center><span id="more"></span><p>先介绍下2——3树</p><h4 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h4><p><strong>性质</strong>：</p><ul><li>满足二分搜索树的基本性质</li><li>节点可以存放一个或者两个元素</li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825181737508.png" alt="image-20210825181737508" style="zoom:50%;" /></li><li>2-3树是一棵<strong>绝对平衡</strong>的树</li></ul><h4 id="2-3树如何维持绝对平衡的？"><a href="#2-3树如何维持绝对平衡的？" class="headerlink" title="2-3树如何维持绝对平衡的？"></a>2-3树如何维持绝对平衡的？</h4><p>​        在插入数据的时候不会放在null的位置，if null就和parent节点暂时相融合变成3节点或者4节点如图：</p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825182718575.png" alt="image-20210825182718575" style="zoom: 50%;" /><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825182857559.png" alt="image-20210825182857559" style="zoom: 50%;" /> <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825182949188.png" alt="image-20210825182949188" style="zoom: 50%;" /></p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825183001986.png" alt="image-20210825183001986" style="zoom: 50%;" /><h4 id="红黑树与2-3树的等价性"><a href="#红黑树与2-3树的等价性" class="headerlink" title="红黑树与2-3树的等价性"></a>红黑树与2-3树的等价性</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825183847374.png" alt="image-20210825183847374" style="zoom:67%;" /><p>b—c连接线变成红色的b变为红色的</p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825190929549.png" alt="image-20210825190929549" style="zoom:80%;" /><p>定义一个红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comprarable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACk = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            color = RED;<span class="comment">//默认创建的节点为红色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="《算法导论》中的红黑树"><a href="#《算法导论》中的红黑树" class="headerlink" title="《算法导论》中的红黑树"></a>《算法导论》中的红黑树</h4><ol><li>每个节点或者是红色的，或者是黑色的；</li><li>根节点是黑色的；</li><li>每个叶子节点（最后的空节点）是黑色的；</li><li>如果一个节点是红色的，那么它的孩子节点是黑色的；</li><li>从任意一个节点到叶子节点，经过的黑色节点是一样的；</li></ol><p>保持“<strong>黑平衡</strong>”的二叉树，严格意义上，不是平衡二叉树；</p><p>最大高度：2logn<strong>时间复杂度还是</strong>O(Logn)</p><h4 id="红黑树中添加元素"><a href="#红黑树中添加元素" class="headerlink" title="红黑树中添加元素"></a>红黑树中添加元素</h4><ul><li>红黑树添加新元素（了解）</li></ul><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826143441667.png" alt="image-20210826143441667" style="zoom:67%;" /><h4 id="红黑树的性能总结"><a href="#红黑树的性能总结" class="headerlink" title="红黑树的性能总结"></a>红黑树的性能总结</h4><ul><li>对于完全随机的数据，普通的二分搜索树很好用；</li><li>对于查询较多的使用情况，AVL树很好用；</li><li>红黑树牺牲了平衡性（2logn的高度）</li></ul><p>统计性能更优（增删改查平均情况下更优）</p><p>​        整个红黑树的查找，插入和删除都是 O (logN) 的，原因就是整个红黑树的高度是 logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是 logN。</p><h4 id="红黑树的底层应用"><a href="#红黑树的底层应用" class="headerlink" title="红黑树的底层应用"></a>红黑树的底层应用</h4><ul><li> linux 中进程的调度用的是红黑树；</li><li>Java 中 HashMap、TreeMap、TreeSet（都在内存中操作）也都是用红黑树实现；</li></ul><h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><ul><li>好文：<a href="https://segmentfault.com/a/1190000023651273">数据结构之红黑树</a></li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;红黑树&lt;/center&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wendaoit.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="红黑树" scheme="https://wendaoit.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="2-3树" scheme="https://wendaoit.github.io/tags/2-3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记</title>
    <link href="https://wendaoit.github.io/2023/03/07/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://wendaoit.github.io/2023/03/07/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-07T06:53:39.086Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>读书笔记</center><span id="more"></span><h1 id="《李松蔚：认知思维》"><a href="#《李松蔚：认知思维》" class="headerlink" title="《李松蔚：认知思维》"></a>《李松蔚：认知思维》</h1><h2 id="认识思维"><a href="#认识思维" class="headerlink" title="认识思维"></a>认识思维</h2><p>认识心理学的规律，掌握规律；</p><h2 id="看清问题的本质（认识问题）"><a href="#看清问题的本质（认识问题）" class="headerlink" title="看清问题的本质（认识问题）"></a>看清问题的本质（认识问题）</h2><ol><li><p>如何用想法改变想法</p><p>认识到自己的想法只是想法；</p></li><li><p>了解什么是自动化思维</p><p>遇到一件事，我们的本能反应（刻板印象）就是一种自动化思维的体现；</p></li><li><p>了解信念对人的影响</p><p>认识到每个人都有看待世界不同的眼镜，也就是不同的信念；</p></li><li><p>了解升级认知的方法</p><p>了解大脑中的“快慢思维”，遇到问题可以进行换位思考，提高认知；升级认知也是为了明确责任划分和解决问题；</p></li></ol><h2 id="找到问题的关键"><a href="#找到问题的关键" class="headerlink" title="找到问题的关键"></a>找到问题的关键</h2><ol><li><p>掌握突破因果的思维方式</p><p>换位思考的具体落地，遇到问题从每个角度思考寻找原因，（个人、他人、不可抗因素）分别寻找原因，最终找到最好的解决办法；</p></li><li><p>了解“不同的认识”对人的影响</p><p>适度的风险是我们获得成长和经验的途径；风险一定是风险吗？我们的自动化思维会把“风险”看做一种警告信号，但是有的人会把他看做机会，这就是不同的认识。</p></li><li><p>了解如何用发展的角度看待问题</p><p>做事要有技巧，不要使蛮力，要学会用发展的眼光来看问题。</p><p>对于有生命的对象，变化是常态，除非是谁做了什么，它才会不变。问题不可能会由导致问题的方式所解决。——爱因斯坦</p><p>问题：总是想玩，没有时间学习、阅读。</p><p>答案：越是正确的事情，越是容易被坚持下来。</p></li><li><p>打破信念往往能带来全新的可能</p></li></ol><h2 id="建立说服的逻辑（该怎么说）"><a href="#建立说服的逻辑（该怎么说）" class="headerlink" title="建立说服的逻辑（该怎么说）"></a>建立说服的逻辑（该怎么说）</h2><ol><li><p>掌握合作的思维模式</p><ol><li>牢记这一点，需要我们时刻保持开放的心态。看到别人不一样的地方，要认识到谁都没有错，只是我们不一致。</li><li>我满足你的要求，然后再提出自己的要求。</li></ol></li><li><p>建设领导力的基础</p><p>我看到的东西是我的，我被你看到的东西，那都是你的。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221122192533511.png" alt="image-20221122192533511" style="zoom:50%;" /></p></li><li><p>为什么总是受别人的影响？（自我授权）</p><p>明白责任和权力的关系；主动改变一个事情的同时就要改变自己承担的责任；</p></li><li><p>了解跳出自我的方法（打破思维的限制）</p><p>角色的价值，存在于和别人的交互当中。</p><p>比如我们在卖一个产品的时候，要考虑别人怎么用；</p><p>​        你的还是你的，不因为谁用谁不用而变。所以，不需要总是把目光在自己身上，想着【你】要呈现给别人什么。不是的。这个世界最有趣的地方就在于每个人都有自己的视角。没有人真的在看【你】，他们都在看对自己有用的东西，那么你就顺着来，找到一种恰如其分的方式，让他们得到满足。你也就影响了他们。他们喜欢你，讨厌你，都跟你无关，都是你影响他们的方式。你越理解这一点，就越具有对这个世界的影响力。</p></li></ol><h2 id="掌控人生的规律（该怎么活）"><a href="#掌控人生的规律（该怎么活）" class="headerlink" title="掌控人生的规律（该怎么活）"></a>掌控人生的规律（该怎么活）</h2><ol><li><p>了解”意义“的重要性</p><p>意义的价值在于独特性。所以主动的发现自己的独特性，发挥自己的特点，找到人生的意义才是最重要的；</p></li><li><p>用联结发现意义</p><ol><li>跟具体的人，跟某个事物，跟观念之间的联结，是我们意义感的三大来源<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221123221107608.png" alt="image-20221123221107608" style="zoom:50%;" /></li><li>就像上学的时候老师说：你学习是为了别人吗？不是啊，是为了你们自己！我们好像觉得这样是更高尚的：不要为了谁去做一件事情，就是为了自己。错了，这句话根本没有解决这个问题。这恰恰造成了很多人找不到意义，如果你做这个事情只跟自己有关，这个事情做或者不做，做得好或者不好，你感受不到对别人有任何差别，那就像开头我们说的那个戒烟的男生一样，你做了，你也觉得没有意思。做着做着你就不想做了。</li></ol><p>所以，为了好好做一件事情，做得开心，做得来劲，你恰恰需要问自己的是：我是为了谁，或者为了什么，才做这件事的？——在这件事情里，我看到的不是只有我一个人。</p><p>把自己的很多事，放到关系的背景里，变成一件有意义的事情。为生活找到更多的联结，从而发现不一样的意义。</p></li><li><p>我们建立意义感的过程，其实就是我们放弃掌控的过程。我们越是意识到很多事情不在我们的掌控当中，我们试图去理解别人的意志，去理解时代的意志，去理解更大的，更超验的那些命题，我们就越是会知道自己在这个过程里扮演了怎样的角色，看到我的意义在哪里。</p></li><li><p>理解孤独和独立</p><p>保持自己的独立性，摆脱工具性的存在；</p></li></ol><h1 id="《个人职场的顶层设计》"><a href="#《个人职场的顶层设计》" class="headerlink" title="《个人职场的顶层设计》"></a>《个人职场的顶层设计》</h1><h2 id="职场之路的顶层设计"><a href="#职场之路的顶层设计" class="headerlink" title="职场之路的顶层设计"></a>职场之路的顶层设计</h2><ol><li><p>敢于走出舒适区</p></li><li><p>做任何事都需要有备而来<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126150744978.png" alt="image-20221126150744978" style="zoom: 25%;" /></p></li><li><p>选择比努力更重要<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126150821147.png" alt="image-20221126150821147" style="zoom:33%;" /></p></li><li><p>选择自己要走的路，承担相应的风险就要接受相应的回报</p></li><li><p>学会计算自己给企业创造的价值<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126151046103.png" alt="image-20221126151046103" style="zoom:50%;" /></p></li><li><p>自我管理的提升——先做该做的事，再做想做的事。</p></li><li><p>学会自我激励（责任心、事业心、上进心）</p></li><li><p>一步一步脚踏实地</p><p>不想当将军的士兵才是好士兵。</p></li><li><p>客观的才是正确的The preception is truth.</p></li><li><p>学习技能，提高自己的竞争力。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126152109974.png" alt="image-20221126152109974" style="zoom:50%;" /></p></li><li><p>企业的顶层设计</p><p>企业的顶层设计有五个内涵：<strong>从后往前看、系统化思考、利他化驱动、剧本化分工、图形化描述。</strong></p><p>从后向前看是指用终局思维来思考企业想要达到什么样的目标，倒推现在应该怎么做。</p><p>系统化思考是要找到问题的根本解，不能“头疼医头，脚疼医脚”。</p><p>利他化驱动是做事情先要为他人着想，考虑别人舒服不舒服，这样才能达到达到双赢。</p><p>剧本化分工是在操作模式上像剧本一样先进行干转、预演。</p><p>图形化描述是要通过传递有画面感的语言，让人可以想象将来的生活。</p></li></ol><h2 id="如何制定-个人的顶层设计"><a href="#如何制定-个人的顶层设计" class="headerlink" title="如何制定 个人的顶层设计"></a>如何制定 个人的顶层设计</h2><h5 id="一、提升自身价值"><a href="#一、提升自身价值" class="headerlink" title="一、提升自身价值"></a><strong>一、提升自身价值</strong></h5><ol><li><p><strong>想清楚企业靠什么生存</strong></p><ol><li>如果在市场经济条件下，用心做事、追求完美、掌握技能、创造价值才能够得到客户的青睐。</li><li>高建华老师当时学习的每个产品都要演讲五个片子。第一，我们在这个领域的世界地位是什么？第二，产品的特点是什么？第三，我们的产品比竞争对手的产品好在哪儿？第四，我们的产品能给你带来什么独到的价值？第五，我们有哪些产品型号和价格供你选择？</li></ol></li><li><p><strong>成为不可抹去的优秀人才</strong></p><p>1234法则：学会一个人挣两个人的钱，干三个人的活，创造四个人的效益。</p></li></ol><h5 id="二、做人做事的原则"><a href="#二、做人做事的原则" class="headerlink" title="二、做人做事的原则"></a><strong>二、做人做事的原则</strong></h5><ol><li><p>学会做人–（拒绝撒谎、保持谦卑）</p></li><li><p>学会做事</p><ol><li><p><strong>学会用规定动作</strong>。</p><p>一个企业的管理水平越高，它的规定动作越多。</p></li><li><p>一次就把事情做好。</p><p>一次做对需要进行干转和预演。干转是Dry run。比如说国家要改变个人所得税，不能轻易地改，要把现有的数据放到系统里干转一年，用产生的数据再来做决策。预演是Rehearsal，比如大会、电视节目、婚礼等都会有预演。</p></li><li><p><strong>学会用问话开头。</strong></p></li></ol></li></ol><h5 id="三、提升自身价值的九个方法"><a href="#三、提升自身价值的九个方法" class="headerlink" title="三、提升自身价值的九个方法"></a><strong>三、提升自身价值的九个方法</strong></h5><ol><li>静下心来练真功夫；</li><li>学会照镜子</li><li>学会一件事会做了之后，要把它变成流程。</li><li>学会“找对人、问对话、做对事”，<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221201164659431.png" alt="image-20221201164659431" style="zoom:50%;" /></li><li><strong>学会做计划</strong>做计划之前就是要减少变量，找到变量背后不变的逻辑，消除焦虑。</li><li><strong>学会提炼</strong> ——写周报</li><li><strong>学会检查</strong></li><li>重视汇报，学会理解</li></ol><h2 id="正确理解“跳槽”对职业的影响"><a href="#正确理解“跳槽”对职业的影响" class="headerlink" title="正确理解“跳槽”对职业的影响"></a>正确理解“跳槽”对职业的影响</h2><ol><li><strong>盲目跳槽弊大于利</strong></li><li><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221201170213838.png" alt="image-20221201170213838" style="zoom:50%;" /></li><li>学会踏踏实实，苹果发现高建华老师一口气在惠普工作八年半，做事很踏实。</li><li>实力主力</li></ol><h2 id="如何成为“管理者”"><a href="#如何成为“管理者”" class="headerlink" title="如何成为“管理者”"></a>如何成为“管理者”</h2><ol><li><p>管理最基本的定义是通过他人把事情办好。</p></li><li><p>管理背后的逻辑一定是把员工的个人利益与公司的集体利益挂钩。</p><p>“咖啡时间”这是一套非常好的制度，</p></li><li><p> 启发员工去思考。给部下选择权，对自己负责。</p></li><li><p>管理者日常有四大类工作：任务设定、人才管理、绩效提升、质量保障。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221201172724100.png" alt="image-20221201172724100" style="zoom:50%;" /></p><h5 id="成为优秀管理者的五个建议"><a href="#成为优秀管理者的五个建议" class="headerlink" title="成为优秀管理者的五个建议"></a>成为优秀管理者的五个建议</h5><ol><li><p>一个好的管理者要教会别人提高效率，想办法鼓励那些绩效好的员工给大家分享经验，把成功的方法复制给大家</p></li><li><p><strong>要做到顶天立地</strong> 出了什么事故，管理者要首先承担责任，每一个事情都必须有第一责任人。</p></li><li><p>一个好的管理者不仅要能干，还要会讲。</p><p>陈述演讲要做到Point、Turn、Speak，Point是指先拿教鞭指着要讲的内容，Turn就是转过头来面向观众，Speak是讲述。</p></li><li><p>独立思考</p><p>要学会独立思考，不要总想着成为别人。中国社会现在有一个要命的风气，就是老看着别人好，习惯走别人走过的路，总是抄袭别人的。</p><p>中国的教育一直关注的都是孩子的缺点，这种挫折型的教育会对孩子的天性有太多的打压，实际上应该多关注孩子的优点，进行鼓励式教育，鼓励每个孩子发挥自己的兴趣和特长，做自己擅长做的事情，这样才有助于激发国民的创造性。</p></li><li><p>回归到员工个人利益上；</p></li></ol></li></ol><h2 id="如何反向管理者（交流）"><a href="#如何反向管理者（交流）" class="headerlink" title="如何反向管理者（交流）"></a>如何反向管理者（交流）</h2><ol><li>职场上，管理好我们的上司有八个实用的方法：做事要超过上司的期望值、做人要与上司的价值观一致、懂得为上司分忧、用脑思考用心做事、不要给上司添乱、让上司主动帮你做事、要经得住上司的考验、关键时刻露一手。</li></ol><h2 id="如何提升自己"><a href="#如何提升自己" class="headerlink" title="如何提升自己"></a>如何提升自己</h2><h1 id="《李忠秋：结构思考力》"><a href="#《李忠秋：结构思考力》" class="headerlink" title="《李忠秋：结构思考力》"></a>《李忠秋：结构思考力》</h1><h2 id="理解结构化思考力的理念"><a href="#理解结构化思考力的理念" class="headerlink" title="理解结构化思考力的理念"></a>理解结构化思考力的理念</h2><ol><li>结构化思考的金字塔结构来源于树形结构，为了达到纵向一体化和横向多元化。</li><li>关键在于：隐形思维显性化，快速地找出信息结构，把握重点，提高分析问题、解决问题以及表达问题的效率和效果；</li><li>面对纷繁复杂的信息，一定要有自己审视问题的坐标系，要学会总结自己的一些方法论；<ol><li>要重视思维能力的训练，多一些思考；</li></ol></li><li>在……的基础上，从xxx和yyy两个方面，说明……</li></ol><h2 id="如何拥有结构化的思考力"><a href="#如何拥有结构化的思考力" class="headerlink" title="如何拥有结构化的思考力"></a>如何拥有结构化的思考力</h2><ol><li>分类、总结、提炼；<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221211215340816.png" alt="image-20221211215340816" style="zoom:50%;" /></li><li>结构化思维：结论先行，依次阐明观点，再次总结观点</li><li>学会分类：3和7  核心：不重不漏（相互独立，完全穷尽）</li><li>学会逻辑顺序 从时间顺序、结构性顺序、重要性顺序递进</li></ol><h2 id="结构化思考力的展示"><a href="#结构化思考力的展示" class="headerlink" title="结构化思考力的展示"></a>结构化思考力的展示</h2><p>找到每个模块之间的联系，合理得利用图表结构可以更加高效得表达出自己结构化思考的内容；</p><ol><li><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221212180711763.png" alt="image-20221212180711763"></li><li><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221212181549075.png" alt="image-20221212181549075"></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>描述问题定方向<ol><li>利用5W2H方法搞清楚问题</li></ol></li><li>基于目标定主题<ol><li>明确目标受众，让表达有的放矢；</li><li>写好序言：情景-&gt;冲突-》疑问-&gt;回答</li><li>根据目标的疑问-回答，自上而下搭建内容框架</li></ol></li><li>说服更有力—演绎<ol><li>标准式演绎——大前提+小前提+结论</li><li>常见式演绎——现象+原因+对应的方法+结论</li></ol></li><li>要点更清晰—归纳<ol><li>封闭式分类——按照模型分类：金字塔、</li><li>开放式分类——四象限<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221214215456823.png" alt="image-20221214215456823" style="zoom:80%;" /></li></ol></li><li>配关系</li></ol><h1 id="《管理你的情绪》"><a href="#《管理你的情绪》" class="headerlink" title="《管理你的情绪》"></a>《管理你的情绪》</h1><p>​        人的情商包括认知自己的情绪、管理自己的情绪、有效地推动自己、认识别人的情绪、处理好人际关系。如果能够做好自己的情绪管理，就能够让自己达到高情商的状态，让自己拥有更多的财富、更好的社会关系、更健康的身体状态，让生活更加的成功。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221219204305575.png" alt="image-20221219204305575" style="zoom:30%;" /></p><p><strong>真正地认知情绪</strong></p><ol><li>作者认为：<strong>一个人在社会上要获得成功，起主要作用的不是智力因素，而是情绪智商，前者占20％，后者占80％</strong>。</li><li>一位心理学家<strong>丹尼尔·卡尔曼</strong>写了一本书《<strong>情商</strong>》，对情商做了系统的诠释。丹尼尔·卡尔曼认为人的情商由两个部分组成，<strong>第一个部分包括认知自己的情绪、管理自己的情绪、有效地推动自己，第二个部分包括认识别人的情绪、处理好人际关系。</strong></li><li><strong>情绪从来都不是问题，只是提示我们。</strong>大部分人都知道管理情绪，但是重要的是想不想去管理。</li></ol><p><strong>有效地情绪管理</strong></p><ol><li>管理自己的情绪有四个表现：通过有效的方法调节自己的情绪；配合情绪状态做事，不被情绪控制；读懂自己情绪背后的意义；改变产生情绪的根源。</li><li>有效地推动自己，包括四个阶段：有效设定自己的目标、认识到目标对自己的意义、了解自己的内在价值观、从“知道”到“做到”。</li></ol><p>当一个人知道自己在某一个场合应该是什么角色，那他就能够把人际关系处理得很好。处理好人际关系包含四个方面：在相互关系中认知自己的角色与价值、有效地表达自己的想法、有效倾听和换位思考、让对方感受到自我价值。</p><p>传统的情绪处理法如发泄、压抑、转移等，都是在处理情绪所带来的身体感受。<strong>作为成年人还需要从理性、感性、角色的角度进行情绪管理。</strong></p><h1 id="《tiny-habits：福格行为模型》"><a href="#《tiny-habits：福格行为模型》" class="headerlink" title="《tiny habits：福格行为模型》"></a>《tiny habits：福格行为模型》</h1><ol><li><p><strong>福格行为模型（BJ Foog’s Behaviour Model）</strong>来源于福格和美国说服技术实验室的研究，它是<strong>一种有效探寻行为原因的模型</strong>。</p><p>模型只包含三个基本元素：<strong>动机</strong>（Motivation）、<strong>能力</strong>（Ability）、<strong>触发条件</strong>（Trigger）</p><p><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221219100251268.png" alt="image-20221219100251268" style="zoom:50%;" />蓝色曲线以上的部分就是“一个用户行为可能发生的地方”。</p></li></ol><h3 id="提升动机"><a href="#提升动机" class="headerlink" title="提升动机"></a>提升动机</h3><ol><li><p>动机分为两种（在八角行为分析法中也有对内在、外在动机的具体分析）：</p><ol><li><strong>外在动机</strong>：来自目标、目的或奖励。</li><li><strong>内在动机</strong>：来自个人自身，包括成就感、好奇心以及满足感等。</li></ol><p>最优秀的设计是同时提供外在和内在两种动机。比如提供折扣（省钱的外部动机）以及学习某项技能或培养健康的习惯（实现目标的内在希望）。</p></li></ol><h3 id="增强能力"><a href="#增强能力" class="headerlink" title="增强能力"></a>增强能力</h3><p><strong>数字设计和产品应该从本质上提升用户的能力，超过他们使用相应非数字化产品的能力。</strong></p><p>比如用手机玩斗地主，你可以不用准备牌和洗牌，不用自己计算分数，还可以远程和朋友玩（原来必须线下聚在一起）。</p><p><strong>你的产品应该同时提升用户完成目标任务的能力以及使用实际产品的能力（操作简单）。</strong></p><p>你要明确哪些资源对于用户来说是最稀缺的，以及如何在设计中节约这些资源。</p><ul><li>如果用户有时间而没钱，那就让他们用你的产品来赚钱或省钱。</li><li>如果用户有钱而没时间，那就让他们支付额外的费用以更快地完成任务。</li><li>如果发现用户使用产品遇到太多困难，那就进行相应的用户研究，确定如何进行内容分类、设计标签文案以及提供有效的指引和常见问题的解答。</li></ul><h3 id="呈现有效的触发"><a href="#呈现有效的触发" class="headerlink" title="呈现有效的触发"></a>呈现有效的触发</h3><p><strong>用户需要意识到触发的存在，明白触发引发的结果是做出预期行为，并且用户的动机和能力要高于临界值才能激活触发并做出行为。</strong>也就说（要做且能做）</p><h3 id="实际生活中的应用"><a href="#实际生活中的应用" class="headerlink" title="实际生活中的应用"></a>实际生活中的应用</h3><p>关于养成一个习惯</p><ol><li>洗袜子、拖地、地铁上读书</li></ol><h1 id="《非暴力沟通》"><a href="#《非暴力沟通》" class="headerlink" title="《非暴力沟通》"></a>《非暴力沟通》</h1><h2 id="对于沟通的理解"><a href="#对于沟通的理解" class="headerlink" title="对于沟通的理解"></a>对于沟通的理解</h2><p>互联网时代商业的特点是用户主导、产品为王、体验至上、口碑传播。给企业最大的警钟是：做产品最重要的是客户至上。对于我们tob企业而言，客户又分为</p><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221226151533749.png" alt="image-20221226151533749" style="zoom:50%;" /><p>非暴力沟通以觉察、能量和意识为精髓，用观察、感受、需要、请求的不断重复来串联诚实表达、关切倾听、自我连接，为企业产品推广、亲子关系改善、个人成长等方面的变革提供了重要动力。我们如果能够带着意识去沟通，往往会事半功倍。</p><h2 id="学会去听"><a href="#学会去听" class="headerlink" title="学会去听"></a>学会去听</h2><p>听就是要用同理心去理解对方的核心需要，在管理中就是要知道一个人的目标。用耳朵管理员工的过程是邀请表达、静默倾听、确认状态。邀请表达是不断地用问题进行情感引导，不评判对方；保持静默是抑制内心的冲动，全身心地听对方表达的内容、情绪和意图；确认状态是不断地确认对方的观点，认可对方的情绪。听的三个层次：听事实、听情绪、听意图。</p><h2 id="学会去说"><a href="#学会去说" class="headerlink" title="学会去说"></a>学会去说</h2><p>《非暴力沟通》这本书里讲到克里希那穆提的一句话：“不带评论的观察是人类智慧的最高形式”。</p><p>学习了如何去说，首先说的基础是听懂对方话的事实、情绪和意图，第二是赢得理解，前提是不要把天聊死，然后要带着尊重和理解的心去表达对方的感受和需要。最终如果我们想要说服别人需要做到这四步：<strong>认真倾听、理解需要、表达核实、叠加请求。</strong></p><p>如果能够做到回归观察，就能平和地回到事实本身，把问题简单化，再加上一些提问的技巧不断确认对方的需要，就能解决企业50%的问题。</p><h2 id="管理沟通法则"><a href="#管理沟通法则" class="headerlink" title="管理沟通法则"></a><strong>管理沟通法则</strong></h2><p>​        惯性回应模式是人们对自己、他人进行表达的时候的一种语言偏好，表现为四种方式：怼他人、怼自己、听自己、听他人。领导者在做管理沟通之前要知道自己和对方所处的状态是什么、想要什么。还要遵循这三大法则：看见活生生的人，用心去连接；关注感受和需要，支持自己和他人；区分岗位和个人需要，多体会个人需要的意义。此外，如果领导者能够带有同理心地倾听和回应，做出简单明确、当下正向、可以操作的请求对于提高员工的行动力也会有显著的效果。</p><h2 id="非暴力沟通亲子实践"><a href="#非暴力沟通亲子实践" class="headerlink" title="非暴力沟通亲子实践"></a><strong>非暴力沟通亲子实践</strong></h2><h2 id="读书思考"><a href="#读书思考" class="headerlink" title="读书思考"></a>读书思考</h2><ol><li>本书中讲到的“别人眼中的自己才是真正的自己”和《认知思维》中“我们认为的自己才是真正的自己” 是冲突的；</li><li>一个员工做人要诚实、谦卑，做事要学会用规定动作、尽量一次把事情做好、用问话沟通，在工作过程中要学会做工作计划、学会训练、学会做工作流程、学会借力牛人、学会提炼、学会照镜子、学会增值、学会检查、学会理解等，这样才能提升自身价值。</li><li>职场第一课：发现问题——》分析问题——》对应的解决方案——》寻求资源——》落实（说到做到）</li><li>本书可以使我的思维更具有逻辑性、结构性，使我思考从大学到职场的真正思维模式的转变，值得反复学习；</li><li>学会如何写工作总结；</li><li></li></ol><!-- more -->]]></content>
    
    
    <summary type="html">&lt;center&gt;读书笔记&lt;/center&gt;</summary>
    
    
    
    <category term="-书籍" scheme="https://wendaoit.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="-阅读" scheme="https://wendaoit.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>浅学JAVA开发中异常处理</title>
    <link href="https://wendaoit.github.io/2023/03/07/2023-02-22-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://wendaoit.github.io/2023/03/07/2023-02-22-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2023-03-07T06:53:39.070Z</published>
    <updated>2023-03-07T06:53:39.070Z</updated>
    
    <content type="html"><![CDATA[<center>优雅处理异常</center><span id="more"></span><p>异常处理逻辑上的分类：</p><p>对于我们并不期望会发生的事，我们可以使用异常捕捉； </p><p>对于我们觉得可能会发生的事，使用返回码。</p><h2 id="springboot异常处理"><a href="#springboot异常处理" class="headerlink" title="springboot异常处理"></a>springboot异常处理</h2><ol><li><h4 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><ol><li>SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常 SpringBoot 会向/error 的 url 发送请求。</li><li>在 springBoot 中提供了一个叫 BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。</li><li>我们也可以重写、error方法，进行特定的返回处理。eg：/error/500,/error/404；</li><li>场景：不是前后端分离，返回页面；</li></ol></li><li><p>自己在controller层对指定异常进行try/catch捕获</p><ol><li><p>```java<br>@RequestMapping(“doCompute/{n1}/{n2}”)</p><pre><code>@ResponseBodypublic String doCompute(@PathVariable  Integer n1,                        @PathVariable Integer n2)&#123;    try&#123;        Integer result=n1/n2;        return &quot;Result is &quot;+result;    &#125;catch(ArithmeticException e)&#123;        return &quot;exception is &quot;+e.getMessage();    &#125;&#125;</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      一个Controller类中通常会有多个方法，这样多个方法中都写<span class="keyword">try</span>语句进行异常处理会带来大量重复代码的编写，不易维护。</span><br><span class="line"></span><br><span class="line">      使用场景：特定的返回结果；</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> #### <span class="meta">@ExceptionHandle</span> 注解处理异常</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> Controller内部定义异常处理方法</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">      <span class="meta">@ResponseBody</span></span><br><span class="line">      <span class="keyword">public</span> String doHandleArithmeticException(ArithmeticException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;计算过程中出现了异常，异常信息为&quot;</span>+e.getMessage();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>@ExceptionHandler注解描述的方法为异常处理方法(注解中的异常类型为可处理的异常类型)，假如Controller类中的逻辑方法中出现异常后没有处理异常，则会查找Controller类中有没有定义异常处理方法，假如定义了，且可以处理抛出的异常类型，则由异常处理方法处理异常。</p></li><li><p>@ControllerAdvice+@ExceptionHandler 全局处理异常</p><ol><li>```java<br>@RestControllerAdvice<br>@Slf4j<br>public class ExceptionAdvice {<pre><code>@ExceptionHandler(ArithmeticException.class)public String doHandleArithmeticException(ArithmeticException e)&#123;    e.printStackTrace();    return  &quot;计算过程中出现了异常，异常信息为&quot;+e.getMessage();&#125;</code></pre><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="number">2.</span> @RestControllerAdvice 注解描述的类为全局异常处理类，当控制层方法中的异常没有自己捕获,也没有定义其内部的异常处理方法，底层默认会查找全局异常处理类，调用对应的异常处理方法进行异常处理。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> #### 自定义的异常类以及枚举类（优化）</span><br><span class="line"></span><br><span class="line">   上述的示例中，我们对捕获的异常进行简单的二次处理，返回异常的信息，虽然这种能够让我们知道异常的原因，但是在很多的情况下来说，可能还是不够人性化，不符合我们的要求。</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 定义一个错误码ErrorCode <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line">      ```<span class="symbol">java</span></span><br><span class="line">      <span class="symbol">public</span> <span class="symbol">interface</span> <span class="symbol">BaseErrorInfoInterface</span> &#123;</span><br><span class="line">          <span class="comment">/** 错误码*/</span></span><br><span class="line">          <span class="built_in">int</span> getCode();</span><br><span class="line">      </span><br><span class="line">          <span class="comment">/** 错误描述*/</span></span><br><span class="line">          String getMessage();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>实现一个错误码枚举类并实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CommonEnum</span> <span class="keyword">implements</span> <span class="title">BaseErrorInfoInterface</span></span>&#123;</span><br><span class="line">    BODY_NOT_MATCH(<span class="number">400</span>,<span class="string">&quot;请求的数据格式不符!&quot;</span>),</span><br><span class="line">    SIGNATURE_NOT_MATCH(<span class="number">401</span>,<span class="string">&quot;请求错误!&quot;</span>),</span><br><span class="line">    NOT_FOUND(<span class="number">404</span>, <span class="string">&quot;未找到该资源!&quot;</span>),</span><br><span class="line">    INTERNAL_SERVER_ERROR(<span class="number">500</span>, <span class="string">&quot;服务器内部错误!&quot;</span>),</span><br><span class="line">    SERVER_BUSY(<span class="number">503</span>,<span class="string">&quot;服务器正忙，请稍后再试!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**错误码*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    CommonEnum(<span class="keyword">int</span> code, String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们在来自定义一个异常类，用于处理我们发生的业务异常和内部异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String errorMsg;</span><br><span class="line">    <span class="comment">//默认无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(BaseErrorInfoInterface errorInfoInterface)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorInfoInterface.getMessage());</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorInfoInterface.getCode();</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorInfoInterface.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(BaseErrorInfoInterface errorInfoInterface, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorInfoInterface.getMessage(), cause);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorInfoInterface.getCode();</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorInfoInterface.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(String errorMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg, cause);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorCode</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 对性能的影响</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BizException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;errorCode=&quot;</span> + errorCode +</span><br><span class="line">                <span class="string">&quot;, errorMsg=&#x27;&quot;</span> + errorMsg + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义全局捕获处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(annotations = Controller.class)</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doHandleArithmeticException</span><span class="params">(ArithmeticException e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历堆栈信息并储存</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element:e.getStackTrace())&#123;</span><br><span class="line">            log.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;计算过程中出现了异常，异常信息为&quot;</span>+e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义的业务异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = BizException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ResultBody <span class="title">bizExceptionHandler</span><span class="params">(HttpServletRequest req, BizException e)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;发生业务异常！原因是：&#123;&#125;&quot;</span>,e.getErrorMsg());</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(e.getErrorCode(),e.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理空指针的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value =NullPointerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBody <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest req, NullPointerException e)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;发生空指针异常！原因是:&quot;</span>,e);</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(CommonEnum.BODY_NOT_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理其他异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(Exception e, HttpServletRequest httpRequest, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;服务器发生异常&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//遍历堆栈信息并储存</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element:e.getStackTrace())&#123;</span><br><span class="line">            log.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line">         String requestHeader = httpRequest.getHeader(<span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (requestHeader.equals(<span class="string">&quot;XMLHttpRequest&quot;</span>))&#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            writer.write(CommunityUtils.getJSONString(<span class="number">1</span>,<span class="string">&quot;服务器异常&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            response.sendRedirect(httpRequest.getContextPath() + <span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务异常输出示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>-09-<span class="number">22</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">24</span>,<span class="number">032</span> ERROR [http-nio-<span class="number">8081</span>-exec-<span class="number">4</span>] t.t.c.c.a.ExceptionAdvice [ExceptionAdvice.java:<span class="number">46</span>] 发生业务异常！原因是：用户姓名不能为空！</span><br><span class="line"><span class="number">2022</span>-09-<span class="number">22</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">24</span>,<span class="number">036</span> WARN [http-nio-<span class="number">8081</span>-exec-<span class="number">4</span>] o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver [AbstractHandlerExceptionResolver.java:<span class="number">208</span>] Resolved [BizException&#123;errorCode=-<span class="number">1</span>, errorMsg=<span class="string">&#x27;用户姓名不能为空！&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="实际开发中遇到的问题和最佳实践"><a href="#实际开发中遇到的问题和最佳实践" class="headerlink" title="实际开发中遇到的问题和最佳实践"></a>实际开发中遇到的问题和最佳实践</h3><p>第一，注意捕获和处理异常的最佳实践。首先，不应该用 AOP  对所有方法进行统一异常处理，异常要么不捕获不处理，要么根据不同的业务逻辑、不同的异常类型进行精细化、针对性处理；其次，处理异常应该杜绝生吞，并确保异常栈信息得到保留；最后，如果需要重新抛出异常的话，请使用具有意义的异常类型和异常消息。</p><p> 第二，务必小心 finally 代码块中资源回收逻辑，确保 finally 代码块不出现异常，内部把异常处理完毕，避免 finally  中的异常覆盖 try 中的异常；或者考虑使用 addSuppressed 方法把 finally 中的异常附加到 try  中的异常上，确保主异常信息不丢失。此外，使用实现了 AutoCloseable 接口的资源，务必使用 try-with-resources  模式来使用资源，确保资源可以正确释放，也同时确保异常可以正确处理。 </p><p>第三，虽然在统一的地方定义收口所有的业务异常是一个不错的实践，但务必确保异常是每次 new 出来的，而不能使用一个预先定义的 static  字段存放异常，否则可能会引起栈信息的错乱。</p><p> 第四，确保正确处理了线程池中任务的异常，如果任务通过 execute  提交，那么出现异常会导致线程退出，大量的异常会导致线程重复创建引起性能问题，我们应该尽可能确保任务不出异常，同时设置默认的未捕获异常处理程序来兜底；如果任务通过 submit 提交意味着我们关心任务的执行结果，应该通过拿到的 Future 调用其 get  方法来获得任务运行结果和可能出现的异常，否则异常可能就被生吞了。</p><h4 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a><strong>要注意的问题</strong></h4><ol><li>在哪一层进行抛出？应该在哪里抛，抛什么异常。</li></ol><p>A：比如 我们需要知道 参数为空报什么异常，对其进行捕获统一处理；</p><p>2、所有异常被吃掉，带来的严重的后果；</p><!-- more -->]]></content>
    
    
    <summary type="html">&lt;center&gt;优雅处理异常&lt;/center&gt;</summary>
    
    
    
    <category term="-JAVA" scheme="https://wendaoit.github.io/categories/JAVA/"/>
    
    
    <category term="-JAVA -学习" scheme="https://wendaoit.github.io/tags/JAVA-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树BST</title>
    <link href="https://wendaoit.github.io/2023/03/07/Day3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wendaoit.github.io/2023/03/07/Day3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-07T06:53:39.070Z</published>
    <updated>2023-03-07T06:53:39.070Z</updated>
    
    <content type="html"><![CDATA[<center>二叉搜索树</center><span id="more"></span><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol><li>定义：也是一种动态数据结构 ；</li></ol><p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210821130645690.png" alt="image-20210821130645690"></p><p>一个节点也是二叉树、null也是二叉树</p><h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><ul><li> 特点：每个节点的值</li><li>小于其右子树的所有结点的值；</li><li>大于其左子树所有结点的值；</li><li>储存的元素必须有可比较性；<del>意思是说不能存放重复数据</del></li></ul><h3 id="Set-AND-Map-可以理解为一种定义好的数据结构"><a href="#Set-AND-Map-可以理解为一种定义好的数据结构" class="headerlink" title="Set AND Map(可以理解为一种定义好的数据结构)"></a>Set AND Map(可以理解为一种定义好的数据结构)</h3><h4 id="Set–集合：不能有重复元素"><a href="#Set–集合：不能有重复元素" class="headerlink" title="Set–集合：不能有重复元素"></a>Set–集合：不能有重复元素</h4><p>因为二分搜索树不能存放重复元素，所以是非常好的实现“集合”的底层数据结构；</p><h4 id="二分搜索树的遍历"><a href="#二分搜索树的遍历" class="headerlink" title="二分搜索树的遍历"></a>二分搜索树的遍历</h4><p>都是从根结点出发，最后回到根结点</p><ol><li><p>前序遍历</p></li><li><p>```java<br> System.out.println(node.)<br> traverse(node.right);<br> traverse(node.left);</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 中序遍历</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    traverse(node.<span class="attribute">left</span>);</span><br><span class="line">    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(node.)</span><br><span class="line">    traverse(node.<span class="attribute">right</span>);</span><br></pre></td></tr></table></figure></li></ol><ul><li>（得到的结果是从小到大排列的）</li></ul><ol start="4"><li>后续遍历（eg:为二分搜索树释放内存）</li></ol><ul><li><pre><code class="java">traverse(node.right);traverse(node.left);System.out.println(node.)</code></pre></li></ul><h4 id="二分搜索树BST的顺序性特性："><a href="#二分搜索树BST的顺序性特性：" class="headerlink" title="二分搜索树BST的顺序性特性："></a>二分搜索树BST的顺序性特性：</h4><ul><li>求最大值和最小值</li><li>求floor和ceil</li><li>求Rank和select（维护SIZE）</li><li>改进后支持重复元素（进入左子树或者加一个COUNT）</li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;二叉搜索树&lt;/center&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wendaoit.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="二叉树" scheme="https://wendaoit.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="树结构" scheme="https://wendaoit.github.io/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
    <category term="八股文" scheme="https://wendaoit.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>常用的快捷键</title>
    <link href="https://wendaoit.github.io/2023/03/07/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://wendaoit.github.io/2023/03/07/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2023-03-07T06:53:39.070Z</published>
    <updated>2023-03-07T06:53:39.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><center>快捷键</center></h1><span id="more"></span><h2 id="MAC中快捷键"><a href="#MAC中快捷键" class="headerlink" title="MAC中快捷键"></a>MAC中快捷键</h2><table><thead><tr><th align="left"><strong>快捷键</strong></th><th>中文描述</th></tr></thead><tbody><tr><td align="left"></td><td>通知中心往下拉。勿扰快速开关</td></tr><tr><td align="left">ctrl+数字键</td><td>跳转到指定的数字书签</td></tr><tr><td align="left">cmd+2</td><td>显示收藏窗口 包括书签、收藏、断点</td></tr><tr><td align="left">ctrl+shift+数字键</td><td>定义数字书签</td></tr><tr><td align="left">Option+cmd+t</td><td>快速生成if、trycatch语句</td></tr><tr><td align="left">cmd +shift +U</td><td>快速转换为大小写</td></tr><tr><td align="left">cmd+shift+。</td><td>使用Finder查看Mac隐藏文件(.git等)</td></tr><tr><td align="left">cmd+R</td><td>在当前界面查找并替换</td></tr><tr><td align="left">cmd+F</td><td>在当前界面查找</td></tr><tr><td align="left">ctrl + option + o</td><td>快速清除无用包</td></tr><tr><td align="left">CMD+7</td><td>显示该类中所有的方法</td></tr><tr><td align="left">Shift +↑</td><td>逐行选中</td></tr><tr><td align="left">cmd+E</td><td>最近文件</td></tr><tr><td align="left">Option + 方向键上</td><td>连续选中代码块</td></tr><tr><td align="left">Command + N</td><td>生成代码（getter、setter、构造函数、hashCode/equals,toString）</td></tr><tr><td align="left">cmd+opt+⬅️/➡️</td><td>代码跳转</td></tr><tr><td align="left">Command + option + L</td><td>代码格式化</td></tr><tr><td align="left"></td><td></td></tr><tr><td align="left"></td><td></td></tr></tbody></table><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>选中CTRL+shift+左右</p><p>调整位置CTRL+shift+上下</p><p>主方法psvm</p><p>输出sout</p><p>Ctrl+n 查找xxx底层类和方法</p><p>Ctrl+/ 快速创建注释</p><p>Ctrl+F9 重新编译</p><p>弹出的方法大纲的快捷键是<br>MAC [Command + F12]<br>WIN [Ctrl + F12]</p><p>ctrl+shift+L整理代码</p><p>CTRL+shift+F全局搜索</p><p>实习收获：</p><ul><li><p>IDEA快速开发：</p><p>  \1. //TODO</p><p>  \2. CTRL+shift+1/2/3快速标记  CTRL+1/2/3 快速跳转</p><p>  \3. 查找 变量或者方法在代码中的使用find usages  ALT+F7</p><p>  \4. CTRL+shift+alt+C  直接复制对应代码行数</p><p>  \5. CTRL+SHIFT+N</p><p>  \6. CTRL+E打开最近关闭的文件</p><p>  \7. 删除行快捷键 ctrl+Y</p><p>  \8. 清除无用import包快捷键 ctrl+alt+o</p></li></ul><!-- more -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;&lt;center&gt;快捷键&lt;/center&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="-IDEA -MAC" scheme="https://wendaoit.github.io/categories/IDEA-MAC/"/>
    
    
    <category term="-导航 -分享" scheme="https://wendaoit.github.io/tags/%E5%AF%BC%E8%88%AA-%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>错误日志</title>
    <link href="https://wendaoit.github.io/2021/12/13/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
    <id>https://wendaoit.github.io/2021/12/13/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</id>
    <published>2021-12-13T00:00:00.000Z</published>
    <updated>2023-03-07T06:53:39.086Z</updated>
    
    <content type="html"><![CDATA[<center>记错（已解决问题）</center><span id="more"></span><ul><li><p>java: javacTask: 源发行版 8 需要目标发行版 1.8、</p><ul><li><p>1，Project Structure 里确认两个地方：Project sdk 以及 project language level</p><p>2，Project Structure-&gt;Modules 里 Sources 里的 Language level</p><p>3，settings-&gt;java Compiler -&gt;target bytecode Version</p><p>这些个地方需要一致。</p></li></ul></li><li><p><a href="https://segmentfault.com/q/1010000012008825">spring boot application.yml文件不生效</a></p><ul><li>端口号不生效： 配置文件严格·缩进·</li></ul></li><li><p><a href="https://blog.csdn.net/weixin_50707679/article/details/116609127">Maven 打包报错：jar:1.0-SNAPSHOT is missing</a></p><ul><li>后来突发奇想，把 maven.compiler.source 和 maven.compiler.target 标签给删了，然后就好了，相当于不人为指定了。也是给大家提供一个思路吧</li></ul></li><li><p>Nacos startup 无反应，启动报错的解决办法</p><ul><li><p>​    原因是 2.0.3 版本默认是以集群的模式去运行的，而我们本地并没有相关配置，我们只需要用单机模式去运行即可。</p><p>​    解决办法很简单，我们只需要修改一下 <strong>startup.cmd</strong> 里的代码配置即可。</p><p>右键 <strong>startup.cmd</strong> 选择编辑，反正能用编辑器打开就行。</p><p>​    可以看到默认的配置是 <code>set MODE=&quot;cluster&quot;</code></p><p>我们将其改成 <code>set MODE=&quot;standalone&quot;</code> 即可。</p><p>修改后保存，重新运行再看一下。</p></li></ul></li><li><p>nacos无法读取bootstrap.yml文件 </p><ul><li><p> 报错create config service error!properties=NacosConfigProperties{serverAddr=’null’,</p></li><li><p>添加依赖</p></li><li><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li></ul></li><li></li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;记错（已解决问题）&lt;/center&gt;</summary>
    
    
    
    <category term="-错误 -bug" scheme="https://wendaoit.github.io/categories/%E9%94%99%E8%AF%AF-bug/"/>
    
    
    <category term="-bug" scheme="https://wendaoit.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>关于健身.....</title>
    <link href="https://wendaoit.github.io/2021/11/15/20211115-%E5%85%B3%E4%BA%8E%E5%81%A5%E8%BA%AB/"/>
    <id>https://wendaoit.github.io/2021/11/15/20211115-%E5%85%B3%E4%BA%8E%E5%81%A5%E8%BA%AB/</id>
    <published>2021-11-15T00:00:00.000Z</published>
    <updated>2023-03-07T06:53:39.070Z</updated>
    
    <content type="html"><![CDATA[<center>《论每天健身的重要性》And《学习健身笔记》持续ing</center><span id="more"></span><h3 id="学习笔记（不一定对，欢迎讨论）"><a href="#学习笔记（不一定对，欢迎讨论）" class="headerlink" title="学习笔记（不一定对，欢迎讨论）"></a>学习笔记<em>（不一定对，欢迎讨论）</em></h3><h3 id="早晨"><a href="#早晨" class="headerlink" title="早晨"></a>早晨</h3><h4 id="面部-去水肿"><a href="#面部-去水肿" class="headerlink" title="面部    去水肿"></a>面部    去水肿</h4><ul><li>仰头–然后歪头 感受<strong>颈阔肌拉伸</strong> <em>左右各三四十秒</em></li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211115192308015.png" alt="image-20211115192308015" style="zoom: 33%;" /></li></ul><h4 id="养气血健脾胃"><a href="#养气血健脾胃" class="headerlink" title="养气血健脾胃"></a>养气血健脾胃</h4><ol><li><strong>坚持每天早上运动30分钟</strong></li><li>练中气：深吸一口气，然后发出**si~**的音 每次坚持20s</li></ol><h4 id="打哈欠、叹气、犯困、头晕眼花"><a href="#打哈欠、叹气、犯困、头晕眼花" class="headerlink" title="打哈欠、叹气、犯困、头晕眼花"></a>打哈欠、叹气、犯困、头晕眼花</h4><h4 id="头颈-前伸："><a href="#头颈-前伸：" class="headerlink" title="头颈    前伸："></a>头颈    前伸：</h4><p>正常生理结构上，人体脊柱颈椎段是有先前的曲度的。但是由于不良习惯，颈椎曲度会变直甚至反张。长期头颈前伸会引起身体前侧一些肌肉和筋膜的挛缩，会让面部结构出现下垂。</p><ol><li>关节松动</li><li>软组织松解<ol><li>胸锁乳突肌</li><li>斜角肌</li><li>上斜方肌</li><li>风池穴</li></ol></li><li>稳定训练<ol><li>躺下 –&gt;歪头–&gt;抬头（感受胸锁乳突肌拉伸、肩膀必须放松）</li></ol></li></ol><p>日常的姿势再训练：</p><ol><li>动作①：挺胸廓。挺起胸廓，保持一分钟左右，慢慢放松，做3—4组。<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211115195422291.png" alt="image-20211115195422291" style="zoom: 25%;" /></li><li>动作②：拉伸颈前侧。闭紧牙齿闭拢嘴巴，把下颌往上提，保持30—40秒，做3—4组。感到脖子前侧有牵拉感。与仰头区分开，注意把下巴往上提。</li><li>动作③：头悬气球。想象头上有个气球拎着你拎着你拎着你拎着你～就这样拎着。寻找脑袋往上延伸，身体挺拔的感觉，日常保持此状态。</li></ol><p>脖子酸痛  给亲人做胸锁乳突肌 放松  （ 注意   轻力度！！！）</p><h4 id="肩部"><a href="#肩部" class="headerlink" title="肩部"></a>肩部</h4><ol><li><h5 id="解决圆肩驼背问题（15min54）"><a href="#解决圆肩驼背问题（15min54）" class="headerlink" title="解决圆肩驼背问题（15min54）"></a>解决圆肩驼背问题（15min54）</h5><ol><li>活动肩关节（12次）</li><li>放松胸大肌（40秒/4组）</li><li>放松胸小肌（30秒/每边/2组）</li><li>眼镜蛇拉伸（40s/2组）</li><li>大范围绕肩（前后各30秒）</li><li>开肩吸气（60秒/3组）</li></ol></li></ol><h4 id="小腿"><a href="#小腿" class="headerlink" title="小腿"></a>小腿</h4><ol><li>解决各种小腿问题</li><li></li></ol><h4 id="正确的坐姿"><a href="#正确的坐姿" class="headerlink" title="正确的坐姿"></a>正确的坐姿</h4><ol><li>坐骨（屁股）位置高于膝盖（没有往后靠的感觉为止）</li><li>头悬空的感觉，前后发力平衡</li><li>每隔一段时间动一动（1hour）</li><li>靠背椅，往后坐</li><li>视线尽力看平</li></ol><h4 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h4><p>深蹲不粗腿又能促睾翘臀BV1DS4y1M7iG</p><h4 id="正确睡姿："><a href="#正确睡姿：" class="headerlink" title="正确睡姿："></a>正确睡姿：</h4><p>BV12h411C7dw</p><p>一：好的睡眠是全身放松的。<br>二：哪里痛不是睡姿不对，而是哪里该放松松解了。<br>三：睡前操分享。<br>1.猫式伸展。（30秒）<br>2.坐姿位拉伸大腿。（每条腿40秒）<br>3.仰卧旋转拉伸。（每边40秒）（涉及到骨盆旋转）</p><h4 id="骨盆旋转"><a href="#骨盆旋转" class="headerlink" title="骨盆旋转"></a>骨盆旋转</h4><p>BV1Cf4y1S7a2</p><h4 id="你不是懒-是气血不足-易累人群4步养气血"><a href="#你不是懒-是气血不足-易累人群4步养气血" class="headerlink" title="你不是懒 是气血不足  |  易累人群4步养气血"></a>你不是懒 是气血不足  |  易累人群4步养气血</h4><ol><li>气血不足是什么？<ul><li>黑眼圈，疲劳，失眠，乏力……</li></ul></li><li>养气血先健脾胃</li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20220115174223481.png" alt="image-20220115174223481"  /><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20220115174131202.png" style="zoom:80%;" /></li><li>吃——原则：按时吃饭，应季食物。<br>1.淮山玉米芡实排骨汤<br>2.陈皮泡水<br>3.四君子汤</li><li>按摩：早晚顺逆81下揉腹  </li><li><strong>坚持每天早上运动30分钟</strong></li><li>练中气：深吸一口气，然后发出**si~**的音 每次坚持20s</li></ol><p>补气：西洋参</p><p> 社交：减少内耗和对负性情绪的接触。</p><h3 id="分享一些感受："><a href="#分享一些感受：" class="headerlink" title="分享一些感受："></a>分享一些感受：</h3><ol><li>等待没有必要，约到年纪大越难矫正</li><li>不要做着林黛玉的训练量，操着变成阿诺的心（hhhh）</li><li></li></ol><h3 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h3><ol><li>记号笔用酒精一擦就掉；</li><li>维持挺胸，需要深层肌肉稳定</li><li>健身大佬 김종국 GYM JONG KOOK<a href="https://www.youtube.com/channel/UCoe-0EVDJnjlSoPK8ygcGwQ">https://www.youtube.com/channel/UCoe-0EVDJnjlSoPK8ygcGwQ</a></li><li></li></ol><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;《论每天健身的重要性》And《学习健身笔记》持续ing&lt;/center&gt;</summary>
    
    
    
    <category term="-日常 -生活" scheme="https://wendaoit.github.io/categories/%E6%97%A5%E5%B8%B8-%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="健身" scheme="https://wendaoit.github.io/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>记录一次服务器搭建MySQL</title>
    <link href="https://wendaoit.github.io/2021/11/12/20211112-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAMySQL/"/>
    <id>https://wendaoit.github.io/2021/11/12/20211112-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAMySQL/</id>
    <published>2021-11-12T00:00:00.000Z</published>
    <updated>2023-03-07T06:53:39.070Z</updated>
    
    <content type="html"><![CDATA[<center> 技术坑:Linux  centos7 mysql navicate docker</center><span id="more"></span><p><a href="https://www.cnblogs.com/763977251-sg/p/11837130.html">Centos7 系统安装 docker，并配置阿里云镜像加速器</a></p><ol><li><p>先在服务器上安装一个docker 根据官方文档</p><p>​    docker pull MySQL:8.0</p></li><li><p>whereis mysql 查看安装位置</p></li><li><p>通过下面命令创建一个镜像</p><ol><li>```dockerfile<br> docker run -p 3306:3306 –name zxhmysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib64/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0</li></ol></li><li><p>docker ps -a查看是否启动成功</p><ul><li>这里有个坑 ，网上 旧版lib后面没有64  新版要添加</li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211112152206575.png" alt="image-20211112152206575"></li></ul></li><li><p>启动成功  改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mydata/mysql/conf</span><br><span class="line">vi my.cnf</span><br></pre></td></tr></table></figure></li><li><p>配置文件参考</p><ol><li>```<br>[mysqld]<br>####: for global<br>user =mysql<br>federated<br>basedir =/usr/local/mysql<br>datadir =/data/mysql/data<br>server_id = 1250<br>port =3306<br>mysqlx_port = 33070<br>character_set_server =utf8mb4<br>collation_server=utf8mb4_bin<br>log_timestamps =system<br>default_time_zone =’+8:00’<br>socket =/data/mysql/mysql.sock<br>read_only = 0<br>super_read_only = 0<br>skip_name_resolve =on<br>lower_case_table_names =1<br>#secure_file_priv =/data/mysql/data<br>open_files_limit =65536<br>max_connections =2000<br>thread_cache_size =256<br>table_open_cache =4096 # 2000<br>table_definition_cache =4096<br>table_open_cache_instances =64<br>wait_timeout =28800<br>interactive_timeout =28800<br>event_scheduler = 1<br>max_allowed_packet =1024M<br>init_connect =’SET AUTOCOMMIT=1’<br>transaction_isolation =READ-COMMITTED<br>lock_wait_timeout=3600<br>default_authentication_plugin=mysql_native_password###: cache<br>key_buffer_size = 64M<br>sort_buffer_size  = 4M<br>join_buffer_size  = 4M####: for binlog<br>binlog_format =row<br>log_bin =/data/mysql/logs/mysql-bin<br>binlog_rows_query_log_events =off<br>log_slave_updates =on<br>#expire_logs_days =7<br>binlog_expire_logs_seconds=604800<br>binlog_cache_size =1G<br>max_binlog_size =1G<br>binlog_checksum =none<br>sync_binlog =1<br>slave-preserve-commit-order =ON<br>log_bin_trust_function_creators=on  ####:for error-log<br>log_error =/data/mysql/logs/mysql.err<br>general_log =off<br>general_log_file =/data/mysql/logs/general.log####: for slow query log<br>slow_query_log =on<br>slow_query_log_file =/data/mysql/logs/slowquery.log<br>long_query_time =1.000000<br>log_queries_not_using_indexes =0####: for gtid<br>#gtid_executed_compression_period =1000<br>gtid_mode =on<br>enforce_gtid_consistency =on####: for replication<br>relay-log-index = /data/mysql/logs/relay-bin.index<br>relay-log-info-file = /data/mysql/logs/relay-log.info<br>relay-log = /data/mysql/logs/relay-bin<br>log-slave-updates =1<br>skip_slave_start =1<br>master_info_repository =table<br>relay_log_info_repository =table<br>slave_parallel_type =logical_clock<br>slave_parallel_workers =2####: for performance_schema<br>performance_schema = 1<br>performance_schema_instrument = ‘%memory%=on’<br>performance_schema_instrument = ‘%lock%=on’<br>performance_schema_digests_size =100000####: for innodb<br>innodb_data_file_path =ibdata1:1024M:autoextend<br>innodb_temp_data_file_path =ibtmp1:12M:autoextend<br>innodb_buffer_pool_filename =ib_buffer_pool # ib_buffer_pool<br>innodb_log_files_in_group =3<br>innodb_log_file_size =256M # 50331648(48M)<br>innodb_max_undo_log_size =256M<br>innodb_undo_log_truncate =1<br>innodb_undo_tablespaces =2<br>innodb_file_per_table =on<br>innodb_open_files =65535<br>innodb_thread_concurrency =0 # 0<br>innodb_read_io_threads =2<br>innodb_write_io_threads =2<br>innodb_purge_threads =1<br>innodb_page_cleaners =1<br>innodb_print_all_deadlocks =off<br>innodb_lock_wait_timeout =20<br>innodb_autoinc_lock_mode =2<br>innodb_io_capacity =500<br>innodb_io_capacity_max =1000#########################<br>innodb_flush_method =O_DIRECT<br>innodb_log_buffer_size =128M<br>innodb_flush_log_at_trx_commit =1<br>innodb_buffer_pool_size = 128M<br>innodb_buffer_pool_instances = 2<br>#innodb_numa_interleave=on<br>#####################################<br>#######################<br>[client]<br>socket=/data/mysql/mysql.sock<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">7.</span> docker <span class="keyword">restart</span> 容器ID</span><br><span class="line"></span><br><span class="line">   测试连接 </span><br><span class="line"></span><br><span class="line">#### MySQL允许远程连接</span><br><span class="line"></span><br><span class="line">项目中需要连接虚拟机上面的 MySQL 数据库，但是总是出错，怀疑本机是否有连接远程数据库的权限。</span><br><span class="line"></span><br><span class="line">执行命令：</span><br><span class="line"></span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; <span class="keyword">select</span> host,<span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>查看结果是不是 root 用户仅允许本地（localhost）登录，下面这个截图就是这种情况：</p><p><img src="http://hoxis-github-io.qiniudn.com/151212-mysql-root-state.png" alt="mysql-root-state"></p><p>mysql-root-state</p><p>是的话，就要修改它的 host 为 <code>%</code>，表示任意 IP 地址都可以登录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> update <span class="keyword">user</span> <span class="keyword">set</span> host <span class="operator">=</span> <span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行完后可能提示 error。再 <code>mysql&gt; select host,user from user;</code> 查看下吧。</p><p>root 对应的 host 成了 <code>%</code>，表示可以任意 IP 地址登录了。</p><p><img src="http://hoxis-github-io.qiniudn.com/151212-mysql-change-root-state.png" alt="mysql-change-root-state"></p><p>mysql-change-root-state</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure><p>把缓存 flush 掉，在使用 update 语句修改用户记录后，需要 FLUSH 语句告诉服务器重载授权表。</p><h4 id="记录一些遇到的bug"><a href="#记录一些遇到的bug" class="headerlink" title="记录一些遇到的bug"></a>记录一些遇到的bug</h4><ol><li>1130 - Host ‘118.114.228.223’ is not allowed to connect to this MySQL server</li><li><a href="https://blog.csdn.net/qq_45675449/article/details/106866700">MySQL 报错：ERROR 1396 (HY000): Operation ALTER USER failed for root@localhost</a></li><li><a href="https://www.cnblogs.com/adao21/p/9246569.html">MySQL 登录时出现 Access denied for user ‘root‘@‘localhost‘ (using password: YES) 无法打开的解决方法</a></li><li>❗<a href="https://blog.csdn.net/attackkk/article/details/104954941">docker 下 mysql 的密码设置</a></li><li>[ERROR] [MY-010095] [Server] Failed to access directory for –secure-file-priv. Please make sure that directory exists and is accessible by MySQL Server. Supplied value : /var/lib/mysql-files</li><li><a href="https://blog.csdn.net/zhaogot/article/details/113694332">docker 实战之挂载方式部署 MySQL8  （公司实战）</a></li></ol><h4 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h4><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt; 技术坑:Linux  centos7 mysql navicate docker&lt;/center&gt;</summary>
    
    
    
    <category term="-mysql -docker -linux" scheme="https://wendaoit.github.io/categories/mysql-docker-linux/"/>
    
    
    <category term="-实战 -mysql -docker -linux" scheme="https://wendaoit.github.io/tags/%E5%AE%9E%E6%88%98-mysql-docker-linux/"/>
    
  </entry>
  
  <entry>
    <title>Git复习</title>
    <link href="https://wendaoit.github.io/2021/10/27/20211027-Git%E5%A4%8D%E4%B9%A0/"/>
    <id>https://wendaoit.github.io/2021/10/27/20211027-Git%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-10-27T00:00:00.000Z</published>
    <updated>2023-03-07T06:53:39.066Z</updated>
    
    <content type="html"><![CDATA[<center>系统的整理一下Git</center><span id="more"></span><h3 id="git的诞生"><a href="#git的诞生" class="headerlink" title="git的诞生"></a>git的诞生</h3><ul><li>Linux之父linus 想开源使用代码仓库，又觉得当时的其他的不好用，种种原因下 自己花费15天 用C语言写了Git</li><li>推荐读书《just for fun》linus的自传 ，很有意思</li></ul><h3 id="GIT诞生之前有个SVN"><a href="#GIT诞生之前有个SVN" class="headerlink" title="GIT诞生之前有个SVN"></a>GIT诞生之前有个SVN</h3><p>SVN:</p><ul><li>SVN 是一种集中式的版本控制工具。</li><li>所有的客户端将自己的代码上传到中央服务器，中央服务器的版本数据库会保存上传的各个版本的代码，并进行统一管理。</li><li> 这里注意，客户端本身是不存在版本数据库的，所以，如果中央服务器离线或宕机，则集中式版本控制则无法使用。SVN 是一个增量式的版本控制，它不会将整的保存下来，而只会记录下版本之间的差异，然后按照顺序更新或者恢复特定版本的数据。. 这使得服务端的存储量会非常低。</li></ul><p>git：</p><ul><li>GIT是一个分布式的版本控制工具</li><li>每个人的PC都可以有一个版本库；有很好的容灾性；</li></ul><h3 id="先安装一个Windows版"><a href="#先安装一个Windows版" class="headerlink" title="先安装一个Windows版"></a>先安装一个Windows版</h3><p>按照官网安装即可</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用户名+邮箱（最好跟gitee上一样）</p><p>git config –global user.name “自己的用户名”</p><p>git config –global user.email “自己的邮箱” </p><p>最终在C:\Users\ZXH082600\.gitconfig生成一个配置文件</p><h2 id="本地基操"><a href="#本地基操" class="headerlink" title="本地基操"></a>本地基操</h2><h3 id="初始化（创建版本库）"><a href="#初始化（创建版本库）" class="headerlink" title="初始化（创建版本库）"></a>初始化（创建版本库）</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>在当前文件夹下创建一个git仓库</p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027202830969.png" alt="image-20211027202830969" style="zoom:80%;" /><p>在创建一个文件 a.txt</p><p>ls -l 显示total 0   此时只是新建了一个文件，和git并没有关系</p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027204330960.png" alt="image-20211027204330960" style="zoom:80%;" /><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><ol><li><h4 id="git-status-查看文件状态"><a href="#git-status-查看文件状态" class="headerlink" title="git status 查看文件状态"></a>git status 查看文件状态</h4></li><li><p>git add  <file>  将文件添加到 暂存区（生成index索引文件）</p><ul><li>如果报错<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027210523876.png" alt="image-20211027210523876"></li><li>解决办法git config –global core.autocrlf false </li></ul></li><li><p>git commit -m “注释” a.txt   (每次commit都必须写清楚注释)<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027205215099.png" alt="image-20211027205215099"></p></li></ol><h3 id="查看文件提交记录"><a href="#查看文件提交记录" class="headerlink" title="查看文件提交记录"></a>查看文件提交记录</h3><p>git log a.txt </p><p>git log –pretty=oneline a.txt</p><img src="C:/Users/ZXH082600/AppData/Roaming/Typora/typora-user-images/image-20211027211605054.png" alt="image-20211027211605054" style="zoom:80%;" /><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>git reset –hard HEAD^ </p><p>git reset –hard HEAD^ ^^^   （^代表退几步）</p><h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><p>git reflog a.txt 查看历史记录的版本号（很详细）</p><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028100945522.png" alt="image-20211028100945522"></p><p>git reset –hard ee58290 （指针指向版本号）</p><p>git reset –hard HEAD~4(回退四步)</p><h3 id="撤销修改内容（已修改未add的）"><a href="#撤销修改内容（已修改未add的）" class="headerlink" title="撤销修改内容（已修改未add的）"></a>撤销修改内容（已修改未add的）</h3><p>git checkout – a.txt</p><h3 id="删除某个git文件"><a href="#删除某个git文件" class="headerlink" title="删除某个git文件"></a>删除某个git文件</h3><ol><li> git rm c.txt</li><li>git commit -m “del c.txt”</li></ol><h2 id="谈谈git的三个库（工-暂-本）"><a href="#谈谈git的三个库（工-暂-本）" class="headerlink" title="谈谈git的三个库（工 暂 本）"></a>谈谈git的三个库（工 暂 本）</h2><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028104132867.png" alt="image-20211028104132867"></p><h2 id="Gits实操之分支"><a href="#Gits实操之分支" class="headerlink" title="Gits实操之分支"></a>Gits实操之分支</h2><ul><li>创建分支<ul><li>git branch查看分支</li><li>git branch 分支名</li></ul></li><li>切换分支<ul><li>git checkout 分支名</li><li>git checkout -b 分支名（创建并切换，如果已存在会报错）</li></ul></li><li>合并分支<ul><li>先切换到主分支 git checkout master</li><li>git merge 目标分支名</li></ul></li><li>删除分支<ul><li>先切换到主分支 git checkout master</li><li>git branch -d 分支名</li></ul></li></ul><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><ul><li>冲突一般是指同一个文件同一位置的代码，在两个版本合并时版本管理软件无法判断该保留哪一个版本，因此会提示该文件发生冲突；</li></ul><h3 id="分支覆盖冲突"><a href="#分支覆盖冲突" class="headerlink" title="分支覆盖冲突"></a>分支覆盖冲突</h3><ul><li><p>合并时冲突</p><ul><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028110717436.png" alt="image-20211028110717436"></li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028112659780.png" alt="image-20211028112659780"></li></ul></li><li><p>解决</p><p>​    不可以将其他开发人员的代码 覆盖或者删除；（同步，全部保留；）</p><ul><li>git diff //可以找到发生冲突的文件和内容</li><li>然后修改冲突文件的内容，再次git add 文件 和git commit (无文件名)提交后，后缀merging消失，说明冲突解决</li></ul></li></ul><h3 id="远程服务器冲突"><a href="#远程服务器冲突" class="headerlink" title="远程服务器冲突"></a>远程服务器冲突</h3><ul><li>版本不一致 先pull一个最新版本的，diff 冲突文件中的冲突需要手动处理，再重新add/commit/push</li></ul><h3 id="idea拉取提交冲突"><a href="#idea拉取提交冲突" class="headerlink" title="idea拉取提交冲突"></a>idea拉取提交冲突</h3><h2 id="Gitee云上实操"><a href="#Gitee云上实操" class="headerlink" title="Gitee云上实操"></a>Gitee云上实操</h2><ul><li>创建ssh key<ul><li>ssh-keygen -t rsa -C 你自己用户邮箱</li><li>成功的话会生成.ssh文件夹</li></ul></li><li>打开pub文件。复制全部，复制到gitee公钥</li><li>连通性测试 <ul><li>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#x63;&#111;&#109;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#x63;&#111;&#109;</a></li></ul></li></ul><ol><li>先在本地初始化创建一个git库  git init</li><li>在gitee中创建一个同名空仓库</li><li>本地操作提示，git remote与远程建立连接<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028153432245.png" alt="image-20211028153432245"></li><li>从服务器拉最新的<ul><li>git pull origin master</li></ul></li><li>新员工入职从远程拉项目<ul><li>git clone origin https:xxxxxx.git</li><li>然后切换到工作目录，开始操作</li></ul></li></ol><h4 id="新员工入职，如何配合工作-取得代码"><a href="#新员工入职，如何配合工作-取得代码" class="headerlink" title="新员工入职，如何配合工作+取得代码"></a>新员工入职，如何配合工作+取得代码</h4><p>git一般工作流程</p><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028161839922.png" alt="image-20211028161839922"></p><h5 id="重点：git-fetch-origin-master查看是否版本冲突"><a href="#重点：git-fetch-origin-master查看是否版本冲突" class="headerlink" title="重点：git fetch origin master查看是否版本冲突"></a>重点：git fetch origin master查看是否版本冲突</h5><ol><li>up to date 版本一致，证明没人改过</li><li>ahead of 你的比服务端新，可以提交</li><li>behind 服务器有更改，<strong>不能直接push  必须先pull 最新的，然后把自己的代码加上再重新fetch</strong></li><li>pull之后自己手动处理冲突然后再提交</li></ol><h3 id="邀请成员协同开发（被动等待邀请）"><a href="#邀请成员协同开发（被动等待邀请）" class="headerlink" title="邀请成员协同开发（被动等待邀请）"></a>邀请成员协同开发（被动等待邀请）</h3><p>要点击确认</p><h3 id="跨团队协作fork（主动fork）"><a href="#跨团队协作fork（主动fork）" class="headerlink" title="跨团队协作fork（主动fork）"></a>跨团队协作fork（主动fork）</h3><p>请求外部专家帮助解决bug</p><ol><li>找到那个项目，点fork</li><li>git clone /add/push等</li><li>新建pull requests</li><li>主项目端会收到审查和测试</li><li>点文件查看diff</li><li>合并分支</li></ol><h3 id="仓库删除"><a href="#仓库删除" class="headerlink" title="仓库删除"></a>仓库删除</h3><p>点击管理–&gt;删除项目—&gt;验证信息</p><h2 id="IDEA整合"><a href="#IDEA整合" class="headerlink" title="IDEA整合"></a>IDEA整合</h2><h3 id="Git配置忽略文件"><a href="#Git配置忽略文件" class="headerlink" title="Git配置忽略文件"></a>Git配置忽略文件</h3><ol><li>自己的用户目录下创建 git.ignore<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029111113274.png" alt="image-20211029111113274"></li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029111543371.png" alt="image-20211029111543371"></li><li>规则<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029112355363.png" alt="image-20211029112355363" style="zoom:80%;" /></li><li>设置找到git 配置</li><li>安装gitee插件</li><li>版本控制中有个gitee<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029113034406.png" alt="image-20211029113034406"></li><li>创建一个普通maven项目</li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029113647439.png" alt="image-20211029113647439"></li><li>add /commit<ul><li>这里有个报错，跨平台问题；解决办法（<a href="https://blog.csdn.net/iamlihongwei/article/details/107518398%EF%BC%89![image-20211029115025959](https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115025959.png)">https://blog.csdn.net/iamlihongwei/article/details/107518398）![image-20211029115025959](https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115025959.png)</a></li></ul></li><li> 同步到云端，右击git，点share<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115150251.png" alt="image-20211029115150251" style="zoom:50%;" /></li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115909354.png" alt="image-20211029115909354"></li></ol><h2 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1362941">参考TX Git Code Review 设置与使用</a></li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;系统的整理一下Git&lt;/center&gt;</summary>
    
    
    
    <category term="-Git -面试 -JAVA基础" scheme="https://wendaoit.github.io/categories/Git-%E9%9D%A2%E8%AF%95-JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="-Git" scheme="https://wendaoit.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>继续学习JUC</title>
    <link href="https://wendaoit.github.io/2021/10/27/20211027-%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0JUC/"/>
    <id>https://wendaoit.github.io/2021/10/27/20211027-%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0JUC/</id>
    <published>2021-10-27T00:00:00.000Z</published>
    <updated>2023-03-07T06:53:39.066Z</updated>
    
    <content type="html"><![CDATA[<center>不断学习，不断总结，今天的你比昨天更强。</center><span id="more"></span><h3 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h3><ul><li>从start一个线程说起<ul><li>java 线程是通过 start 的方法启动执行的，主要内容在 native 方法 start0 中，Openjdk 的写 JNI 一般是一一对应的，Thread.java 对应的就是 Thread.cstart0 其实就是 JVM_StartThread。此时查看源代码可以看到在 jvm.h 中找到了声明，jvm.cpp 中有实现。</li><li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027154450090.png" alt="image-20211027154450090"></li><li>Java线程分为用户线程和守护线程，<br>线程的daemon属性为<strong>true</strong>表示是守护线程，<strong>false</strong>表示是用户线程；eg：main用户线程+GC守护线程；</li></ul></li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;不断学习，不断总结，今天的你比昨天更强。&lt;/center&gt;</summary>
    
    
    
    <category term="-JUC -JAVA" scheme="https://wendaoit.github.io/categories/JUC-JAVA/"/>
    
    
    <category term="-JUC -Java" scheme="https://wendaoit.github.io/tags/JUC-Java/"/>
    
  </entry>
  
  <entry>
    <title>说说双重检查加锁单例模式为什么两次判断？</title>
    <link href="https://wendaoit.github.io/2021/10/21/20211021-%E8%AF%B4%E8%AF%B4%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E5%8A%A0%E9%94%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E5%88%A4%E6%96%AD%EF%BC%9F/"/>
    <id>https://wendaoit.github.io/2021/10/21/20211021-%E8%AF%B4%E8%AF%B4%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E5%8A%A0%E9%94%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E5%88%A4%E6%96%AD%EF%BC%9F/</id>
    <published>2021-10-21T00:00:00.000Z</published>
    <updated>2023-03-07T06:53:39.066Z</updated>
    
    <content type="html"><![CDATA[<center>  今天面试被问到这道题没说出来，复盘一下</center><span id="more"></span><p>先上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次校验singleton是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//第二次校验singleton是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : &quot;</span>+Singleton.getInstance().hashCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么是双重校验锁实现单例模式呢？"><a href="#为什么是双重校验锁实现单例模式呢？" class="headerlink" title="为什么是双重校验锁实现单例模式呢？"></a>为什么是双重校验锁实现单例模式呢？</h3><ol><li><p><strong>第一次校验：</strong> 也就是第一个 if（singleton==null），由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用 getInstance 方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。</p></li><li><p>第二次校验：第个校验是防止二次创建实例，假如有一种情况，当 singleton 还未被创建时，线程 t1 调用 getInstance 方法，由于第一次判断 singleton==null，此时线程 t1 准备继续执行，但是由于资源被线程 t2 抢占了，此时 t2 页调用 getInstance 方法。</p><p>​            同样的，由于 singleton 并没有实例化，t2 同样可以通过第一个 if，然后继续往下执行，同步代码块，第二个 if 也通过，然后 t2 线程创建了一个实例 singleton。</p><p>​            此时 t2 线程完成任务，资源又回到 t1 线程，t1 此时也进入同步代码块，如果没有这个第二个 if，那么，t1 就也会创建一个 singleton 实例，那么，就会出现创建多个实例的情况，但是加上第二个 if，就可以完全避免这个多线程导致多次创建实例的问题。</p></li></ol><h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul><li>感觉面试还是紧张了，稍微想一下其实就明白了；</li></ul><!--more-->]]></content>
    
    
    <summary type="html">&lt;center&gt;  今天面试被问到这道题没说出来，复盘一下&lt;/center&gt;</summary>
    
    
    
    <category term="-面试 -JAVA" scheme="https://wendaoit.github.io/categories/%E9%9D%A2%E8%AF%95-JAVA/"/>
    
    
    <category term="面试" scheme="https://wendaoit.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
