<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>今天又GET一个🏊‍的小技能</title>
    <url>/2021/09/18/20210918-%E4%BB%8A%E5%A4%A9%E5%8F%88GET%E4%B8%80%E4%B8%AA%F0%9F%8F%8A%E2%80%8D%E7%9A%84%E5%B0%8F%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<center>持续get，持续更新ing</center>

<span id="more"></span>

<p>想要哪个教程在评论区留言，或者联系我，我看到会更新一些教程</p>
<h4 id="2021-09-21-为了备份我博客参考的一些网站，防止404了"><a href="#2021-09-21-为了备份我博客参考的一些网站，防止404了" class="headerlink" title="2021/09/21  为了备份我博客参考的一些网站，防止404了"></a>2021/09/21  为了备份我博客参考的一些网站，防止404了</h4><ul>
<li>发现并学会使用Web cilpper插件，备份网站内容到（暂时备份在GitHub）</li>
</ul>
<h4 id="2021-10-23"><a href="#2021-10-23" class="headerlink" title="2021/10/23"></a>2021/10/23</h4><ul>
<li>初衷是为了：找到一个手机、平板、PC三端同步的todo清单软件</li>
<li>了解到Microsoft 自家出了todo，下载下来试了下，好用</li>
<li>打开的界面<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211023113732578.png" alt="image-20211023113732578"></li>
</ul>
<p>优点：</p>
<ol>
<li>支持多端云同步；</li>
<li><strong>最重要的是么得烦人的广告，追求极简</strong></li>
<li>支持部分快捷键；</li>
<li>我习惯固定在任务栏  WIN+1 快速冷启动 </li>
</ol>
<p>缺点：不支持日历同步 </p>
<h4 id="2021-10-31-截图软件-（我直呼好用）"><a href="#2021-10-31-截图软件-（我直呼好用）" class="headerlink" title="2021-10-31  截图软件 （我直呼好用）"></a>2021-10-31  截图软件 （我直呼好用）</h4><p>​    你有没这样的经历 win10 系统自带截图功能难用无比，而市面上没有一款让你满意的截图软件，这导致很多时候你是在 qq 这款软件来进行截图操作。</p>
<p><a href="https://zhuanlan.zhihu.com/p/99782135">最强截图软件：snipaste</a></p>
<h4 id="2021-12-14-补-真正保存整个网页的方法，完全还原-（vue）"><a href="#2021-12-14-补-真正保存整个网页的方法，完全还原-（vue）" class="headerlink" title="2021/12/14 补 真正保存整个网页的方法，完全还原 （vue）"></a>2021/12/14 补 真正保存整个网页的方法，完全还原 （vue）</h4><ul>
<li>UP插件  Save All Resources</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211214222333264.png" alt="image-20211214222333264"></li>
</ul>
<h4 id="2021-12-14-小破站发现一个-浏览器标签页-扩展-5颗星-推荐-iTabNewTab"><a href="#2021-12-14-小破站发现一个-浏览器标签页-扩展-5颗星-推荐-iTabNewTab" class="headerlink" title="2021/12/14 小破站发现一个 浏览器标签页 扩展 5颗星 推荐    iTabNewTab"></a>2021/12/14 小破站发现一个 浏览器标签页 扩展 5颗星 推荐    iTabNewTab</h4><ul>
<li>详情官网 itab.link</li>
</ul>
<h4 id="2021-12-15-一个传输文件神器-空投（airportal-cn）"><a href="#2021-12-15-一个传输文件神器-空投（airportal-cn）" class="headerlink" title="2021/12/15 一个传输文件神器 空投（airportal.cn）"></a>2021/12/15 一个传输文件神器 空投（airportal.cn）</h4><ul>
<li>极简<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211214223704215.png" alt="image-20211214223704215" style="zoom: 33%;" /></li>
<li>配合取件码 像收快递一样 <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211214223752007.png" alt="image-20211214223752007" style="zoom:33%;" /></li>
</ul>
<h2 id="提升编程效率的软件"><a href="#提升编程效率的软件" class="headerlink" title="提升编程效率的软件"></a>提升编程效率的软件</h2><h4 id="2021-11-10-JSON格式化插件"><a href="#2021-11-10-JSON格式化插件" class="headerlink" title="2021/11/10 JSON格式化插件"></a>2021/11/10 JSON格式化插件</h4><p>浏览器JSON-Handle插件  （特别好用）</p>
<h4 id="2021-11-11-抓取整个网页-（复原）"><a href="#2021-11-11-抓取整个网页-（复原）" class="headerlink" title="2021/11/11 抓取整个网页 （复原）"></a>2021/11/11 抓取整个网页 （复原）</h4><p>Resource Saver插件 （全网唯一满足需求的东西）</p>
<h4 id="2021-11-11-Finalshell"><a href="#2021-11-11-Finalshell" class="headerlink" title="2021/11/11 Finalshell"></a>2021/11/11 Finalshell</h4><p>很好用的工具  功能很多 国产的替代xshell </p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211112005933595.png" alt="image-20211112005933595" style="zoom:80%;" />

<h4 id="2021-11-12-Navicat-Keygen-Patch-全系列注册机"><a href="#2021-11-12-Navicat-Keygen-Patch-全系列注册机" class="headerlink" title="2021/11/12 Navicat Keygen Patch 全系列注册机"></a>2021/11/12 Navicat Keygen Patch 全系列注册机</h4><p>做项目中 遇到Navicat版本太低，询问别人了解的好东西  教程：<a href="https://www.bilibili.com/read/cv9403602">https://www.bilibili.com/read/cv9403602</a></p>
<h4 id="2021-10-03"><a href="#2021-10-03" class="headerlink" title="2021/10/03"></a>2021/10/03</h4><ul>
<li>linux使用ab 可以进行测试，（模拟大规模并发操作）</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>小技能</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的快捷键</title>
    <url>/2023/03/07/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><center>快捷键</center></h1><span id="more"></span>

<h2 id="MAC中快捷键"><a href="#MAC中快捷键" class="headerlink" title="MAC中快捷键"></a>MAC中快捷键</h2><table>
<thead>
<tr>
<th align="left"><strong>快捷键</strong></th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td>通知中心往下拉。勿扰快速开关</td>
</tr>
<tr>
<td align="left">ctrl+数字键</td>
<td>跳转到指定的数字书签</td>
</tr>
<tr>
<td align="left">cmd+2</td>
<td>显示收藏窗口 包括书签、收藏、断点</td>
</tr>
<tr>
<td align="left">ctrl+shift+数字键</td>
<td>定义数字书签</td>
</tr>
<tr>
<td align="left">Option+cmd+t</td>
<td>快速生成if、trycatch语句</td>
</tr>
<tr>
<td align="left">cmd +shift +U</td>
<td>快速转换为大小写</td>
</tr>
<tr>
<td align="left">cmd+shift+。</td>
<td>使用Finder查看Mac隐藏文件(.git等)</td>
</tr>
<tr>
<td align="left">cmd+R</td>
<td>在当前界面查找并替换</td>
</tr>
<tr>
<td align="left">cmd+F</td>
<td>在当前界面查找</td>
</tr>
<tr>
<td align="left">ctrl + option + o</td>
<td>快速清除无用包</td>
</tr>
<tr>
<td align="left">CMD+7</td>
<td>显示该类中所有的方法</td>
</tr>
<tr>
<td align="left">Shift +↑</td>
<td>逐行选中</td>
</tr>
<tr>
<td align="left">cmd+E</td>
<td>最近文件</td>
</tr>
<tr>
<td align="left">Option + 方向键上</td>
<td>连续选中代码块</td>
</tr>
<tr>
<td align="left">Command + N</td>
<td>生成代码（getter、setter、构造函数、hashCode/equals,toString）</td>
</tr>
<tr>
<td align="left">cmd+opt+⬅️/➡️</td>
<td>代码跳转</td>
</tr>
<tr>
<td align="left">Command + option + L</td>
<td>代码格式化</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>选中CTRL+shift+左右</p>
<p>调整位置CTRL+shift+上下</p>
<p>主方法psvm</p>
<p>输出sout</p>
<p>Ctrl+n 查找xxx底层类和方法</p>
<p>Ctrl+/ 快速创建注释</p>
<p>Ctrl+F9 重新编译</p>
<p>弹出的方法大纲的快捷键是<br>MAC [Command + F12]<br>WIN [Ctrl + F12]</p>
<p>ctrl+shift+L整理代码</p>
<p>CTRL+shift+F全局搜索</p>
<p>实习收获：</p>
<ul>
<li><p>IDEA快速开发：</p>
<p>  \1. //TODO</p>
<p>  \2. CTRL+shift+1/2/3快速标记  CTRL+1/2/3 快速跳转</p>
<p>  \3. 查找 变量或者方法在代码中的使用find usages  ALT+F7</p>
<p>  \4. CTRL+shift+alt+C  直接复制对应代码行数</p>
<p>  \5. CTRL+SHIFT+N</p>
<p>  \6. CTRL+E打开最近关闭的文件</p>
<p>  \7. 删除行快捷键 ctrl+Y</p>
<p>  \8. 清除无用import包快捷键 ctrl+alt+o</p>
</li>
</ul>
<!-- more -->
]]></content>
      <categories>
        <category>-IDEA -MAC</category>
      </categories>
      <tags>
        <tag>-导航 -分享</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/03/07/java%E4%B8%AD%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<center>java 中位运算 ^,&,<<,>>,<<<,>>> 总结</center>

<span id="more"></span>

<h3 id="位运算都是基于二进制的"><a href="#位运算都是基于二进制的" class="headerlink" title="位运算都是基于二进制的"></a>位运算都是基于二进制的</h3><h4 id="1-亦或运算-，针对二进制，相同的为-0，不同的为-1"><a href="#1-亦或运算-，针对二进制，相同的为-0，不同的为-1" class="headerlink" title="1.^(亦或运算) ，针对二进制，相同的为 0，不同的为 1"></a><strong>1.^(亦或运算) ，</strong>针对二进制，相同的为 0，不同的为 1</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2^3运算的结果是 :&quot;</span>+(<span class="number">2</span>^<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//打印的结果是:   2^3运算的结果是 :1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2 =======&gt;0010</p>
<p>3 =======&gt;0011</p>
<p>2^3 就为 0001，结果就是 1</p>
<h4 id="2-amp-（与运算）-针对二进制，只要有一个为-0，就为-0"><a href="#2-amp-（与运算）-针对二进制，只要有一个为-0，就为-0" class="headerlink" title="2.&amp;（与运算） 针对二进制，只要有一个为 0，就为 0"></a><strong>2.&amp;（与运算）</strong> 针对二进制，只要有一个为 0，就为 0</h4><p>还是上述的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">&quot;2&amp;3 运算的结果是 :&quot;</span>+(<span class="number">2</span>&amp;<span class="number">3</span>));</span><br><span class="line">     <span class="comment">// 打印的结果是:  2&amp;3 运算的结果是 :2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>0010 &amp; 0011 =0010 也就是2</p>
<h4 id="3-lt-lt-向左位移"><a href="#3-lt-lt-向左位移" class="headerlink" title="3.&lt;&lt;(向左位移)"></a><strong>3.&lt;&lt;(向左位移)</strong></h4><h5 id="针对二进制，转换成二进制后向左移动-3-位，后面用-0-补齐"><a href="#针对二进制，转换成二进制后向左移动-3-位，后面用-0-补齐" class="headerlink" title="针对二进制，转换成二进制后向左移动 3 位，后面用 0 补齐"></a>针对二进制，转换成二进制后向左移动 3 位，后面用 0 补齐</h5><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">&quot;2&lt;&lt;3 运算的结果是 :&quot;</span>+(<span class="number">2</span>&lt;&lt;<span class="number">3</span>));</span><br><span class="line">     <span class="comment">// 打印的结果是:  2&lt;&lt;3 运算的结果是 :16</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>0010 左移三位 10000  相当于2*2^3 =16</p>
</blockquote>
<h4 id="4-gt-gt-向右位移"><a href="#4-gt-gt-向右位移" class="headerlink" title="4.&gt;&gt;(向右位移)"></a><strong>4.&gt;&gt;(向右位移)</strong></h4><p>针对二进制，转换成二进制后向右移动 3 位，</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">&quot;2&gt;&gt;3 运算的结果是 :&quot;</span>+(<span class="number">2</span>&gt;&gt;<span class="number">3</span>));</span><br><span class="line">     <span class="comment">// 打印的结果是:  2&gt;&gt;3 运算的结果是 :0</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-gt-gt-gt-无符号右移"><a href="#5-gt-gt-gt-无符号右移" class="headerlink" title="5.&gt;&gt;&gt;(无符号右移)"></a><strong>5.&gt;&gt;&gt;(无符号右移)</strong></h4><p>无符号右移，忽略符号位，空位都以 0 补齐</p>
<p>10 进制转二进制的时候，因为二进制数一般分 8 位、 16 位、32 位以及 64 位 表示一个十进制数，所以在转换过程中，最高位会补零。</p>
<p>在计算机中负数采用二进制的补码表示，10 进制转为二进制得到的是原码，将原码按位取反得到的是反码，反码加 1 得到补码</p>
<p>二进制的最高位是符号位，0 表示正，1 表示负。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;与&gt;&gt;唯一的不同是它无论原来的最左边是什么数，统统都用<span class="number">0</span>填充。</span><br><span class="line">——比如，<span class="keyword">byte</span>是<span class="number">8</span>位的，<span class="number">-1</span>表示为<span class="keyword">byte</span>型是<span class="number">11111111</span>(补码表示法）</span><br><span class="line">b&gt;&gt;&gt;<span class="number">4</span>就是无符号右移<span class="number">4</span>位，即<span class="number">00001111</span>，这样结果就是<span class="number">15</span>。</span><br></pre></td></tr></table></figure>

<p>下面看代码</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>的<span class="number">2</span>进制表示 <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;    System.out.println (<span class="string">&quot;16&gt;&gt;2 运算的结果是 :&quot;</span>+((<span class="number">16</span>)&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;    <span class="comment">// 打印的结果是:  16&gt;&gt;2 运算的结果是 :4</span></span><br><span class="line">&gt; &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;      System.out.println (<span class="string">&quot;-16&gt;&gt;2 运算的结果是 :&quot;</span>+((-<span class="number">16</span>)&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;      <span class="comment">// 打印的结果是:  -16&gt;&gt;2 运算的结果是 :-4</span></span><br><span class="line">&gt;    &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;      System.out.println (<span class="string">&quot;16&gt;&gt;&gt;2 运算的结果是 :&quot;</span>+((<span class="number">16</span>)&gt;&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;      <span class="comment">// 打印的结果是:  16&gt;&gt;&gt;2 运算的结果是 :4</span></span><br><span class="line">&gt;    &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;     System.out.println (<span class="string">&quot;-16&gt;&gt;&gt;2 运算的结果是 :&quot;</span>+((-<span class="number">16</span>)&gt;&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&gt;     <span class="comment">// 打印的结果是:  -16&gt;&gt;&gt;2 运算的结果是 :1073741820</span></span><br><span class="line">&gt;    &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>可见正数做 &gt;&gt;&gt; 运算的时候和 &gt;&gt; 是一样的。区别在于负数运算</p>
<h3 id="others："><a href="#others：" class="headerlink" title="others："></a>others：</h3><ul>
<li>参考上一篇文章HashMap底层原理 </li>
</ul>
<!--more-->]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Think in Java 第四版 读书笔记</title>
    <url>/2023/03/07/%E3%80%8AThink%20in%20Java%20%E7%AC%AC%E5%9B%9B%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Think-in-Java-第四版-读书笔记"><a href="#Think-in-Java-第四版-读书笔记" class="headerlink" title="Think in Java 第四版 读书笔记"></a><center>Think in Java 第四版 读书笔记</center></h1><span id="more"></span>

<p>本书基于jdk1.5 有些许老旧</p>
<p>面向对象程序的挑战之一就是在问题空间的元素和解空间的对象之间创建一对一的映射。</p>
<p>UML统一建模语言，每个类用一个方框表示，类名在方框顶部，任何数据成员在中间，方法行为在底部；</p>
<h1 id="第8章多态"><a href="#第8章多态" class="headerlink" title="第8章多态"></a>第8章多态</h1><ol>
<li>子类想要获取父类的属性时，必须显式的使用super<ol>
<li>因为子类转换为父类时，任何域的操作都是由编译器决定的，不是多态的；子类默认的域是自己的域；</li>
</ol>
</li>
<li>什么是多态？<ol>
<li>子类可以向上转型为父类，父类在调用传进来的方法时，无法判断是哪个子类（只有在编译中才能确定），这就是java的多态性；</li>
</ol>
</li>
<li>向下转型时可能会出现类型转换异常ClassCastException</li>
<li>尽量避免子类和父类中出现同样的命名；</li>
</ol>
<h1 id="第九章-接口"><a href="#第九章-接口" class="headerlink" title="第九章 接口"></a>第九章 接口</h1><ol>
<li>包含抽象方法的类是抽象类</li>
<li>创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，被称为策略设计模式；</li>
<li>适配器设计模式——适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。（类型转换?）</li>
<li>同时继承一个类和多个接口时，必须把类放在前面，否则会报错；</li>
<li>同名同返回类型的多个继承，不会报错，会覆写；but同名不同返回类型的继承会报错；</li>
<li>接口可以包含域，但是是隐式static和final的</li>
<li>接口和工厂——复用性</li>
<li>优先选择类而不是接口，必要的时候才对接口进行重构；</li>
</ol>
<h1 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章 内部类"></a>第十章 内部类</h1><ol>
<li>接口内部类，因为接口中的类都是public、static的，所以可以在接口内实现外围的接口，单独进行main方法测试；</li>
<li>内部类单独生成一个.class文件</li>
<li>内部类和匿名内部类的区别P214</li>
</ol>
<h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><ol>
<li>通过使用泛型，可以在编译器避免将错误的类型放置到容器中；</li>
<li>Object中默认的toString方法，打印的是类名+@+hashCode产生的该对象的散列码的无符号十六进制；</li>
<li></li>
</ol>
<h1 id="第十二章-通过异常处理错误"><a href="#第十二章-通过异常处理错误" class="headerlink" title="第十二章 通过异常处理错误"></a>第十二章 通过异常处理错误</h1><ol>
<li>理解异常处理的两种模型——终止模型和回复模型。<ol>
<li>终止模型：将错误视为不能继续运行的错误，抛出异常；</li>
<li>恢复模型：try块中处理程序的工作是修正错误，然后重新尝试调用；（eg：执行job失败时的多次重试、把try放在while循环中）</li>
</ol>
</li>
<li></li>
</ol>
<h2 id="与C-的区别"><a href="#与C-的区别" class="headerlink" title="与C++ 的区别"></a>与C++ 的区别</h2><ol>
<li>数组的使用<ol>
<li>java更加安全，c++直接操作内存块；</li>
</ol>
</li>
<li>代码作用域不同</li>
<li>C++创建对象后，需要销毁对象，而java具有垃圾回收机制；</li>
<li>c++没有变量初始化功能；</li>
<li>C++中组合多个接口的类的行为是多重继承；</li>
<li>java统一了异常处理</li>
</ol>
<!--more-->
]]></content>
      <categories>
        <category>-Java -书籍</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>公司融资知识科普</title>
    <url>/2023/03/07/%E5%85%AC%E5%8F%B8%E8%9E%8D%E8%B5%84%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/</url>
    <content><![CDATA[<center>双创科普知识</center>

<span id="more"></span>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>最近在找公司面试，发现有的公司不需要融资，有的还分为天使、ABCD等</p>
<p>了解一点关于投融资的知识；</p>
<p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820151547131.png" alt="image-20210820151547131"></p>
<p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820151737303.png" alt="image-20210820151737303"></p>
<p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820152018932.png" alt="image-20210820152018932"></p>
<!-- more -->
]]></content>
      <categories>
        <category>公司</category>
      </categories>
      <tags>
        <tag>-投融资 -公司</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/03/07/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<center>数据结构之哈希表</center>

<center>思想：用空间换取时间；</center>

<span id="more"></span>

<p> <strong>定义</strong>：每一个字符都和一个索引相对应；</p>
<p>查找的复杂度O(1)；</p>
<p><strong>哈希函数</strong>：“键”转换成索引的<strong>转换函数</strong>；</p>
<p><strong>哈希冲突</strong>：两个不同的键对应一个索引；</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826093503314.png" alt="image-20210826093503314" style="zoom:50%;" />

<p>哈希函数的设计是很重要的；</p>
<p>  键通过哈希函数得到的索引的索引越均匀越好</p>
<p><strong>哈希函数的设计</strong>：转成整型（并不是唯一的办法）</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826094043955.png" alt="image-20210826094043955" style="zoom:67%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826094304154.png" alt="image-20210826094304154" style="zoom:67%;" />

<p>大整数取模一个素数，让分布更均匀 ；<strong>选一个合适的素数</strong><a href="https://planetmath.org/goodhashtableprimes">参考网站</a></p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826094531867.png" alt="image-20210826094531867" style="zoom:80%;" />

<p><strong>字符串设计</strong></p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826095605810.png" alt="image-20210826095605810" style="zoom:80%;" />

<p> 复合类型转换–和字符串类似</p>
<p><strong>性质</strong>：</p>
<ol>
<li>一致性：如果a==b,则hash(a)=hash(b);</li>
<li>高效性：计算高校简便；</li>
<li>均匀性：哈希值均匀分布；</li>
</ol>
<h4 id="JAVA中的hashCode"><a href="#JAVA中的hashCode" class="headerlink" title="JAVA中的hashCode"></a>JAVA中的hashCode</h4><p> Java中每个Object自带hashCode是根据对象地址生成的，同样的内容不同的对象地址也不一样；</p>
<p>我们可以自定义覆盖hashCode计算方法；</p>
<p><strong>通常要比较两个类是否相等</strong>：覆盖hashcode和equals</p>
<ul>
<li>hashcode相等证明他们的内容相等</li>
<li>同时如果equals相等证明地址也相同，是用一个类</li>
</ul>
<h4 id="哈希冲突的处理-链地址法-Seperate-Chaining"><a href="#哈希冲突的处理-链地址法-Seperate-Chaining" class="headerlink" title="哈希冲突的处理 链地址法 Seperate Chaining"></a>哈希冲突的处理 链地址法 Seperate Chaining</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826105524706.png" alt="image-20210826105524706" style="zoom:50%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826105804004.png" alt="image-20210826105804004" style="zoom:80%;" />

<h4 id="自己做一个哈希表"><a href="#自己做一个哈希表" class="headerlink" title="自己做一个哈希表"></a>自己做一个哈希表</h4><p><strong>设计思想</strong>： </p>
<ul>
<li>表：顾名思义有行有列</li>
<li>设计一个用户自定义大小的数组列</li>
<li>每个列中的行设计链表，成TreeMap；（TreeMap的底层实现是红黑树）</li>
</ul>
<h4 id="定义一个表"><a href="#定义一个表" class="headerlink" title="定义一个表"></a>定义一个表<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826111205963.png" alt="image-20210826111205963" style="zoom:80%;" /></h4><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826111704766.png" alt="image-20210826111704766"></p>
<h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove()"></a>Remove()</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826112241539.png" alt="image-20210826112241539" style="zoom:67%;" />

<h4 id="Set-Contains"><a href="#Set-Contains" class="headerlink" title="Set() Contains()"></a>Set() Contains()</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826112414906.png" alt="image-20210826112414906" style="zoom:67%;" />

<h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826113246371.png" alt="image-20210826113246371" style="zoom:67%;" />

<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826140549596.png" alt="image-20210826140549596" style="zoom:67%;" />

<p>为实现O(1)级别的复杂度，和静态数组一样，需要reSize</p>
<h6 id="动态空间处理"><a href="#动态空间处理" class="headerlink" title="动态空间处理"></a>动态空间处理</h6><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826140834209.png" alt="image-20210826140834209" style="zoom:50%;" />

<h4 id="reSize"><a href="#reSize" class="headerlink" title="reSize()"></a>reSize()</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826142745265.png" alt="image-20210826142745265" style="zoom:67%;" />





<p>哈希碰撞攻击（了解）</p>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other:"></a>Other:</h4><ul>
<li>leetcode第378题字符串中的第一个唯一的字符</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>红黑树</tag>
        <tag>链表</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title>意外收获 HEXO 阅读全文</title>
    <url>/2023/03/07/%E6%84%8F%E5%A4%96%E6%94%B6%E8%8E%B7-HEXO-%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87/</url>
    <content><![CDATA[<center>hexo more折叠失效问题</center>

<p>ps：因为hexo默认index展示全文，我根据官方三种办法配置了都没有达到我想要的效果；显得我的首页很冗余；某天下午上传文章时突然想到试一下多写几个more试试，没想到成功了；</p>
<span id="more"></span>

<p><strong>自己配置问题</strong>：</p>
<p>我们可以把自己想要折叠的部分放在两个more之间，就可以了</p>
<h4 id="看效果："><a href="#看效果：" class="headerlink" title="看效果："></a>看效果：</h4><ul>
<li>这是没有解决之前的效果</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825144754934.png" alt="image-20210825144754934" style="zoom:50%;" /></li>
<li>加了两行之后<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825144841763.png" alt="image-20210825144841763" style="zoom:50%;" /></li>
<li>实现了我想要的折叠</li>
</ul>
<p><strong>感悟</strong>：多试一试，这个错误可能是因为我对前端知识不是很了解导致的；不过我查了很多博客都没有说这种方法；</p>
<!--more-->

<center>希望对大家能有帮助</center>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>意外收获</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Day2/</url>
    <content><![CDATA[<center>链表</center>

<span id="more"></span>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组和链表的对比：<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820090218843.png" alt="image-20210820090218843" style="zoom:67%;" /></p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>​            真正的动态；头插方便</p>
<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820151148173.png" alt="image-20210820151148173" style="zoom:67%;" />

<h3 id="在链表中插入元素："><a href="#在链表中插入元素：" class="headerlink" title="在链表中插入元素："></a>在链表中插入元素：</h3><p>顺序很重要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node(e)</span><br><span class="line">node.next = prev.next;</span><br><span class="line">prev.next = node;</span><br></pre></td></tr></table></figure>

<h3 id="在链表中删除某个节点："><a href="#在链表中删除某个节点：" class="headerlink" title="在链表中删除某个节点："></a>在链表中删除某个节点：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node(e)</span><br><span class="line">Node delNode = prev.next;</span><br><span class="line">prev.next=delNode.next;</span><br><span class="line">delNode.next = <span class="keyword">null</span>;</span><br><span class="line">size --;</span><br></pre></td></tr></table></figure>

<h3 id="链表的时间复杂度："><a href="#链表的时间复杂度：" class="headerlink" title="链表的时间复杂度："></a>链表的时间复杂度：</h3><ol>
<li><h5 id="添加、删除操作"><a href="#添加、删除操作" class="headerlink" title="添加、删除操作"></a>添加、删除操作</h5><ul>
<li>addLast(e) ——-O(n)</li>
<li>addFirst(e)——–O(1)</li>
<li>add(index,e)——-O(n/2)=O(n)</li>
</ul>
</li>
<li><h5 id="查找操作O-n"><a href="#查找操作O-n" class="headerlink" title="查找操作O(n)"></a>查找操作O(n)<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820103315983.png" alt="image-20210820103315983" style="zoom: 50%;" /></h5></li>
</ol>
<p>链表的应用</p>
<ul>
<li>用链表实现栈</li>
<li>用链表实现队列 </li>
</ul>
<h3 id="删除元素递归的微观机制解读："><a href="#删除元素递归的微观机制解读：" class="headerlink" title="删除元素递归的微观机制解读："></a>删除元素递归的微观机制解读：</h3><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820143125372.png" alt="image-20210820143125372" style="zoom: 50%;" />

<p> <img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210820143157544.png" alt="image-20210820143157544"></p>
<p>递归调用的代价：函数调用+系统栈空间</p>
<!-- more -->
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数组、stack、queue</title>
    <url>/2023/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0Day1/</url>
    <content><![CDATA[<center>摘要：数组、stack、queue</center>

<span id="more"></span>

<h4 id="线性结构—数组"><a href="#线性结构—数组" class="headerlink" title="线性结构—数组"></a>线性结构—数组</h4><p>栈的底层操作——&gt;数组</p>
<h4 id="线性结构—栈"><a href="#线性结构—栈" class="headerlink" title="线性结构—栈"></a>线性结构—栈</h4><h5 id="特点：后进先出LIFO"><a href="#特点：后进先出LIFO" class="headerlink" title="特点：后进先出LIFO"></a>特点：后进先出LIFO</h5><p>只能从栈顶添加，取出；（操作的是数组的子集）</p>
<p>eg:撤销操作</p>
<h5 id="栈的复杂度"><a href="#栈的复杂度" class="headerlink" title="栈的复杂度"></a>栈的复杂度</h5> <img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210819151959688.png" alt="image-20210819151959688" style="zoom:67%;" />

<h4 id="线性结构—队列Queue"><a href="#线性结构—队列Queue" class="headerlink" title="线性结构—队列Queue"></a>线性结构—队列Queue</h4><h5 id="特点：先进先出FIFO"><a href="#特点：先进先出FIFO" class="headerlink" title="特点：先进先出FIFO"></a>特点：先进先出FIFO</h5><p>eg:办理业务</p>
<h5 id="队列复杂度"><a href="#队列复杂度" class="headerlink" title="队列复杂度"></a>队列复杂度</h5><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210819161236293.png" alt="image-20210819161236293" style="zoom:67%;" />

  

<h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>​        ——解决dequeue复杂度为O(n)的问题，首尾相接，复杂度变为O(1)</p>
<p>tail溢出是发生在入队操作中，解决办法：tail = (tail + 1) % capacity</p>
<p>参：<a href="https://juejin.cn/post/6844903805264347149">Java版-数据结构-队列（循环队列</a></p>
<p>代码分析两个队列花费时间的差距</p>
<p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210819232113828.png" alt="image-20210819232113828"></p>
<p>性能差距100倍！</p>
<!-- more -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java业务开发常见错误100例</title>
    <url>/2023/03/07/%E6%B5%85%E5%AD%A6Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/</url>
    <content><![CDATA[<center>极客时间</center>

<span id="more"></span>

<h1 id="Java业务开发常见错误100例"><a href="#Java业务开发常见错误100例" class="headerlink" title="Java业务开发常见错误100例"></a>Java业务开发常见错误100例</h1><h2 id="代码篇"><a href="#代码篇" class="headerlink" title="代码篇"></a>代码篇</h2><h4 id="线程安全错误"><a href="#线程安全错误" class="headerlink" title="线程安全错误"></a>线程安全错误</h4><p>原因：错用或者不会用集合导致的oom</p>
<p>解决方案：</p>
<h3 id="代码加锁的问题"><a href="#代码加锁的问题" class="headerlink" title="代码加锁的问题"></a>代码加锁的问题</h3><p>第一，使用 synchronized  加锁虽然简单，但我们首先要弄清楚共享资源是类还是实例级别的、会被哪些线程操作，synchronized 关联的锁对象或方法又是什么范围的。 </p>
<p>第二，加锁尽可能要考虑粒度和场景，锁保护的代码意味着无法进行多线程操作。对于 Web  类型的天然多线程项目，对方法进行大范围加锁会显著降级并发能力，要考虑尽可能地只为必要的代码块加锁，降低锁的粒度；而对于要求超高性能的业务，还要细化考虑锁的读写场景，以及悲观优先还是乐观优先，尽可能针对明确场景精细化加锁方案，可以在适当的场景下考虑使用 ReentrantReadWriteLock、StampedLock 等高级的锁工具类。 </p>
<p>第三，业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是，避免无限等待和循环等待。 此外，如果业务逻辑中锁的实现比较复杂的话，要仔细看看加锁和释放是否配对，是否有遗漏释放或重复释放的可能性；并且对于分布式锁要考虑锁自动超时释放了，而业务逻辑却还在进行的情况下，如果别的线线程或进程拿到了相同的锁，可能会导致重复执行。</p>
<p>​    必要的压测——如果你的业务代码涉及复杂的锁操作，强烈建议  Mock 相关外部接口或数据库操作后对应用代码进行压测，通过压测排除锁误用带来的性能问题和死锁问题。</p>
<h3 id="管理宝贵的资源——线程"><a href="#管理宝贵的资源——线程" class="headerlink" title="管理宝贵的资源——线程"></a>管理宝贵的资源——线程</h3><p>原因：线程池的使用</p>
<p>注意：</p>
<ol>
<li>线程池过多造成OOM 因为活跃线程过多和线程池不会被回收 </li>
<li>Java Stream Api异步分流 公用一个默认forkjion线程池，使用时要注意</li>
<li>线程池创建时要分析执行任务是IO资源型还是CPU资源型 </li>
<li>IO资源型或者说执行较长时间任务，并且拒绝策略为Call时，会在线程池满状态后交给<strong>调用者</strong>线程执行，如果是Web服务跑在tomcat⬆️的话，就导致整体吞吐量下降</li>
</ol>
<h3 id="管理宝贵的资源——连接池"><a href="#管理宝贵的资源——连接池" class="headerlink" title="管理宝贵的资源——连接池"></a>管理宝贵的资源——连接池</h3><ol>
<li>池化技术的核心在于，在鱼塘养好一群鱼，需要的时候就从里面拿一条，用完再放回去。而不是自己生产一条鱼，然后用完就销毁。从而减少了开销。</li>
<li>大多已经实现的连接池，都是有线程安全处理的。通常比个人创建管理连接更加安全。 </li>
<li>使用了连接池技术，就要保证连接池能够被有效复用。频繁创建连接池比频繁创建链接更加耗费资源。 </li>
<li>连接池的参数配置要根据实际情况，并不存在多多益善</li>
<li>连接池的主要好处：（1）减少资源消耗，（2）利用现有的线城安全实现，（3）提升并发量</li>
</ol>
<h3 id="Http调用超时、重试、并发问题"><a href="#Http调用超时、重试、并发问题" class="headerlink" title="Http调用超时、重试、并发问题"></a>Http调用超时、重试、并发问题</h3><ol>
<li>超时：<ol>
<li>连接超时代表建立 TCP 连接的时间</li>
<li>读取超时代表了等待远端返回数据的时间，也包括远端程序处理的时间。</li>
<li>在解决问题时，要考虑清楚连接的对象是谁（用户一般连接的是nginx），根据下游服务和自身服务设定合适的读取超时时间；</li>
<li>根据FeignClient配置规则修改配置后，检验是否生效</li>
</ol>
</li>
<li>重试：<ol>
<li>原因：网络丢包是比较常见的、查询是无状态的；</li>
<li>注意：考虑上下游接口的幂等性是否关闭自动重试；</li>
</ol>
</li>
<li>并发：包括 HttpClient 在内的 HTTP 客户端以及浏览器，都会限制客户端调用的最大并发数。</li>
</ol>
<h3 id="Spring声明式事务的使用"><a href="#Spring声明式事务的使用" class="headerlink" title="Spring声明式事务的使用"></a>Spring声明式事务的使用</h3><p>总结: ① 事务不生效的情况，事务注解加在private方法上、事务方法中调用的是内部this调用的方法而不是self     ②事务生效却出异常不回滚的情况，事务异常没有被传播出注解方法而是被捕获了、被事务注解的方法抛出的是受检异常导致不回滚 ③主方法提交，子方法出错不提交的做法: 子方法上注解加上 propagation = Propagation.REQUIRES_NEW 来设置 REQUIRES_NEW 方式的事务传播策略，也就是执行到这个方法时需要开启新的事务，并挂起当前事务</p>
<h3 id="数据库索引问题"><a href="#数据库索引问题" class="headerlink" title="数据库索引问题"></a>数据库索引问题</h3><p>过早的优化，是万恶之源。不需要提前考虑建立索引。等性能出现问题，真正的需求降临的时候再考虑优化。 建立索引之前，需要考虑索引带来的副作用：维护成本，空间成本，回表成本。 更重要的是还要考虑，你的查询是否能用到索引。如果花费大量成本建立的索引，最后还用不上。那就赔了夫人又折兵了。 索引又牵扯到了很多注意事项，例如：尽量使用前缀匹配，而避免使用后缀匹配。因为后缀匹配会使得索引失效，走全表匹配。</p>
<h3 id="数值计算的精度、舍入和溢出问题"><a href="#数值计算的精度、舍入和溢出问题" class="headerlink" title="数值计算的精度、舍入和溢出问题"></a>数值计算的精度、舍入和溢出问题</h3><p>手机计算器把 10%+10% 算成了 0.11 而不是 0.2。 出现这种问题的原因在于，国外的计算程序使用的是单步计算法。在单步计算法中，a+b% 代表的是 a*(1+b%)。所以，手机计算器计算 10%+10% 时，其实计算的是 10%*（1+10%），所以得到的是 0.11 而不是 0.2。</p>
<ol>
<li>使用 BigDecimal 表示和计算浮点数，应该使用 String 入参的构造方法或者 BigDecimal.valueOf 方法来初始化。</li>
<li>对于浮点数的格式化</li>
<li>如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法;如果结合 HashSet 或 HashMap 使用的话,使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。</li>
</ol>
<h3 id="文件读写中的问题"><a href="#文件读写中的问题" class="headerlink" title="文件读写中的问题"></a>文件读写中的问题</h3><p>第一，如果需要读写字符流，那么需要确保文件中字符的字符集和字符流的字符集是一致的，否则可能产生乱码。 </p>
<p>第二，使用 Files 类的一些流式处理操作，注意使用 try-with-resources 包装 Stream，确保底层文件资源可以释放，避免产生 too many open files 的问题。 </p>
<p>第三，进行文件字节流操作的时候，一般情况下不考虑进行逐字节操作，使用缓冲区进行批量读写减少 IO 次数，性能会好很多。一般可以考虑直接使用缓冲输入输出流 BufferedXXXStream，追求极限性能的话可以考虑使用 FileChannel 进行流转发。</p>
<h3 id="OOM有关的问题"><a href="#OOM有关的问题" class="headerlink" title="OOM有关的问题"></a>OOM有关的问题</h3><ol>
<li>我们的程序确实需要超出 JVM 配置的内存上限的内存。</li>
<li>内存泄漏，其实就是我们认为没有用的对象最终会被 GC，但却没有。强引用的选择使用；</li>
<li>不合理的资源需求配置，在业务量小的时候可能不会出现问题，但业务量一大可能很快就会撑爆内存。Tomacat</li>
</ol>
<p>解决办法：为生产系统的程序配置 JVM 参数启用详细的 GC 日志，方便观察垃圾收集器的行为，并开启 HeapDumpOnOutOfMemoryError，以便在出现 OOM 时能自动 Dump 留下第一问题现场。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">XX:+HeapDumpOnOutOfMemoryError</span> <span class="string">-XX:HeapDumpPath=.</span> <span class="string">-XX:+PrintGCDateStamps</span> <span class="string">-XX:+PrintGCDetails</span> <span class="string">-Xloggc:gc.log</span> <span class="string">-XX:+UseGCLogFileRotation</span> <span class="string">-XX:NumberOfGCLogFiles=10</span> <span class="string">-XX:GCLogFileSize=100M</span></span><br></pre></td></tr></table></figure>





<h3 id="反射、注解、泛型的坑"><a href="#反射、注解、泛型的坑" class="headerlink" title="反射、注解、泛型的坑"></a>反射、注解、泛型的坑</h3><ol>
<li></li>
</ol>
<h3 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h3><ol>
<li>spring容器管理对象默认是单例模式，可能会导致内存泄露问题；</li>
</ol>
<h2 id="设计篇"><a href="#设计篇" class="headerlink" title="设计篇"></a>设计篇</h2><h3 id="解决代码重复"><a href="#解决代码重复" class="headerlink" title="解决代码重复"></a>解决代码重复</h3><ol>
<li><p>利用工厂设计模式和模版设计方法</p>
<p>​        我们可以考虑提取相同逻辑在父类中实现，差异逻辑通过抽象方法留给子类实现。</p>
</li>
<li><p>通过反射+注解的方式</p>
<p>​        使用硬编码的方式重复实现相同的数据处理算法。我们可以考虑把规则转换为自定义注解，作为元数据对类或对字段、方法进行描述，然后通过反射动态读取这些元数据、字段或调用方法，实现规则参数和规则定义的分离。也就是说，把变化的部分也就是规则的参数放入注解，规则的定义统一处理。</p>
</li>
<li><p>利用属性拷贝工具消除重复代码</p>
</li>
</ol>
<p>注意：可以把代码重复度作为评估一个项目质量的重要指标，如果一个项目几乎没有任何重复代码，那么它内部的抽象一定是非常好的。在做项目重构的时候，可以以消除重复为第一目标去考虑实现。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。</p>
<ol>
<li>针对响应体的设计混乱、响应结果的不明确问题，服务端需要明确响应体每一个字段的意义，以一致的方式进行处理，并确保不透传下游服务的错误。</li>
<li>接口版本控制问题。解决不兼容问题</li>
<li>针对接口的处理方式，需要明确要么是同步要么是异步。</li>
</ol>
<h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><ol>
<li>不要把Redis作为数据库使用；Redis 的特点是，处理请求很快，但无法保存超过内存大小的数据。</li>
<li>把reids作为缓存使用时的注意事项：<ol>
<li>从客户端的角度来说，缓存数据的特点一定是有原始数据来源，且允许丢失；当数据丢失后，我们需要从原始数据重新加载数据，不能认为缓存系统是绝对可靠的，更不能认为缓存系统不会删除没有过期的数据。</li>
<li>从 Redis 服务端的角度来说，缓存系统可以保存的数据量一定是小于原始数据的。首先，我们应该限制 Redis 对内存的使用量，也就是设置 maxmemory 参数；其次，我们应该根据数据特点，明确 Redis 应该以怎样的算法来驱逐数据。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20230306151954911.png" alt="image-20230306151954911" style="zoom:30%;" /></li>
</ol>
</li>
<li><strong>缓存雪崩问题</strong><ul>
<li>原因：第一是缓存系统本身不可用；第二是应用设计层面大量的 Key 在同一时间过期，导致大量的数据回源。</li>
<li>解决办法：<ul>
<li>方案一：差异化设置缓存TTL。增加扰动值；</li>
<li>方案二：让缓存永不过期。设置一个后台进程，30s一次把全量数据更新到缓存</li>
</ul>
</li>
<li>注意：不管是方案一还是方案二，在把数据从数据库加入缓存的时候，都需要判断来自数据库的数据是否合法，比如进行最基本的判空检查。生产事故eg：DBA归档数据库（类似删除），从数据库中查询到了空数据加入缓存，爆发了大面积的事故。</li>
</ul>
</li>
<li><strong>缓存击穿问题</strong><ul>
<li>原因：某个热点key失效，大量并发请求昂贵回源；</li>
<li>方案：<ul>
<li>方案一，使用进程内的锁进行限制，这样每一个节点都可以以一个并发回源数据库； </li>
<li>方案二，不使用锁进行限制，而是使用类似 Semaphore 的工具限制并发数，比如限制为 10，这样既限制了回源并发数不至于太大，又能使得一定量的线程可以同时回源。</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存穿透问题</strong><ul>
<li>原因：缓存没有起到压力缓冲的作用；</li>
<li>方案：<ul>
<li>方案一：对于不存在的数据，设置一个特殊的 Value 到缓存中；但是可能会导致大量无效key。</li>
<li>方案二：我们需要同步所有可能存在的值并加入布隆过滤器，这是比较麻烦的地方。如果业务规则明确的话，你也可以考虑直接根据业务规则判断值是否存在。</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存数据同步问题</strong><ul>
<li>原因：更新缓存信息/和更新数据库先后顺序？</li>
<li>注意：考虑数据一致性问题；删除、更新操作的幂等性；</li>
<li>方案：缓存中的数据不由数据更新操作主动触发，统一在需要使用的时候按需加载，数据更新后及时删除缓存中的数据即可。</li>
</ul>
</li>
<li>使用缓存系统的时候，要监控缓存系统的内存使用量、命中率、对象平均过期时间等重要指标，以便评估系统的有效性，并及时发现问题。</li>
</ol>
<h3 id="业务上生产线的问题"><a href="#业务上生产线的问题" class="headerlink" title="业务上生产线的问题"></a>业务上生产线的问题</h3><p>完整的应用监控体系一般由三个方面构成，包括日志 Logging、指标 Metrics 和追踪 Tracing。</p>
<p>管理者 ：面向过程管理——背结果</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ol>
<li><p>直接运行课件代码：</p>
<ol>
<li>pom文件：删除spring-boot-starter-actuator 依赖；redisson-spring-boot-starter 里exclude redisson-spring-boot-starter 依赖。</li>
<li>对应的@SpringBootApplication 注解上添加exclude = { DataSourceAutoConfiguration.class, RedissonAutoConfiguration.class }</li>
</ol>
</li>
<li><p>解决IDEA配置.gitignore不生效的问题</p>
<ol>
<li><p>原因：**.gitignore只能忽略未被track的文件，<strong>而git本地缓存。</strong>如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的**。</p>
</li>
<li><p>解决办法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git rm -r <span class="comment">--cached .</span></span><br><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li></li>
</ol>
<!-- more -->

]]></content>
      <categories>
        <category>-JAVA</category>
      </categories>
      <tags>
        <tag>-JAVA -学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树（区间树）</title>
    <url>/2023/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<center>线段树（区间树）</center>

<p>​        为什么要有线段树？比如现在有一个数组，要计算和查赵这个数组中某个区间的值的和，那么它的时间复杂度就是O(n),要遍历数组；而如果使用树结构，他的时间复杂度为O(logn)；差距还是很大的</p>
<span id="more"></span>

<h3 id="什么是线段树？"><a href="#什么是线段树？" class="headerlink" title="什么是线段树？"></a>什么是线段树？</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823134438439.png" alt="image-20210823134438439" style="zoom:50%;" />

<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><p>​    线段树不是完全二叉树<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823135312682.png" alt="image-20210823135312682" style="zoom:50%;" /></p>
</li>
<li><p>线段树也是平衡二叉树</p>
</li>
</ul>
<h3 id="用数组实现，开辟空间，定义左子树和右子树"><a href="#用数组实现，开辟空间，定义左子树和右子树" class="headerlink" title="用数组实现，开辟空间，定义左子树和右子树"></a>用数组实现，开辟空间，定义左子树和右子树</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824101136411.png" alt="image-20210824101136411" style="zoom:50%;" />

<h3 id="创建线段树："><a href="#创建线段树：" class="headerlink" title="创建线段树："></a>创建线段树：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824093203026.png" style="zoom:50%;" /></h3><h3 id="线段树的区间查询操作"><a href="#线段树的区间查询操作" class="headerlink" title="线段树的区间查询操作"></a>线段树的区间查询操作</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824093607084.png" alt="image-20210824093607084" style="zoom:50%;" />

<h3 id="线段树的更新操作"><a href="#线段树的更新操作" class="headerlink" title="线段树的更新操作"></a>线段树的更新操作</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824095553046.png" alt="image-20210824095553046" style="zoom:80%;" />

<p>​    Lazy更新</p>
<h4 id="链式动态线段树"><a href="#链式动态线段树" class="headerlink" title="链式动态线段树"></a>链式动态线段树</h4><p>不浪费空间</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824095756869.png" alt="image-20210824095756869" style="zoom:50%;" />





<h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul>
<li>leetcode第303题区域和检查</li>
<li>leetcode第307题区域和检查美版UPDATe</li>
<li>树状数组（了解）BIT</li>
<li>RMQ问题</li>
</ul>
<!-- more -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>链表</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>经典红黑树</title>
    <url>/2023/03/07/%E7%BB%8F%E5%85%B8%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<center>红黑树</center>

<span id="more"></span>

<p>先介绍下2——3树</p>
<h4 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h4><p><strong>性质</strong>：</p>
<ul>
<li>满足二分搜索树的基本性质</li>
<li>节点可以存放一个或者两个元素</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825181737508.png" alt="image-20210825181737508" style="zoom:50%;" /></li>
<li>2-3树是一棵<strong>绝对平衡</strong>的树</li>
</ul>
<h4 id="2-3树如何维持绝对平衡的？"><a href="#2-3树如何维持绝对平衡的？" class="headerlink" title="2-3树如何维持绝对平衡的？"></a>2-3树如何维持绝对平衡的？</h4><p>​        在插入数据的时候不会放在null的位置，if null就和parent节点暂时相融合变成3节点或者4节点如图：</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825182718575.png" alt="image-20210825182718575" style="zoom: 50%;" />

<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825182857559.png" alt="image-20210825182857559" style="zoom: 50%;" /> <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825182949188.png" alt="image-20210825182949188" style="zoom: 50%;" /></p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825183001986.png" alt="image-20210825183001986" style="zoom: 50%;" />

<h4 id="红黑树与2-3树的等价性"><a href="#红黑树与2-3树的等价性" class="headerlink" title="红黑树与2-3树的等价性"></a>红黑树与2-3树的等价性</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825183847374.png" alt="image-20210825183847374" style="zoom:67%;" />

<p>b—c连接线变成红色的b变为红色的</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825190929549.png" alt="image-20210825190929549" style="zoom:80%;" />

<p>定义一个红黑树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comprarable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACk = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            color = RED;<span class="comment">//默认创建的节点为红色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="《算法导论》中的红黑树"><a href="#《算法导论》中的红黑树" class="headerlink" title="《算法导论》中的红黑树"></a>《算法导论》中的红黑树</h4><ol>
<li>每个节点或者是红色的，或者是黑色的；</li>
<li>根节点是黑色的；</li>
<li>每个叶子节点（最后的空节点）是黑色的；</li>
<li>如果一个节点是红色的，那么它的孩子节点是黑色的；</li>
<li>从任意一个节点到叶子节点，经过的黑色节点是一样的；</li>
</ol>
<p>保持“<strong>黑平衡</strong>”的二叉树，严格意义上，不是平衡二叉树；</p>
<p>最大高度：2logn<strong>时间复杂度还是</strong>O(Logn)</p>
<h4 id="红黑树中添加元素"><a href="#红黑树中添加元素" class="headerlink" title="红黑树中添加元素"></a>红黑树中添加元素</h4><ul>
<li>红黑树添加新元素（了解）</li>
</ul>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210826143441667.png" alt="image-20210826143441667" style="zoom:67%;" />

<h4 id="红黑树的性能总结"><a href="#红黑树的性能总结" class="headerlink" title="红黑树的性能总结"></a>红黑树的性能总结</h4><ul>
<li>对于完全随机的数据，普通的二分搜索树很好用；</li>
<li>对于查询较多的使用情况，AVL树很好用；</li>
<li>红黑树牺牲了平衡性（2logn的高度）</li>
</ul>
<p>统计性能更优（增删改查平均情况下更优）</p>
<p>​        整个红黑树的查找，插入和删除都是 O (logN) 的，原因就是整个红黑树的高度是 logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是 logN。</p>
<h4 id="红黑树的底层应用"><a href="#红黑树的底层应用" class="headerlink" title="红黑树的底层应用"></a>红黑树的底层应用</h4><ul>
<li> linux 中进程的调度用的是红黑树；</li>
<li>Java 中 HashMap、TreeMap、TreeSet（都在内存中操作）也都是用红黑树实现；</li>
</ul>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><ul>
<li>好文：<a href="https://segmentfault.com/a/1190000023651273">数据结构之红黑树</a></li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
        <tag>2-3树</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记</title>
    <url>/2023/03/07/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>读书笔记</center>

<span id="more"></span>

<h1 id="《李松蔚：认知思维》"><a href="#《李松蔚：认知思维》" class="headerlink" title="《李松蔚：认知思维》"></a>《李松蔚：认知思维》</h1><h2 id="认识思维"><a href="#认识思维" class="headerlink" title="认识思维"></a>认识思维</h2><p>认识心理学的规律，掌握规律；</p>
<h2 id="看清问题的本质（认识问题）"><a href="#看清问题的本质（认识问题）" class="headerlink" title="看清问题的本质（认识问题）"></a>看清问题的本质（认识问题）</h2><ol>
<li><p>如何用想法改变想法</p>
<p>认识到自己的想法只是想法；</p>
</li>
<li><p>了解什么是自动化思维</p>
<p>遇到一件事，我们的本能反应（刻板印象）就是一种自动化思维的体现；</p>
</li>
<li><p>了解信念对人的影响</p>
<p>认识到每个人都有看待世界不同的眼镜，也就是不同的信念；</p>
</li>
<li><p>了解升级认知的方法</p>
<p>了解大脑中的“快慢思维”，遇到问题可以进行换位思考，提高认知；升级认知也是为了明确责任划分和解决问题；</p>
</li>
</ol>
<h2 id="找到问题的关键"><a href="#找到问题的关键" class="headerlink" title="找到问题的关键"></a>找到问题的关键</h2><ol>
<li><p>掌握突破因果的思维方式</p>
<p>换位思考的具体落地，遇到问题从每个角度思考寻找原因，（个人、他人、不可抗因素）分别寻找原因，最终找到最好的解决办法；</p>
</li>
<li><p>了解“不同的认识”对人的影响</p>
<p>适度的风险是我们获得成长和经验的途径；风险一定是风险吗？我们的自动化思维会把“风险”看做一种警告信号，但是有的人会把他看做机会，这就是不同的认识。</p>
</li>
<li><p>了解如何用发展的角度看待问题</p>
<p>做事要有技巧，不要使蛮力，要学会用发展的眼光来看问题。</p>
<p>对于有生命的对象，变化是常态，除非是谁做了什么，它才会不变。问题不可能会由导致问题的方式所解决。——爱因斯坦</p>
<p>问题：总是想玩，没有时间学习、阅读。</p>
<p>答案：越是正确的事情，越是容易被坚持下来。</p>
</li>
<li><p>打破信念往往能带来全新的可能</p>
</li>
</ol>
<h2 id="建立说服的逻辑（该怎么说）"><a href="#建立说服的逻辑（该怎么说）" class="headerlink" title="建立说服的逻辑（该怎么说）"></a>建立说服的逻辑（该怎么说）</h2><ol>
<li><p>掌握合作的思维模式</p>
<ol>
<li>牢记这一点，需要我们时刻保持开放的心态。看到别人不一样的地方，要认识到谁都没有错，只是我们不一致。</li>
<li>我满足你的要求，然后再提出自己的要求。</li>
</ol>
</li>
<li><p>建设领导力的基础</p>
<p>我看到的东西是我的，我被你看到的东西，那都是你的。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221122192533511.png" alt="image-20221122192533511" style="zoom:50%;" /></p>
</li>
<li><p>为什么总是受别人的影响？（自我授权）</p>
<p>明白责任和权力的关系；主动改变一个事情的同时就要改变自己承担的责任；</p>
</li>
<li><p>了解跳出自我的方法（打破思维的限制）</p>
<p>角色的价值，存在于和别人的交互当中。</p>
<p>比如我们在卖一个产品的时候，要考虑别人怎么用；</p>
<p>​        你的还是你的，不因为谁用谁不用而变。所以，不需要总是把目光在自己身上，想着【你】要呈现给别人什么。不是的。这个世界最有趣的地方就在于每个人都有自己的视角。没有人真的在看【你】，他们都在看对自己有用的东西，那么你就顺着来，找到一种恰如其分的方式，让他们得到满足。你也就影响了他们。他们喜欢你，讨厌你，都跟你无关，都是你影响他们的方式。你越理解这一点，就越具有对这个世界的影响力。</p>
</li>
</ol>
<h2 id="掌控人生的规律（该怎么活）"><a href="#掌控人生的规律（该怎么活）" class="headerlink" title="掌控人生的规律（该怎么活）"></a>掌控人生的规律（该怎么活）</h2><ol>
<li><p>了解”意义“的重要性</p>
<p>意义的价值在于独特性。所以主动的发现自己的独特性，发挥自己的特点，找到人生的意义才是最重要的；</p>
</li>
<li><p>用联结发现意义</p>
<ol>
<li>跟具体的人，跟某个事物，跟观念之间的联结，是我们意义感的三大来源<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221123221107608.png" alt="image-20221123221107608" style="zoom:50%;" /></li>
<li>就像上学的时候老师说：你学习是为了别人吗？不是啊，是为了你们自己！我们好像觉得这样是更高尚的：不要为了谁去做一件事情，就是为了自己。错了，这句话根本没有解决这个问题。这恰恰造成了很多人找不到意义，如果你做这个事情只跟自己有关，这个事情做或者不做，做得好或者不好，你感受不到对别人有任何差别，那就像开头我们说的那个戒烟的男生一样，你做了，你也觉得没有意思。做着做着你就不想做了。</li>
</ol>
<p>所以，为了好好做一件事情，做得开心，做得来劲，你恰恰需要问自己的是：我是为了谁，或者为了什么，才做这件事的？——在这件事情里，我看到的不是只有我一个人。</p>
<p>把自己的很多事，放到关系的背景里，变成一件有意义的事情。为生活找到更多的联结，从而发现不一样的意义。</p>
</li>
<li><p>我们建立意义感的过程，其实就是我们放弃掌控的过程。我们越是意识到很多事情不在我们的掌控当中，我们试图去理解别人的意志，去理解时代的意志，去理解更大的，更超验的那些命题，我们就越是会知道自己在这个过程里扮演了怎样的角色，看到我的意义在哪里。</p>
</li>
<li><p>理解孤独和独立</p>
<p>保持自己的独立性，摆脱工具性的存在；</p>
</li>
</ol>
<h1 id="《个人职场的顶层设计》"><a href="#《个人职场的顶层设计》" class="headerlink" title="《个人职场的顶层设计》"></a>《个人职场的顶层设计》</h1><h2 id="职场之路的顶层设计"><a href="#职场之路的顶层设计" class="headerlink" title="职场之路的顶层设计"></a>职场之路的顶层设计</h2><ol>
<li><p>敢于走出舒适区</p>
</li>
<li><p>做任何事都需要有备而来<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126150744978.png" alt="image-20221126150744978" style="zoom: 25%;" /></p>
</li>
<li><p>选择比努力更重要<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126150821147.png" alt="image-20221126150821147" style="zoom:33%;" /></p>
</li>
<li><p>选择自己要走的路，承担相应的风险就要接受相应的回报</p>
</li>
<li><p>学会计算自己给企业创造的价值<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126151046103.png" alt="image-20221126151046103" style="zoom:50%;" /></p>
</li>
<li><p>自我管理的提升——先做该做的事，再做想做的事。</p>
</li>
<li><p>学会自我激励（责任心、事业心、上进心）</p>
</li>
<li><p>一步一步脚踏实地</p>
<p>不想当将军的士兵才是好士兵。</p>
</li>
<li><p>客观的才是正确的The preception is truth.</p>
</li>
<li><p>学习技能，提高自己的竞争力。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221126152109974.png" alt="image-20221126152109974" style="zoom:50%;" /></p>
</li>
<li><p>企业的顶层设计</p>
<p>企业的顶层设计有五个内涵：<strong>从后往前看、系统化思考、利他化驱动、剧本化分工、图形化描述。</strong></p>
<p>从后向前看是指用终局思维来思考企业想要达到什么样的目标，倒推现在应该怎么做。</p>
<p>系统化思考是要找到问题的根本解，不能“头疼医头，脚疼医脚”。</p>
<p>利他化驱动是做事情先要为他人着想，考虑别人舒服不舒服，这样才能达到达到双赢。</p>
<p>剧本化分工是在操作模式上像剧本一样先进行干转、预演。</p>
<p>图形化描述是要通过传递有画面感的语言，让人可以想象将来的生活。</p>
</li>
</ol>
<h2 id="如何制定-个人的顶层设计"><a href="#如何制定-个人的顶层设计" class="headerlink" title="如何制定 个人的顶层设计"></a>如何制定 个人的顶层设计</h2><h5 id="一、提升自身价值"><a href="#一、提升自身价值" class="headerlink" title="一、提升自身价值"></a><strong>一、提升自身价值</strong></h5><ol>
<li><p><strong>想清楚企业靠什么生存</strong></p>
<ol>
<li>如果在市场经济条件下，用心做事、追求完美、掌握技能、创造价值才能够得到客户的青睐。</li>
<li>高建华老师当时学习的每个产品都要演讲五个片子。第一，我们在这个领域的世界地位是什么？第二，产品的特点是什么？第三，我们的产品比竞争对手的产品好在哪儿？第四，我们的产品能给你带来什么独到的价值？第五，我们有哪些产品型号和价格供你选择？</li>
</ol>
</li>
<li><p><strong>成为不可抹去的优秀人才</strong></p>
<p>1234法则：学会一个人挣两个人的钱，干三个人的活，创造四个人的效益。</p>
</li>
</ol>
<h5 id="二、做人做事的原则"><a href="#二、做人做事的原则" class="headerlink" title="二、做人做事的原则"></a><strong>二、做人做事的原则</strong></h5><ol>
<li><p>学会做人–（拒绝撒谎、保持谦卑）</p>
</li>
<li><p>学会做事</p>
<ol>
<li><p><strong>学会用规定动作</strong>。</p>
<p>一个企业的管理水平越高，它的规定动作越多。</p>
</li>
<li><p>一次就把事情做好。</p>
<p>一次做对需要进行干转和预演。干转是Dry run。比如说国家要改变个人所得税，不能轻易地改，要把现有的数据放到系统里干转一年，用产生的数据再来做决策。预演是Rehearsal，比如大会、电视节目、婚礼等都会有预演。</p>
</li>
<li><p><strong>学会用问话开头。</strong></p>
</li>
</ol>
</li>
</ol>
<h5 id="三、提升自身价值的九个方法"><a href="#三、提升自身价值的九个方法" class="headerlink" title="三、提升自身价值的九个方法"></a><strong>三、提升自身价值的九个方法</strong></h5><ol>
<li>静下心来练真功夫；</li>
<li>学会照镜子</li>
<li>学会一件事会做了之后，要把它变成流程。</li>
<li>学会“找对人、问对话、做对事”，<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221201164659431.png" alt="image-20221201164659431" style="zoom:50%;" /></li>
<li><strong>学会做计划</strong>做计划之前就是要减少变量，找到变量背后不变的逻辑，消除焦虑。</li>
<li><strong>学会提炼</strong> ——写周报</li>
<li><strong>学会检查</strong></li>
<li>重视汇报，学会理解</li>
</ol>
<h2 id="正确理解“跳槽”对职业的影响"><a href="#正确理解“跳槽”对职业的影响" class="headerlink" title="正确理解“跳槽”对职业的影响"></a>正确理解“跳槽”对职业的影响</h2><ol>
<li><strong>盲目跳槽弊大于利</strong></li>
<li><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221201170213838.png" alt="image-20221201170213838" style="zoom:50%;" /></li>
<li>学会踏踏实实，苹果发现高建华老师一口气在惠普工作八年半，做事很踏实。</li>
<li>实力主力</li>
</ol>
<h2 id="如何成为“管理者”"><a href="#如何成为“管理者”" class="headerlink" title="如何成为“管理者”"></a>如何成为“管理者”</h2><ol>
<li><p>管理最基本的定义是通过他人把事情办好。</p>
</li>
<li><p>管理背后的逻辑一定是把员工的个人利益与公司的集体利益挂钩。</p>
<p>“咖啡时间”这是一套非常好的制度，</p>
</li>
<li><p> 启发员工去思考。给部下选择权，对自己负责。</p>
</li>
<li><p>管理者日常有四大类工作：任务设定、人才管理、绩效提升、质量保障。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221201172724100.png" alt="image-20221201172724100" style="zoom:50%;" /></p>
<h5 id="成为优秀管理者的五个建议"><a href="#成为优秀管理者的五个建议" class="headerlink" title="成为优秀管理者的五个建议"></a>成为优秀管理者的五个建议</h5><ol>
<li><p>一个好的管理者要教会别人提高效率，想办法鼓励那些绩效好的员工给大家分享经验，把成功的方法复制给大家</p>
</li>
<li><p><strong>要做到顶天立地</strong> 出了什么事故，管理者要首先承担责任，每一个事情都必须有第一责任人。</p>
</li>
<li><p>一个好的管理者不仅要能干，还要会讲。</p>
<p>陈述演讲要做到Point、Turn、Speak，Point是指先拿教鞭指着要讲的内容，Turn就是转过头来面向观众，Speak是讲述。</p>
</li>
<li><p>独立思考</p>
<p>要学会独立思考，不要总想着成为别人。中国社会现在有一个要命的风气，就是老看着别人好，习惯走别人走过的路，总是抄袭别人的。</p>
<p>中国的教育一直关注的都是孩子的缺点，这种挫折型的教育会对孩子的天性有太多的打压，实际上应该多关注孩子的优点，进行鼓励式教育，鼓励每个孩子发挥自己的兴趣和特长，做自己擅长做的事情，这样才有助于激发国民的创造性。</p>
</li>
<li><p>回归到员工个人利益上；</p>
</li>
</ol>
</li>
</ol>
<h2 id="如何反向管理者（交流）"><a href="#如何反向管理者（交流）" class="headerlink" title="如何反向管理者（交流）"></a>如何反向管理者（交流）</h2><ol>
<li>职场上，管理好我们的上司有八个实用的方法：做事要超过上司的期望值、做人要与上司的价值观一致、懂得为上司分忧、用脑思考用心做事、不要给上司添乱、让上司主动帮你做事、要经得住上司的考验、关键时刻露一手。</li>
</ol>
<h2 id="如何提升自己"><a href="#如何提升自己" class="headerlink" title="如何提升自己"></a>如何提升自己</h2><h1 id="《李忠秋：结构思考力》"><a href="#《李忠秋：结构思考力》" class="headerlink" title="《李忠秋：结构思考力》"></a>《李忠秋：结构思考力》</h1><h2 id="理解结构化思考力的理念"><a href="#理解结构化思考力的理念" class="headerlink" title="理解结构化思考力的理念"></a>理解结构化思考力的理念</h2><ol>
<li>结构化思考的金字塔结构来源于树形结构，为了达到纵向一体化和横向多元化。</li>
<li>关键在于：隐形思维显性化，快速地找出信息结构，把握重点，提高分析问题、解决问题以及表达问题的效率和效果；</li>
<li>面对纷繁复杂的信息，一定要有自己审视问题的坐标系，要学会总结自己的一些方法论；<ol>
<li>要重视思维能力的训练，多一些思考；</li>
</ol>
</li>
<li>在……的基础上，从xxx和yyy两个方面，说明……</li>
</ol>
<h2 id="如何拥有结构化的思考力"><a href="#如何拥有结构化的思考力" class="headerlink" title="如何拥有结构化的思考力"></a>如何拥有结构化的思考力</h2><ol>
<li>分类、总结、提炼；<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221211215340816.png" alt="image-20221211215340816" style="zoom:50%;" /></li>
<li>结构化思维：结论先行，依次阐明观点，再次总结观点</li>
<li>学会分类：3和7  核心：不重不漏（相互独立，完全穷尽）</li>
<li>学会逻辑顺序 从时间顺序、结构性顺序、重要性顺序递进</li>
</ol>
<h2 id="结构化思考力的展示"><a href="#结构化思考力的展示" class="headerlink" title="结构化思考力的展示"></a>结构化思考力的展示</h2><p>找到每个模块之间的联系，合理得利用图表结构可以更加高效得表达出自己结构化思考的内容；</p>
<ol>
<li><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221212180711763.png" alt="image-20221212180711763"></li>
<li><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221212181549075.png" alt="image-20221212181549075"></li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li>描述问题定方向<ol>
<li>利用5W2H方法搞清楚问题</li>
</ol>
</li>
<li>基于目标定主题<ol>
<li>明确目标受众，让表达有的放矢；</li>
<li>写好序言：情景-&gt;冲突-》疑问-&gt;回答</li>
<li>根据目标的疑问-回答，自上而下搭建内容框架</li>
</ol>
</li>
<li>说服更有力—演绎<ol>
<li>标准式演绎——大前提+小前提+结论</li>
<li>常见式演绎——现象+原因+对应的方法+结论</li>
</ol>
</li>
<li>要点更清晰—归纳<ol>
<li>封闭式分类——按照模型分类：金字塔、</li>
<li>开放式分类——四象限<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221214215456823.png" alt="image-20221214215456823" style="zoom:80%;" /></li>
</ol>
</li>
<li>配关系</li>
</ol>
<h1 id="《管理你的情绪》"><a href="#《管理你的情绪》" class="headerlink" title="《管理你的情绪》"></a>《管理你的情绪》</h1><p>​        人的情商包括认知自己的情绪、管理自己的情绪、有效地推动自己、认识别人的情绪、处理好人际关系。如果能够做好自己的情绪管理，就能够让自己达到高情商的状态，让自己拥有更多的财富、更好的社会关系、更健康的身体状态，让生活更加的成功。<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221219204305575.png" alt="image-20221219204305575" style="zoom:30%;" /></p>
<p><strong>真正地认知情绪</strong></p>
<ol>
<li>作者认为：<strong>一个人在社会上要获得成功，起主要作用的不是智力因素，而是情绪智商，前者占20％，后者占80％</strong>。</li>
<li>一位心理学家<strong>丹尼尔·卡尔曼</strong>写了一本书《<strong>情商</strong>》，对情商做了系统的诠释。丹尼尔·卡尔曼认为人的情商由两个部分组成，<strong>第一个部分包括认知自己的情绪、管理自己的情绪、有效地推动自己，第二个部分包括认识别人的情绪、处理好人际关系。</strong></li>
<li><strong>情绪从来都不是问题，只是提示我们。</strong>大部分人都知道管理情绪，但是重要的是想不想去管理。</li>
</ol>
<p><strong>有效地情绪管理</strong></p>
<ol>
<li>管理自己的情绪有四个表现：通过有效的方法调节自己的情绪；配合情绪状态做事，不被情绪控制；读懂自己情绪背后的意义；改变产生情绪的根源。</li>
<li>有效地推动自己，包括四个阶段：有效设定自己的目标、认识到目标对自己的意义、了解自己的内在价值观、从“知道”到“做到”。</li>
</ol>
<p>当一个人知道自己在某一个场合应该是什么角色，那他就能够把人际关系处理得很好。处理好人际关系包含四个方面：在相互关系中认知自己的角色与价值、有效地表达自己的想法、有效倾听和换位思考、让对方感受到自我价值。</p>
<p>传统的情绪处理法如发泄、压抑、转移等，都是在处理情绪所带来的身体感受。<strong>作为成年人还需要从理性、感性、角色的角度进行情绪管理。</strong></p>
<h1 id="《tiny-habits：福格行为模型》"><a href="#《tiny-habits：福格行为模型》" class="headerlink" title="《tiny habits：福格行为模型》"></a>《tiny habits：福格行为模型》</h1><ol>
<li><p><strong>福格行为模型（BJ Foog’s Behaviour Model）</strong>来源于福格和美国说服技术实验室的研究，它是<strong>一种有效探寻行为原因的模型</strong>。</p>
<p>模型只包含三个基本元素：<strong>动机</strong>（Motivation）、<strong>能力</strong>（Ability）、<strong>触发条件</strong>（Trigger）</p>
<p><img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221219100251268.png" alt="image-20221219100251268" style="zoom:50%;" />蓝色曲线以上的部分就是“一个用户行为可能发生的地方”。</p>
</li>
</ol>
<h3 id="提升动机"><a href="#提升动机" class="headerlink" title="提升动机"></a>提升动机</h3><ol>
<li><p>动机分为两种（在八角行为分析法中也有对内在、外在动机的具体分析）：</p>
<ol>
<li><strong>外在动机</strong>：来自目标、目的或奖励。</li>
<li><strong>内在动机</strong>：来自个人自身，包括成就感、好奇心以及满足感等。</li>
</ol>
<p>最优秀的设计是同时提供外在和内在两种动机。比如提供折扣（省钱的外部动机）以及学习某项技能或培养健康的习惯（实现目标的内在希望）。</p>
</li>
</ol>
<h3 id="增强能力"><a href="#增强能力" class="headerlink" title="增强能力"></a>增强能力</h3><p><strong>数字设计和产品应该从本质上提升用户的能力，超过他们使用相应非数字化产品的能力。</strong></p>
<p>比如用手机玩斗地主，你可以不用准备牌和洗牌，不用自己计算分数，还可以远程和朋友玩（原来必须线下聚在一起）。</p>
<p><strong>你的产品应该同时提升用户完成目标任务的能力以及使用实际产品的能力（操作简单）。</strong></p>
<p>你要明确哪些资源对于用户来说是最稀缺的，以及如何在设计中节约这些资源。</p>
<ul>
<li>如果用户有时间而没钱，那就让他们用你的产品来赚钱或省钱。</li>
<li>如果用户有钱而没时间，那就让他们支付额外的费用以更快地完成任务。</li>
<li>如果发现用户使用产品遇到太多困难，那就进行相应的用户研究，确定如何进行内容分类、设计标签文案以及提供有效的指引和常见问题的解答。</li>
</ul>
<h3 id="呈现有效的触发"><a href="#呈现有效的触发" class="headerlink" title="呈现有效的触发"></a>呈现有效的触发</h3><p><strong>用户需要意识到触发的存在，明白触发引发的结果是做出预期行为，并且用户的动机和能力要高于临界值才能激活触发并做出行为。</strong>也就说（要做且能做）</p>
<h3 id="实际生活中的应用"><a href="#实际生活中的应用" class="headerlink" title="实际生活中的应用"></a>实际生活中的应用</h3><p>关于养成一个习惯</p>
<ol>
<li>洗袜子、拖地、地铁上读书</li>
</ol>
<h1 id="《非暴力沟通》"><a href="#《非暴力沟通》" class="headerlink" title="《非暴力沟通》"></a>《非暴力沟通》</h1><h2 id="对于沟通的理解"><a href="#对于沟通的理解" class="headerlink" title="对于沟通的理解"></a>对于沟通的理解</h2><p>互联网时代商业的特点是用户主导、产品为王、体验至上、口碑传播。给企业最大的警钟是：做产品最重要的是客户至上。对于我们tob企业而言，客户又分为</p>
<img src="/Users/zhaoxiaohui/IdeaProjects/zxhBlog/source/_posts/image-20221226151533749.png" alt="image-20221226151533749" style="zoom:50%;" />

<p>非暴力沟通以觉察、能量和意识为精髓，用观察、感受、需要、请求的不断重复来串联诚实表达、关切倾听、自我连接，为企业产品推广、亲子关系改善、个人成长等方面的变革提供了重要动力。我们如果能够带着意识去沟通，往往会事半功倍。</p>
<h2 id="学会去听"><a href="#学会去听" class="headerlink" title="学会去听"></a>学会去听</h2><p>听就是要用同理心去理解对方的核心需要，在管理中就是要知道一个人的目标。用耳朵管理员工的过程是邀请表达、静默倾听、确认状态。邀请表达是不断地用问题进行情感引导，不评判对方；保持静默是抑制内心的冲动，全身心地听对方表达的内容、情绪和意图；确认状态是不断地确认对方的观点，认可对方的情绪。听的三个层次：听事实、听情绪、听意图。</p>
<h2 id="学会去说"><a href="#学会去说" class="headerlink" title="学会去说"></a>学会去说</h2><p>《非暴力沟通》这本书里讲到克里希那穆提的一句话：“不带评论的观察是人类智慧的最高形式”。</p>
<p>学习了如何去说，首先说的基础是听懂对方话的事实、情绪和意图，第二是赢得理解，前提是不要把天聊死，然后要带着尊重和理解的心去表达对方的感受和需要。最终如果我们想要说服别人需要做到这四步：<strong>认真倾听、理解需要、表达核实、叠加请求。</strong></p>
<p>如果能够做到回归观察，就能平和地回到事实本身，把问题简单化，再加上一些提问的技巧不断确认对方的需要，就能解决企业50%的问题。</p>
<h2 id="管理沟通法则"><a href="#管理沟通法则" class="headerlink" title="管理沟通法则"></a><strong>管理沟通法则</strong></h2><p>​        惯性回应模式是人们对自己、他人进行表达的时候的一种语言偏好，表现为四种方式：怼他人、怼自己、听自己、听他人。领导者在做管理沟通之前要知道自己和对方所处的状态是什么、想要什么。还要遵循这三大法则：看见活生生的人，用心去连接；关注感受和需要，支持自己和他人；区分岗位和个人需要，多体会个人需要的意义。此外，如果领导者能够带有同理心地倾听和回应，做出简单明确、当下正向、可以操作的请求对于提高员工的行动力也会有显著的效果。</p>
<h2 id="非暴力沟通亲子实践"><a href="#非暴力沟通亲子实践" class="headerlink" title="非暴力沟通亲子实践"></a><strong>非暴力沟通亲子实践</strong></h2><h2 id="读书思考"><a href="#读书思考" class="headerlink" title="读书思考"></a>读书思考</h2><ol>
<li>本书中讲到的“别人眼中的自己才是真正的自己”和《认知思维》中“我们认为的自己才是真正的自己” 是冲突的；</li>
<li>一个员工做人要诚实、谦卑，做事要学会用规定动作、尽量一次把事情做好、用问话沟通，在工作过程中要学会做工作计划、学会训练、学会做工作流程、学会借力牛人、学会提炼、学会照镜子、学会增值、学会检查、学会理解等，这样才能提升自身价值。</li>
<li>职场第一课：发现问题——》分析问题——》对应的解决方案——》寻求资源——》落实（说到做到）</li>
<li>本书可以使我的思维更具有逻辑性、结构性，使我思考从大学到职场的真正思维模式的转变，值得反复学习；</li>
<li>学会如何写工作总结；</li>
<li></li>
</ol>
<!-- more -->]]></content>
      <categories>
        <category>-书籍</category>
      </categories>
      <tags>
        <tag>-阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>浅学JAVA开发中异常处理</title>
    <url>/2023/03/07/2023-02-22-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<center>优雅处理异常</center>

<span id="more"></span>

<p>异常处理逻辑上的分类：</p>
<p>对于我们并不期望会发生的事，我们可以使用异常捕捉； </p>
<p>对于我们觉得可能会发生的事，使用返回码。</p>
<h2 id="springboot异常处理"><a href="#springboot异常处理" class="headerlink" title="springboot异常处理"></a>springboot异常处理</h2><ol>
<li><h4 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><ol>
<li>SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常 SpringBoot 会向/error 的 url 发送请求。</li>
<li>在 springBoot 中提供了一个叫 BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。</li>
<li>我们也可以重写、error方法，进行特定的返回处理。eg：/error/500,/error/404；</li>
<li>场景：不是前后端分离，返回页面；</li>
</ol>
</li>
<li><p>自己在controller层对指定异常进行try/catch捕获</p>
<ol>
<li><p>```java<br>@RequestMapping(“doCompute/{n1}/{n2}”)</p>
<pre><code>@ResponseBody
public String doCompute(@PathVariable  Integer n1,
                        @PathVariable Integer n2)&#123;
    try&#123;
        Integer result=n1/n2;
        return &quot;Result is &quot;+result;
    &#125;catch(ArithmeticException e)&#123;
        return &quot;exception is &quot;+e.getMessage();
    &#125;
&#125;
</code></pre>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      一个Controller类中通常会有多个方法，这样多个方法中都写<span class="keyword">try</span>语句进行异常处理会带来大量重复代码的编写，不易维护。</span><br><span class="line"></span><br><span class="line">      使用场景：特定的返回结果；</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> #### <span class="meta">@ExceptionHandle</span> 注解处理异常</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> Controller内部定义异常处理方法</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">      <span class="meta">@ResponseBody</span></span><br><span class="line">      <span class="keyword">public</span> String doHandleArithmeticException(ArithmeticException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;计算过程中出现了异常，异常信息为&quot;</span>+e.getMessage();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>@ExceptionHandler注解描述的方法为异常处理方法(注解中的异常类型为可处理的异常类型)，假如Controller类中的逻辑方法中出现异常后没有处理异常，则会查找Controller类中有没有定义异常处理方法，假如定义了，且可以处理抛出的异常类型，则由异常处理方法处理异常。</p>
</li>
<li><p>@ControllerAdvice+@ExceptionHandler 全局处理异常</p>
<ol>
<li>```java<br>@RestControllerAdvice<br>@Slf4j<br>public class ExceptionAdvice {<pre><code>@ExceptionHandler(ArithmeticException.class)
public String doHandleArithmeticException(ArithmeticException e)&#123;
    e.printStackTrace();
    return  &quot;计算过程中出现了异常，异常信息为&quot;+e.getMessage();
&#125;
</code></pre>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="number">2.</span> @RestControllerAdvice 注解描述的类为全局异常处理类，当控制层方法中的异常没有自己捕获,也没有定义其内部的异常处理方法，底层默认会查找全局异常处理类，调用对应的异常处理方法进行异常处理。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> #### 自定义的异常类以及枚举类（优化）</span><br><span class="line"></span><br><span class="line">   上述的示例中，我们对捕获的异常进行简单的二次处理，返回异常的信息，虽然这种能够让我们知道异常的原因，但是在很多的情况下来说，可能还是不够人性化，不符合我们的要求。</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 定义一个错误码ErrorCode <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line">      ```<span class="symbol">java</span></span><br><span class="line">      <span class="symbol">public</span> <span class="symbol">interface</span> <span class="symbol">BaseErrorInfoInterface</span> &#123;</span><br><span class="line">          <span class="comment">/** 错误码*/</span></span><br><span class="line">          <span class="built_in">int</span> getCode();</span><br><span class="line">      </span><br><span class="line">          <span class="comment">/** 错误描述*/</span></span><br><span class="line">          String getMessage();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>实现一个错误码枚举类并实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CommonEnum</span> <span class="keyword">implements</span> <span class="title">BaseErrorInfoInterface</span></span>&#123;</span><br><span class="line">    BODY_NOT_MATCH(<span class="number">400</span>,<span class="string">&quot;请求的数据格式不符!&quot;</span>),</span><br><span class="line">    SIGNATURE_NOT_MATCH(<span class="number">401</span>,<span class="string">&quot;请求错误!&quot;</span>),</span><br><span class="line">    NOT_FOUND(<span class="number">404</span>, <span class="string">&quot;未找到该资源!&quot;</span>),</span><br><span class="line">    INTERNAL_SERVER_ERROR(<span class="number">500</span>, <span class="string">&quot;服务器内部错误!&quot;</span>),</span><br><span class="line">    SERVER_BUSY(<span class="number">503</span>,<span class="string">&quot;服务器正忙，请稍后再试!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**错误码*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    CommonEnum(<span class="keyword">int</span> code, String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后我们在来自定义一个异常类，用于处理我们发生的业务异常和内部异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String errorMsg;</span><br><span class="line">    <span class="comment">//默认无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(BaseErrorInfoInterface errorInfoInterface)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorInfoInterface.getMessage());</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorInfoInterface.getCode();</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorInfoInterface.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(BaseErrorInfoInterface errorInfoInterface, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorInfoInterface.getMessage(), cause);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorInfoInterface.getCode();</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorInfoInterface.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(String errorMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg, cause);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorCode</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 对性能的影响</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BizException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;errorCode=&quot;</span> + errorCode +</span><br><span class="line">                <span class="string">&quot;, errorMsg=&#x27;&quot;</span> + errorMsg + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义全局捕获处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(annotations = Controller.class)</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doHandleArithmeticException</span><span class="params">(ArithmeticException e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历堆栈信息并储存</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element:e.getStackTrace())&#123;</span><br><span class="line">            log.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;计算过程中出现了异常，异常信息为&quot;</span>+e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义的业务异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = BizException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ResultBody <span class="title">bizExceptionHandler</span><span class="params">(HttpServletRequest req, BizException e)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;发生业务异常！原因是：&#123;&#125;&quot;</span>,e.getErrorMsg());</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(e.getErrorCode(),e.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理空指针的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value =NullPointerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBody <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest req, NullPointerException e)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;发生空指针异常！原因是:&quot;</span>,e);</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(CommonEnum.BODY_NOT_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理其他异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(Exception e, HttpServletRequest httpRequest, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;服务器发生异常&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//遍历堆栈信息并储存</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element:e.getStackTrace())&#123;</span><br><span class="line">            log.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line">         String requestHeader = httpRequest.getHeader(<span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (requestHeader.equals(<span class="string">&quot;XMLHttpRequest&quot;</span>))&#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            writer.write(CommunityUtils.getJSONString(<span class="number">1</span>,<span class="string">&quot;服务器异常&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            response.sendRedirect(httpRequest.getContextPath() + <span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务异常输出示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>-09-<span class="number">22</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">24</span>,<span class="number">032</span> ERROR [http-nio-<span class="number">8081</span>-exec-<span class="number">4</span>] t.t.c.c.a.ExceptionAdvice [ExceptionAdvice.java:<span class="number">46</span>] 发生业务异常！原因是：用户姓名不能为空！</span><br><span class="line"><span class="number">2022</span>-09-<span class="number">22</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">24</span>,<span class="number">036</span> WARN [http-nio-<span class="number">8081</span>-exec-<span class="number">4</span>] o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver [AbstractHandlerExceptionResolver.java:<span class="number">208</span>] Resolved [BizException&#123;errorCode=-<span class="number">1</span>, errorMsg=<span class="string">&#x27;用户姓名不能为空！&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="实际开发中遇到的问题和最佳实践"><a href="#实际开发中遇到的问题和最佳实践" class="headerlink" title="实际开发中遇到的问题和最佳实践"></a>实际开发中遇到的问题和最佳实践</h3><p>第一，注意捕获和处理异常的最佳实践。首先，不应该用 AOP  对所有方法进行统一异常处理，异常要么不捕获不处理，要么根据不同的业务逻辑、不同的异常类型进行精细化、针对性处理；其次，处理异常应该杜绝生吞，并确保异常栈信息得到保留；最后，如果需要重新抛出异常的话，请使用具有意义的异常类型和异常消息。</p>
<p> 第二，务必小心 finally 代码块中资源回收逻辑，确保 finally 代码块不出现异常，内部把异常处理完毕，避免 finally  中的异常覆盖 try 中的异常；或者考虑使用 addSuppressed 方法把 finally 中的异常附加到 try  中的异常上，确保主异常信息不丢失。此外，使用实现了 AutoCloseable 接口的资源，务必使用 try-with-resources  模式来使用资源，确保资源可以正确释放，也同时确保异常可以正确处理。 </p>
<p>第三，虽然在统一的地方定义收口所有的业务异常是一个不错的实践，但务必确保异常是每次 new 出来的，而不能使用一个预先定义的 static  字段存放异常，否则可能会引起栈信息的错乱。</p>
<p> 第四，确保正确处理了线程池中任务的异常，如果任务通过 execute  提交，那么出现异常会导致线程退出，大量的异常会导致线程重复创建引起性能问题，我们应该尽可能确保任务不出异常，同时设置默认的未捕获异常处理程序来兜底；如果任务通过 submit 提交意味着我们关心任务的执行结果，应该通过拿到的 Future 调用其 get  方法来获得任务运行结果和可能出现的异常，否则异常可能就被生吞了。</p>
<h4 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a><strong>要注意的问题</strong></h4><ol>
<li>在哪一层进行抛出？应该在哪里抛，抛什么异常。</li>
</ol>
<p>A：比如 我们需要知道 参数为空报什么异常，对其进行捕获统一处理；</p>
<p>2、所有异常被吃掉，带来的严重的后果；</p>
<!-- more -->]]></content>
      <categories>
        <category>-JAVA</category>
      </categories>
      <tags>
        <tag>-JAVA -学习</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树BST</title>
    <url>/2023/03/07/Day3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<center>二叉搜索树</center>

<span id="more"></span>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol>
<li>定义：也是一种动态数据结构 ；</li>
</ol>
<p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210821130645690.png" alt="image-20210821130645690"></p>
<p>一个节点也是二叉树、null也是二叉树</p>
<h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><ul>
<li> 特点：每个节点的值</li>
<li>小于其右子树的所有结点的值；</li>
<li>大于其左子树所有结点的值；</li>
<li>储存的元素必须有可比较性；<del>意思是说不能存放重复数据</del></li>
</ul>
<h3 id="Set-AND-Map-可以理解为一种定义好的数据结构"><a href="#Set-AND-Map-可以理解为一种定义好的数据结构" class="headerlink" title="Set AND Map(可以理解为一种定义好的数据结构)"></a>Set AND Map(可以理解为一种定义好的数据结构)</h3><h4 id="Set–集合：不能有重复元素"><a href="#Set–集合：不能有重复元素" class="headerlink" title="Set–集合：不能有重复元素"></a>Set–集合：不能有重复元素</h4><p>因为二分搜索树不能存放重复元素，所以是非常好的实现“集合”的底层数据结构；</p>
<h4 id="二分搜索树的遍历"><a href="#二分搜索树的遍历" class="headerlink" title="二分搜索树的遍历"></a>二分搜索树的遍历</h4><p>都是从根结点出发，最后回到根结点</p>
<ol>
<li><p>前序遍历</p>
</li>
<li><p>```java<br> System.out.println(node.)<br> traverse(node.right);<br> traverse(node.left);</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 中序遍历</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    traverse(node.<span class="attribute">left</span>);</span><br><span class="line">    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(node.)</span><br><span class="line">    traverse(node.<span class="attribute">right</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>（得到的结果是从小到大排列的）</li>
</ul>
<ol start="4">
<li>后续遍历（eg:为二分搜索树释放内存）</li>
</ol>
<ul>
<li><pre><code class="java">traverse(node.right);
traverse(node.left);
System.out.println(node.)
</code></pre>
</li>
</ul>
<h4 id="二分搜索树BST的顺序性特性："><a href="#二分搜索树BST的顺序性特性：" class="headerlink" title="二分搜索树BST的顺序性特性："></a>二分搜索树BST的顺序性特性：</h4><ul>
<li>求最大值和最小值</li>
<li>求floor和ceil</li>
<li>求Rank和select（维护SIZE）</li>
<li>改进后支持重复元素（进入左子树或者加一个COUNT）</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>树结构</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>错误日志</title>
    <url>/2021/12/13/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<center>记错（已解决问题）</center>

<span id="more"></span>



<ul>
<li><p>java: javacTask: 源发行版 8 需要目标发行版 1.8、</p>
<ul>
<li><p>1，Project Structure 里确认两个地方：Project sdk 以及 project language level</p>
<p>2，Project Structure-&gt;Modules 里 Sources 里的 Language level</p>
<p>3，settings-&gt;java Compiler -&gt;target bytecode Version</p>
<p>这些个地方需要一致。</p>
</li>
</ul>
</li>
<li><p><a href="https://segmentfault.com/q/1010000012008825">spring boot application.yml文件不生效</a></p>
<ul>
<li>端口号不生效： 配置文件严格·缩进·</li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/weixin_50707679/article/details/116609127">Maven 打包报错：jar:1.0-SNAPSHOT is missing</a></p>
<ul>
<li>后来突发奇想，把 maven.compiler.source 和 maven.compiler.target 标签给删了，然后就好了，相当于不人为指定了。也是给大家提供一个思路吧</li>
</ul>
</li>
<li><p>Nacos startup 无反应，启动报错的解决办法</p>
<ul>
<li><p>​    原因是 2.0.3 版本默认是以集群的模式去运行的，而我们本地并没有相关配置，我们只需要用单机模式去运行即可。</p>
<p>​    解决办法很简单，我们只需要修改一下 <strong>startup.cmd</strong> 里的代码配置即可。</p>
<p>右键 <strong>startup.cmd</strong> 选择编辑，反正能用编辑器打开就行。</p>
<p>​    可以看到默认的配置是 <code>set MODE=&quot;cluster&quot;</code></p>
<p>我们将其改成 <code>set MODE=&quot;standalone&quot;</code> 即可。</p>
<p>修改后保存，重新运行再看一下。</p>
</li>
</ul>
</li>
<li><p>nacos无法读取bootstrap.yml文件 </p>
<ul>
<li><p> 报错create config service error!properties=NacosConfigProperties{serverAddr=’null’,</p>
</li>
<li><p>添加依赖</p>
</li>
<li><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
<li></li>
</ul>
<!--more-->]]></content>
      <categories>
        <category>-错误 -bug</category>
      </categories>
      <tags>
        <tag>-bug</tag>
      </tags>
  </entry>
  <entry>
    <title>关于健身.....</title>
    <url>/2021/11/15/20211115-%E5%85%B3%E4%BA%8E%E5%81%A5%E8%BA%AB/</url>
    <content><![CDATA[<center>《论每天健身的重要性》And《学习健身笔记》持续ing</center>

<span id="more"></span>



<h3 id="学习笔记（不一定对，欢迎讨论）"><a href="#学习笔记（不一定对，欢迎讨论）" class="headerlink" title="学习笔记（不一定对，欢迎讨论）"></a>学习笔记<em>（不一定对，欢迎讨论）</em></h3><h3 id="早晨"><a href="#早晨" class="headerlink" title="早晨"></a>早晨</h3><h4 id="面部-去水肿"><a href="#面部-去水肿" class="headerlink" title="面部    去水肿"></a>面部    去水肿</h4><ul>
<li>仰头–然后歪头 感受<strong>颈阔肌拉伸</strong> <em>左右各三四十秒</em></li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211115192308015.png" alt="image-20211115192308015" style="zoom: 33%;" /></li>
</ul>
<h4 id="养气血健脾胃"><a href="#养气血健脾胃" class="headerlink" title="养气血健脾胃"></a>养气血健脾胃</h4><ol>
<li><strong>坚持每天早上运动30分钟</strong></li>
<li>练中气：深吸一口气，然后发出**si~**的音 每次坚持20s</li>
</ol>
<h4 id="打哈欠、叹气、犯困、头晕眼花"><a href="#打哈欠、叹气、犯困、头晕眼花" class="headerlink" title="打哈欠、叹气、犯困、头晕眼花"></a>打哈欠、叹气、犯困、头晕眼花</h4><h4 id="头颈-前伸："><a href="#头颈-前伸：" class="headerlink" title="头颈    前伸："></a>头颈    前伸：</h4><p>正常生理结构上，人体脊柱颈椎段是有先前的曲度的。但是由于不良习惯，颈椎曲度会变直甚至反张。长期头颈前伸会引起身体前侧一些肌肉和筋膜的挛缩，会让面部结构出现下垂。</p>
<ol>
<li>关节松动</li>
<li>软组织松解<ol>
<li>胸锁乳突肌</li>
<li>斜角肌</li>
<li>上斜方肌</li>
<li>风池穴</li>
</ol>
</li>
<li>稳定训练<ol>
<li>躺下 –&gt;歪头–&gt;抬头（感受胸锁乳突肌拉伸、肩膀必须放松）</li>
</ol>
</li>
</ol>
<p>日常的姿势再训练：</p>
<ol>
<li>动作①：挺胸廓。挺起胸廓，保持一分钟左右，慢慢放松，做3—4组。<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211115195422291.png" alt="image-20211115195422291" style="zoom: 25%;" /></li>
<li>动作②：拉伸颈前侧。闭紧牙齿闭拢嘴巴，把下颌往上提，保持30—40秒，做3—4组。感到脖子前侧有牵拉感。与仰头区分开，注意把下巴往上提。</li>
<li>动作③：头悬气球。想象头上有个气球拎着你拎着你拎着你拎着你～就这样拎着。寻找脑袋往上延伸，身体挺拔的感觉，日常保持此状态。</li>
</ol>
<p>脖子酸痛  给亲人做胸锁乳突肌 放松  （ 注意   轻力度！！！）</p>
<h4 id="肩部"><a href="#肩部" class="headerlink" title="肩部"></a>肩部</h4><ol>
<li><h5 id="解决圆肩驼背问题（15min54）"><a href="#解决圆肩驼背问题（15min54）" class="headerlink" title="解决圆肩驼背问题（15min54）"></a>解决圆肩驼背问题（15min54）</h5><ol>
<li>活动肩关节（12次）</li>
<li>放松胸大肌（40秒/4组）</li>
<li>放松胸小肌（30秒/每边/2组）</li>
<li>眼镜蛇拉伸（40s/2组）</li>
<li>大范围绕肩（前后各30秒）</li>
<li>开肩吸气（60秒/3组）</li>
</ol>
</li>
</ol>
<h4 id="小腿"><a href="#小腿" class="headerlink" title="小腿"></a>小腿</h4><ol>
<li>解决各种小腿问题</li>
<li></li>
</ol>
<h4 id="正确的坐姿"><a href="#正确的坐姿" class="headerlink" title="正确的坐姿"></a>正确的坐姿</h4><ol>
<li>坐骨（屁股）位置高于膝盖（没有往后靠的感觉为止）</li>
<li>头悬空的感觉，前后发力平衡</li>
<li>每隔一段时间动一动（1hour）</li>
<li>靠背椅，往后坐</li>
<li>视线尽力看平</li>
</ol>
<h4 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h4><p>深蹲不粗腿又能促睾翘臀BV1DS4y1M7iG</p>
<h4 id="正确睡姿："><a href="#正确睡姿：" class="headerlink" title="正确睡姿："></a>正确睡姿：</h4><p>BV12h411C7dw</p>
<p>一：好的睡眠是全身放松的。<br>二：哪里痛不是睡姿不对，而是哪里该放松松解了。<br>三：睡前操分享。<br>1.猫式伸展。（30秒）<br>2.坐姿位拉伸大腿。（每条腿40秒）<br>3.仰卧旋转拉伸。（每边40秒）（涉及到骨盆旋转）</p>
<h4 id="骨盆旋转"><a href="#骨盆旋转" class="headerlink" title="骨盆旋转"></a>骨盆旋转</h4><p>BV1Cf4y1S7a2</p>
<h4 id="你不是懒-是气血不足-易累人群4步养气血"><a href="#你不是懒-是气血不足-易累人群4步养气血" class="headerlink" title="你不是懒 是气血不足  |  易累人群4步养气血"></a>你不是懒 是气血不足  |  易累人群4步养气血</h4><ol>
<li>气血不足是什么？<ul>
<li>黑眼圈，疲劳，失眠，乏力……</li>
</ul>
</li>
<li>养气血先健脾胃</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20220115174223481.png" alt="image-20220115174223481"  /><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20220115174131202.png" style="zoom:80%;" /></li>
<li>吃——原则：按时吃饭，应季食物。<br>1.淮山玉米芡实排骨汤<br>2.陈皮泡水<br>3.四君子汤</li>
<li>按摩：早晚顺逆81下揉腹  </li>
<li><strong>坚持每天早上运动30分钟</strong></li>
<li>练中气：深吸一口气，然后发出**si~**的音 每次坚持20s</li>
</ol>
<p>补气：西洋参</p>
<p> 社交：减少内耗和对负性情绪的接触。</p>
<h3 id="分享一些感受："><a href="#分享一些感受：" class="headerlink" title="分享一些感受："></a>分享一些感受：</h3><ol>
<li>等待没有必要，约到年纪大越难矫正</li>
<li>不要做着林黛玉的训练量，操着变成阿诺的心（hhhh）</li>
<li></li>
</ol>
<h3 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h3><ol>
<li>记号笔用酒精一擦就掉；</li>
<li>维持挺胸，需要深层肌肉稳定</li>
<li>健身大佬 김종국 GYM JONG KOOK<a href="https://www.youtube.com/channel/UCoe-0EVDJnjlSoPK8ygcGwQ">https://www.youtube.com/channel/UCoe-0EVDJnjlSoPK8ygcGwQ</a></li>
<li></li>
</ol>
<!--more-->

]]></content>
      <categories>
        <category>-日常 -生活</category>
      </categories>
      <tags>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次服务器搭建MySQL</title>
    <url>/2021/11/12/20211112-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAMySQL/</url>
    <content><![CDATA[<center> 技术坑:Linux  centos7 mysql navicate docker</center>

<span id="more"></span>

<p><a href="https://www.cnblogs.com/763977251-sg/p/11837130.html">Centos7 系统安装 docker，并配置阿里云镜像加速器</a></p>
<ol>
<li><p>先在服务器上安装一个docker 根据官方文档</p>
<p>​    docker pull MySQL:8.0</p>
</li>
<li><p>whereis mysql 查看安装位置</p>
</li>
<li><p>通过下面命令创建一个镜像</p>
<ol>
<li>```dockerfile<br> docker run -p 3306:3306 –name zxhmysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib64/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0</li>
</ol>
</li>
<li><p>docker ps -a查看是否启动成功</p>
<ul>
<li>这里有个坑 ，网上 旧版lib后面没有64  新版要添加</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211112152206575.png" alt="image-20211112152206575"></li>
</ul>
</li>
<li><p>启动成功  改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mydata/mysql/conf</span><br><span class="line">vi my.cnf</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件参考</p>
<ol>
<li>```<br>[mysqld]<br>####: for global<br>user =mysql<br>federated<br>basedir =/usr/local/mysql<br>datadir =/data/mysql/data<br>server_id = 1250<br>port =3306<br>mysqlx_port = 33070<br>character_set_server =utf8mb4<br>collation_server=utf8mb4_bin<br>log_timestamps =system<br>default_time_zone =’+8:00’<br>socket =/data/mysql/mysql.sock<br>read_only = 0<br>super_read_only = 0<br>skip_name_resolve =on<br>lower_case_table_names =1<br>#secure_file_priv =/data/mysql/data<br>open_files_limit =65536<br>max_connections =2000<br>thread_cache_size =256<br>table_open_cache =4096 # 2000<br>table_definition_cache =4096<br>table_open_cache_instances =64<br>wait_timeout =28800<br>interactive_timeout =28800<br>event_scheduler = 1<br>max_allowed_packet =1024M<br>init_connect =’SET AUTOCOMMIT=1’<br>transaction_isolation =READ-COMMITTED<br>lock_wait_timeout=3600<br>default_authentication_plugin=mysql_native_password###: cache<br>key_buffer_size = 64M<br>sort_buffer_size  = 4M<br>join_buffer_size  = 4M####: for binlog<br>binlog_format =row<br>log_bin =/data/mysql/logs/mysql-bin<br>binlog_rows_query_log_events =off<br>log_slave_updates =on<br>#expire_logs_days =7<br>binlog_expire_logs_seconds=604800<br>binlog_cache_size =1G<br>max_binlog_size =1G<br>binlog_checksum =none<br>sync_binlog =1<br>slave-preserve-commit-order =ON<br>log_bin_trust_function_creators=on  ####:for error-log<br>log_error =/data/mysql/logs/mysql.err<br>general_log =off<br>general_log_file =/data/mysql/logs/general.log####: for slow query log<br>slow_query_log =on<br>slow_query_log_file =/data/mysql/logs/slowquery.log<br>long_query_time =1.000000<br>log_queries_not_using_indexes =0####: for gtid<br>#gtid_executed_compression_period =1000<br>gtid_mode =on<br>enforce_gtid_consistency =on####: for replication<br>relay-log-index = /data/mysql/logs/relay-bin.index<br>relay-log-info-file = /data/mysql/logs/relay-log.info<br>relay-log = /data/mysql/logs/relay-bin<br>log-slave-updates =1<br>skip_slave_start =1<br>master_info_repository =table<br>relay_log_info_repository =table<br>slave_parallel_type =logical_clock<br>slave_parallel_workers =2####: for performance_schema<br>performance_schema = 1<br>performance_schema_instrument = ‘%memory%=on’<br>performance_schema_instrument = ‘%lock%=on’<br>performance_schema_digests_size =100000####: for innodb<br>innodb_data_file_path =ibdata1:1024M:autoextend<br>innodb_temp_data_file_path =ibtmp1:12M:autoextend<br>innodb_buffer_pool_filename =ib_buffer_pool # ib_buffer_pool<br>innodb_log_files_in_group =3<br>innodb_log_file_size =256M # 50331648(48M)<br>innodb_max_undo_log_size =256M<br>innodb_undo_log_truncate =1<br>innodb_undo_tablespaces =2<br>innodb_file_per_table =on<br>innodb_open_files =65535<br>innodb_thread_concurrency =0 # 0<br>innodb_read_io_threads =2<br>innodb_write_io_threads =2<br>innodb_purge_threads =1<br>innodb_page_cleaners =1<br>innodb_print_all_deadlocks =off<br>innodb_lock_wait_timeout =20<br>innodb_autoinc_lock_mode =2<br>innodb_io_capacity =500<br>innodb_io_capacity_max =1000#########################<br>innodb_flush_method =O_DIRECT<br>innodb_log_buffer_size =128M<br>innodb_flush_log_at_trx_commit =1<br>innodb_buffer_pool_size = 128M<br>innodb_buffer_pool_instances = 2<br>#innodb_numa_interleave=on<br>#####################################<br>#######################<br>[client]<br>socket=/data/mysql/mysql.sock<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">7.</span> docker <span class="keyword">restart</span> 容器ID</span><br><span class="line"></span><br><span class="line">   测试连接 </span><br><span class="line"></span><br><span class="line">#### MySQL允许远程连接</span><br><span class="line"></span><br><span class="line">项目中需要连接虚拟机上面的 MySQL 数据库，但是总是出错，怀疑本机是否有连接远程数据库的权限。</span><br><span class="line"></span><br><span class="line">执行命令：</span><br><span class="line"></span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; <span class="keyword">select</span> host,<span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>查看结果是不是 root 用户仅允许本地（localhost）登录，下面这个截图就是这种情况：</p>
<p><img src="http://hoxis-github-io.qiniudn.com/151212-mysql-root-state.png" alt="mysql-root-state"></p>
<p>mysql-root-state</p>
<p>是的话，就要修改它的 host 为 <code>%</code>，表示任意 IP 地址都可以登录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> update <span class="keyword">user</span> <span class="keyword">set</span> host <span class="operator">=</span> <span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行完后可能提示 error。再 <code>mysql&gt; select host,user from user;</code> 查看下吧。</p>
<p>root 对应的 host 成了 <code>%</code>，表示可以任意 IP 地址登录了。</p>
<p><img src="http://hoxis-github-io.qiniudn.com/151212-mysql-change-root-state.png" alt="mysql-change-root-state"></p>
<p>mysql-change-root-state</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>

<p>把缓存 flush 掉，在使用 update 语句修改用户记录后，需要 FLUSH 语句告诉服务器重载授权表。</p>
<h4 id="记录一些遇到的bug"><a href="#记录一些遇到的bug" class="headerlink" title="记录一些遇到的bug"></a>记录一些遇到的bug</h4><ol>
<li>1130 - Host ‘118.114.228.223’ is not allowed to connect to this MySQL server</li>
<li><a href="https://blog.csdn.net/qq_45675449/article/details/106866700">MySQL 报错：ERROR 1396 (HY000): Operation ALTER USER failed for root@localhost</a></li>
<li><a href="https://www.cnblogs.com/adao21/p/9246569.html">MySQL 登录时出现 Access denied for user ‘root‘@‘localhost‘ (using password: YES) 无法打开的解决方法</a></li>
<li>❗<a href="https://blog.csdn.net/attackkk/article/details/104954941">docker 下 mysql 的密码设置</a></li>
<li>[ERROR] [MY-010095] [Server] Failed to access directory for –secure-file-priv. Please make sure that directory exists and is accessible by MySQL Server. Supplied value : /var/lib/mysql-files</li>
<li><a href="https://blog.csdn.net/zhaogot/article/details/113694332">docker 实战之挂载方式部署 MySQL8  （公司实战）</a></li>
</ol>
<h4 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h4><!--more-->

]]></content>
      <categories>
        <category>-mysql -docker -linux</category>
      </categories>
      <tags>
        <tag>-实战 -mysql -docker -linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git复习</title>
    <url>/2021/10/27/20211027-Git%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<center>系统的整理一下Git</center>

<span id="more"></span>

<h3 id="git的诞生"><a href="#git的诞生" class="headerlink" title="git的诞生"></a>git的诞生</h3><ul>
<li>Linux之父linus 想开源使用代码仓库，又觉得当时的其他的不好用，种种原因下 自己花费15天 用C语言写了Git</li>
<li>推荐读书《just for fun》linus的自传 ，很有意思</li>
</ul>
<h3 id="GIT诞生之前有个SVN"><a href="#GIT诞生之前有个SVN" class="headerlink" title="GIT诞生之前有个SVN"></a>GIT诞生之前有个SVN</h3><p>SVN:</p>
<ul>
<li>SVN 是一种集中式的版本控制工具。</li>
<li>所有的客户端将自己的代码上传到中央服务器，中央服务器的版本数据库会保存上传的各个版本的代码，并进行统一管理。</li>
<li> 这里注意，客户端本身是不存在版本数据库的，所以，如果中央服务器离线或宕机，则集中式版本控制则无法使用。SVN 是一个增量式的版本控制，它不会将整的保存下来，而只会记录下版本之间的差异，然后按照顺序更新或者恢复特定版本的数据。. 这使得服务端的存储量会非常低。</li>
</ul>
<p>git：</p>
<ul>
<li>GIT是一个分布式的版本控制工具</li>
<li>每个人的PC都可以有一个版本库；有很好的容灾性；</li>
</ul>
<h3 id="先安装一个Windows版"><a href="#先安装一个Windows版" class="headerlink" title="先安装一个Windows版"></a>先安装一个Windows版</h3><p>按照官网安装即可</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用户名+邮箱（最好跟gitee上一样）</p>
<p>git config –global user.name “自己的用户名”</p>
<p>git config –global user.email “自己的邮箱” </p>
<p>最终在C:\Users\ZXH082600\.gitconfig生成一个配置文件</p>
<h2 id="本地基操"><a href="#本地基操" class="headerlink" title="本地基操"></a>本地基操</h2><h3 id="初始化（创建版本库）"><a href="#初始化（创建版本库）" class="headerlink" title="初始化（创建版本库）"></a>初始化（创建版本库）</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>在当前文件夹下创建一个git仓库</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027202830969.png" alt="image-20211027202830969" style="zoom:80%;" />



<p>在创建一个文件 a.txt</p>
<p>ls -l 显示total 0   此时只是新建了一个文件，和git并没有关系</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027204330960.png" alt="image-20211027204330960" style="zoom:80%;" />

<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><ol>
<li><h4 id="git-status-查看文件状态"><a href="#git-status-查看文件状态" class="headerlink" title="git status 查看文件状态"></a>git status 查看文件状态</h4></li>
<li><p>git add  <file>  将文件添加到 暂存区（生成index索引文件）</p>
<ul>
<li>如果报错<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027210523876.png" alt="image-20211027210523876"></li>
<li>解决办法git config –global core.autocrlf false </li>
</ul>
</li>
<li><p>git commit -m “注释” a.txt   (每次commit都必须写清楚注释)<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027205215099.png" alt="image-20211027205215099"></p>
</li>
</ol>
<h3 id="查看文件提交记录"><a href="#查看文件提交记录" class="headerlink" title="查看文件提交记录"></a>查看文件提交记录</h3><p>git log a.txt </p>
<p>git log –pretty=oneline a.txt</p>
<img src="C:/Users/ZXH082600/AppData/Roaming/Typora/typora-user-images/image-20211027211605054.png" alt="image-20211027211605054" style="zoom:80%;" />

<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>git reset –hard HEAD^ </p>
<p>git reset –hard HEAD^ ^^^   （^代表退几步）</p>
<h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><p>git reflog a.txt 查看历史记录的版本号（很详细）</p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028100945522.png" alt="image-20211028100945522"></p>
<p>git reset –hard ee58290 （指针指向版本号）</p>
<p>git reset –hard HEAD~4(回退四步)</p>
<h3 id="撤销修改内容（已修改未add的）"><a href="#撤销修改内容（已修改未add的）" class="headerlink" title="撤销修改内容（已修改未add的）"></a>撤销修改内容（已修改未add的）</h3><p>git checkout – a.txt</p>
<h3 id="删除某个git文件"><a href="#删除某个git文件" class="headerlink" title="删除某个git文件"></a>删除某个git文件</h3><ol>
<li> git rm c.txt</li>
<li>git commit -m “del c.txt”</li>
</ol>
<h2 id="谈谈git的三个库（工-暂-本）"><a href="#谈谈git的三个库（工-暂-本）" class="headerlink" title="谈谈git的三个库（工 暂 本）"></a>谈谈git的三个库（工 暂 本）</h2><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028104132867.png" alt="image-20211028104132867"></p>
<h2 id="Gits实操之分支"><a href="#Gits实操之分支" class="headerlink" title="Gits实操之分支"></a>Gits实操之分支</h2><ul>
<li>创建分支<ul>
<li>git branch查看分支</li>
<li>git branch 分支名</li>
</ul>
</li>
<li>切换分支<ul>
<li>git checkout 分支名</li>
<li>git checkout -b 分支名（创建并切换，如果已存在会报错）</li>
</ul>
</li>
<li>合并分支<ul>
<li>先切换到主分支 git checkout master</li>
<li>git merge 目标分支名</li>
</ul>
</li>
<li>删除分支<ul>
<li>先切换到主分支 git checkout master</li>
<li>git branch -d 分支名</li>
</ul>
</li>
</ul>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><ul>
<li>冲突一般是指同一个文件同一位置的代码，在两个版本合并时版本管理软件无法判断该保留哪一个版本，因此会提示该文件发生冲突；</li>
</ul>
<h3 id="分支覆盖冲突"><a href="#分支覆盖冲突" class="headerlink" title="分支覆盖冲突"></a>分支覆盖冲突</h3><ul>
<li><p>合并时冲突</p>
<ul>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028110717436.png" alt="image-20211028110717436"></li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028112659780.png" alt="image-20211028112659780"></li>
</ul>
</li>
<li><p>解决</p>
<p>​    不可以将其他开发人员的代码 覆盖或者删除；（同步，全部保留；）</p>
<ul>
<li>git diff //可以找到发生冲突的文件和内容</li>
<li>然后修改冲突文件的内容，再次git add 文件 和git commit (无文件名)提交后，后缀merging消失，说明冲突解决</li>
</ul>
</li>
</ul>
<h3 id="远程服务器冲突"><a href="#远程服务器冲突" class="headerlink" title="远程服务器冲突"></a>远程服务器冲突</h3><ul>
<li>版本不一致 先pull一个最新版本的，diff 冲突文件中的冲突需要手动处理，再重新add/commit/push</li>
</ul>
<h3 id="idea拉取提交冲突"><a href="#idea拉取提交冲突" class="headerlink" title="idea拉取提交冲突"></a>idea拉取提交冲突</h3><h2 id="Gitee云上实操"><a href="#Gitee云上实操" class="headerlink" title="Gitee云上实操"></a>Gitee云上实操</h2><ul>
<li>创建ssh key<ul>
<li>ssh-keygen -t rsa -C 你自己用户邮箱</li>
<li>成功的话会生成.ssh文件夹</li>
</ul>
</li>
<li>打开pub文件。复制全部，复制到gitee公钥</li>
<li>连通性测试 <ul>
<li>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#x63;&#111;&#109;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#x63;&#111;&#109;</a></li>
</ul>
</li>
</ul>
<ol>
<li>先在本地初始化创建一个git库  git init</li>
<li>在gitee中创建一个同名空仓库</li>
<li>本地操作提示，git remote与远程建立连接<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028153432245.png" alt="image-20211028153432245"></li>
<li>从服务器拉最新的<ul>
<li>git pull origin master</li>
</ul>
</li>
<li>新员工入职从远程拉项目<ul>
<li>git clone origin https:xxxxxx.git</li>
<li>然后切换到工作目录，开始操作</li>
</ul>
</li>
</ol>
<h4 id="新员工入职，如何配合工作-取得代码"><a href="#新员工入职，如何配合工作-取得代码" class="headerlink" title="新员工入职，如何配合工作+取得代码"></a>新员工入职，如何配合工作+取得代码</h4><p>git一般工作流程</p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211028161839922.png" alt="image-20211028161839922"></p>
<h5 id="重点：git-fetch-origin-master查看是否版本冲突"><a href="#重点：git-fetch-origin-master查看是否版本冲突" class="headerlink" title="重点：git fetch origin master查看是否版本冲突"></a>重点：git fetch origin master查看是否版本冲突</h5><ol>
<li>up to date 版本一致，证明没人改过</li>
<li>ahead of 你的比服务端新，可以提交</li>
<li>behind 服务器有更改，<strong>不能直接push  必须先pull 最新的，然后把自己的代码加上再重新fetch</strong></li>
<li>pull之后自己手动处理冲突然后再提交</li>
</ol>
<h3 id="邀请成员协同开发（被动等待邀请）"><a href="#邀请成员协同开发（被动等待邀请）" class="headerlink" title="邀请成员协同开发（被动等待邀请）"></a>邀请成员协同开发（被动等待邀请）</h3><p>要点击确认</p>
<h3 id="跨团队协作fork（主动fork）"><a href="#跨团队协作fork（主动fork）" class="headerlink" title="跨团队协作fork（主动fork）"></a>跨团队协作fork（主动fork）</h3><p>请求外部专家帮助解决bug</p>
<ol>
<li>找到那个项目，点fork</li>
<li>git clone /add/push等</li>
<li>新建pull requests</li>
<li>主项目端会收到审查和测试</li>
<li>点文件查看diff</li>
<li>合并分支</li>
</ol>
<h3 id="仓库删除"><a href="#仓库删除" class="headerlink" title="仓库删除"></a>仓库删除</h3><p>点击管理–&gt;删除项目—&gt;验证信息</p>
<h2 id="IDEA整合"><a href="#IDEA整合" class="headerlink" title="IDEA整合"></a>IDEA整合</h2><h3 id="Git配置忽略文件"><a href="#Git配置忽略文件" class="headerlink" title="Git配置忽略文件"></a>Git配置忽略文件</h3><ol>
<li>自己的用户目录下创建 git.ignore<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029111113274.png" alt="image-20211029111113274"></li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029111543371.png" alt="image-20211029111543371"></li>
<li>规则<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029112355363.png" alt="image-20211029112355363" style="zoom:80%;" /></li>
<li>设置找到git 配置</li>
<li>安装gitee插件</li>
<li>版本控制中有个gitee<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029113034406.png" alt="image-20211029113034406"></li>
<li>创建一个普通maven项目</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029113647439.png" alt="image-20211029113647439"></li>
<li>add /commit<ul>
<li>这里有个报错，跨平台问题；解决办法（<a href="https://blog.csdn.net/iamlihongwei/article/details/107518398%EF%BC%89![image-20211029115025959](https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115025959.png)">https://blog.csdn.net/iamlihongwei/article/details/107518398）![image-20211029115025959](https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115025959.png)</a></li>
</ul>
</li>
<li> 同步到云端，右击git，点share<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115150251.png" alt="image-20211029115150251" style="zoom:50%;" /></li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211029115909354.png" alt="image-20211029115909354"></li>
</ol>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1362941">参考TX Git Code Review 设置与使用</a></li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>-Git -面试 -JAVA基础</category>
      </categories>
      <tags>
        <tag>-Git</tag>
      </tags>
  </entry>
  <entry>
    <title>继续学习JUC</title>
    <url>/2021/10/27/20211027-%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0JUC/</url>
    <content><![CDATA[<center>不断学习，不断总结，今天的你比昨天更强。</center>

<span id="more"></span>

<h3 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h3><ul>
<li>从start一个线程说起<ul>
<li>java 线程是通过 start 的方法启动执行的，主要内容在 native 方法 start0 中，Openjdk 的写 JNI 一般是一一对应的，Thread.java 对应的就是 Thread.cstart0 其实就是 JVM_StartThread。此时查看源代码可以看到在 jvm.h 中找到了声明，jvm.cpp 中有实现。</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211027154450090.png" alt="image-20211027154450090"></li>
<li>Java线程分为用户线程和守护线程，<br>线程的daemon属性为<strong>true</strong>表示是守护线程，<strong>false</strong>表示是用户线程；eg：main用户线程+GC守护线程；</li>
</ul>
</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>-JUC -JAVA</category>
      </categories>
      <tags>
        <tag>-JUC -Java</tag>
      </tags>
  </entry>
  <entry>
    <title>说说双重检查加锁单例模式为什么两次判断？</title>
    <url>/2021/10/21/20211021-%E8%AF%B4%E8%AF%B4%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E5%8A%A0%E9%94%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E5%88%A4%E6%96%AD%EF%BC%9F/</url>
    <content><![CDATA[<center>  今天面试被问到这道题没说出来，复盘一下</center>

<span id="more"></span>

<p>先上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次校验singleton是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//第二次校验singleton是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : &quot;</span>+Singleton.getInstance().hashCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么是双重校验锁实现单例模式呢？"><a href="#为什么是双重校验锁实现单例模式呢？" class="headerlink" title="为什么是双重校验锁实现单例模式呢？"></a>为什么是双重校验锁实现单例模式呢？</h3><ol>
<li><p><strong>第一次校验：</strong> 也就是第一个 if（singleton==null），由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用 getInstance 方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。</p>
</li>
<li><p>第二次校验：第个校验是防止二次创建实例，假如有一种情况，当 singleton 还未被创建时，线程 t1 调用 getInstance 方法，由于第一次判断 singleton==null，此时线程 t1 准备继续执行，但是由于资源被线程 t2 抢占了，此时 t2 页调用 getInstance 方法。</p>
<p>​            同样的，由于 singleton 并没有实例化，t2 同样可以通过第一个 if，然后继续往下执行，同步代码块，第二个 if 也通过，然后 t2 线程创建了一个实例 singleton。</p>
<p>​            此时 t2 线程完成任务，资源又回到 t1 线程，t1 此时也进入同步代码块，如果没有这个第二个 if，那么，t1 就也会创建一个 singleton 实例，那么，就会出现创建多个实例的情况，但是加上第二个 if，就可以完全避免这个多线程导致多次创建实例的问题。</p>
</li>
</ol>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul>
<li>感觉面试还是紧张了，稍微想一下其实就明白了；</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>-面试 -JAVA</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 常见的几种JVM内存溢出及解决方法</title>
    <url>/2021/10/20/Java%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<center>Java 常见的几种JVM内存溢出及解决方法</center>

<span id="more"></span>



<p><strong>【情况一】：</strong><br>java.lang.OutOfMemoryError:Javaheapspace：这种是 java 堆内存不够，一个原因是真不够（如递归的层数太多等），另一个原因是程序中有死循环；<br>如果是 java 堆内存不够的话，可以通过调整 JVM 下面的配置来解决：<br>-Xms3072m<br>-Xmx3072m<br><strong>【情况二】：</strong><br>java.lang.OutOfMemoryError:GCoverheadlimitexceeded<br>【解释】：JDK6 新增错误类型，当 GC 为释放很小空间占用大量时间时抛出；一般是因为堆太小，导致异常的原因，没有足够的内存。<br>【解决方案】：<br>1、查看系统是否有使用大内存的代码或死循环；<br>2、通过添加 JVM 配置，来限制使用内存：<br>-XX:-UseGCOverheadLimit<br><strong>【情况三】：</strong><br>java.lang.OutOfMemoryError:PermGenspace：这种是 P 区内存不够，可通过调整 JVM 的配置：<br>-XX:MaxPermSize=128m<br>-XXermSize=128m<br>【注】：<br>JVM 的 Perm 区主要用于存放 Class 和 Meta 信息的，Class 在被 Loader 时就会被放到 PermGenspace，这个区域成为年老代，GC 在主程序运行期间不会对年老区进行清理，默认是 64M 大小，当程序需要加载的对象比较多时，超过 64M 就会报这部分内存溢出了，需要加大内存分配，一般 128m 足够。<br><strong>【情况四】：</strong><br>java.lang.OutOfMemoryError:Directbuffermemory<br>调整 - XX:MaxDirectMemorySize = 参数，如添加 JVM 配置：<br>-XX:MaxDirectMemorySize=128m<br>【情况五】：<br>java.lang.OutOfMemoryError:unabletocreatenewnativethread<br>【原因】：Stack 空间不足以创建额外的线程，要么是创建的线程过多，要么是 Stack 空间确实小了。<br>【解决】：由于 JVM 没有提供参数设置总的 stack 空间大小，但可以设置单个线程栈的大小；而系统的用户空间一共是 3G，除了 Text/Data/BSS/MemoryMapping 几个段之外，Heap 和 Stack 空间的总量有限，是此消彼长的。因此遇到这个错误，可以通过两个途径解决：1. 通过 - Xss 启动参数减少单个线程栈大小，这样便能开更多线程（当然不能太小，太小会出现 StackOverflowError）；2. 通过 - Xms-Xmx 两参数减少 Heap 大小，将内存让给 Stack（前提是保证 Heap 空间够用）。<br><strong>【情况六】：</strong><br>java.lang.StackOverflowError<br>【原因】：这也内存溢出错误的一种，即线程栈的溢出，要么是方法调用层次过多（比如存在无限递归调用），要么是线程栈太小。<br>【解决】：优化程序设计，减少方法调用层次；调整 - Xss 参数增加线程栈大小。</p>
<!--more-->]]></content>
      <categories>
        <category>-JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>图的搜索方式</title>
    <url>/2021/10/10/20211010-%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<center>二叉树是一种特殊的图</center>

<span id="more"></span>

<p>二叉树的遍历方式</p>
<ul>
<li><p>深度优先（FILO栈）</p>
<ul>
<li>前序遍历（根左右）：访问根结点，再访问左子树、再访问右子树。</li>
<li>中序遍历（左根右）：先访问左子树，再访问根结点、再访问右子树。</li>
<li>后续遍历（左右根）：先访问左子树，再访问右子树，再访问根结点。</li>
</ul>
</li>
<li><p>广度优先（FIFO队列）</p>
<ul>
<li>层序遍历</li>
</ul>
</li>
</ul>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul>
<li><p><a href="https://blog.csdn.net/tjh625/article/details/82628196">https://blog.csdn.net/tjh625/article/details/82628196</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1785964">https://cloud.tencent.com/developer/article/1785964</a></p>
</li>
<li><p><a href="https://liweiwei1419.gitee.io/leetcode-algo/2017/10/01/leetcode-solution/queue-1/#">https://liweiwei1419.gitee.io/leetcode-algo/2017/10/01/leetcode-solution/queue-1/#</a>!</p>
</li>
</ul>
<!--more-->]]></content>
      <categories>
        <category>-算法 -数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>linux学习</title>
    <url>/2021/10/01/20211001-linux%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<center>持续记录ing</center>

<span id="more"></span>

<h4 id="Linux-命令中-Ctrl-z、Ctrl-c-和-Ctrl-d-的区别和使用"><a href="#Linux-命令中-Ctrl-z、Ctrl-c-和-Ctrl-d-的区别和使用" class="headerlink" title="Linux 命令中 Ctrl+z、Ctrl+c 和 Ctrl+d 的区别和使用"></a>Linux 命令中 Ctrl+z、Ctrl+c 和 Ctrl+d 的区别和使用</h4><ul>
<li><p>Ctrl+c 和 ctrl+z 都是中断命令，但是他们的作用却不一样.</p>
</li>
<li><p>Ctrl+c 是强制中断程序的执行。</p>
</li>
<li><p>Ctrl+z 的是将任务中断，但是此任务并没有结束，他仍然在进程中他只是维持挂起的状态。</p>
</li>
<li><p>Ctrl + d 的作用和你在 终端中执行 exit 的效果是一样的。 ctrl + d 后你会直接<strong>退出终端，如果是 xshell 则直接断开连接</strong>。 如果是直接用显示器键盘插在服务器上面，那么执行 ctrl + d 会退出到 login 界面。</p>
</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>-linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 背包问题</title>
    <url>/2021/09/21/20210921-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<center>祝大家中秋节快乐</center>

<span id="more"></span>

<p>今天学习了，动态规划 解决了背包问题</p>
<p>感觉这个有点绕，所以写一下子</p>
<p>[网上只找到一篇图解讲的非常好的；]</p>
<ul>
<li>[(<a href="https://blog.csdn.net/bohu83/article/details/91453227">《算法图解》-9 动态规划 背包问题，行程最优化_bohu83 的博客 - CSDN 博客_动态规划背包问题算法</a>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">大前提：因为书包初始容量大于0，物品也不会是0件，所以i，j,从1开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicPlanning</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//物品的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//物品的价值</span></span><br><span class="line">        <span class="keyword">int</span>[] val=&#123;<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">5</span>;</span><br><span class="line">        <span class="comment">//  物品的个数</span></span><br><span class="line">        <span class="keyword">int</span> n=val.length;</span><br><span class="line">        <span class="comment">//v[i][j]表示在前i个物品能装入容量为J的背包的最大价格；</span></span><br><span class="line">        <span class="keyword">int</span> [][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//因为书包初始容量大于0，物品也不会是0件，所以i，j,从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;v.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[i-<span class="number">1</span>]&gt;j)&#123;</span><br><span class="line">                    v[i][j] = v[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                    v[i][j] = Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i-<span class="number">1</span>][j]&lt;val[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]])&#123;</span><br><span class="line">                        v[i][j] = val[i-<span class="number">1</span>]+v[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]];</span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v[i].length;j++)&#123;</span><br><span class="line">                System.out.print(v[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;===========================&quot;);</span></span><br><span class="line"><span class="comment">//        for (int i=0;i&lt;path.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//            for (int j=0;j&lt;path[i].length;j++)&#123;</span></span><br><span class="line"><span class="comment">//                if (path[i][j]==1)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.printf(&quot;第%d个物品放入背包&quot;,i);</span></span><br><span class="line"><span class="comment">//                    System.out.println();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//逆序</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;<span class="number">0</span>&amp;&amp; j &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个物品放入背包&quot;</span>,i);</span><br><span class="line">                j -= w[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul>
<li>更多源码见我的GitHub</li>
</ul>
<!--more-->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA必备知识整理</title>
    <url>/2021/09/19/20210919-JAVA%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<center>JAVA知识学习 面试</center>

<span id="more"></span>

<h3 id="Object类的常见方法总结"><a href="#Object类的常见方法总结" class="headerlink" title="Object类的常见方法总结"></a><strong>Object</strong>类的常见方法总结</h3><p>Object类是一个特殊的类，是所有类的父类。它主要提供了以下11个方法：</p>
<p><strong>public final native Class&lt;?&gt; getClass()</strong>//native方法，用于返回当前运行时对象的Class对象，使用了 final关键字修饰，故不允许子类重写。 </p>
<p>public native int <strong>hashCode</strong>() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的 HashMap。 </p>
<p>public boolean <strong>equals</strong>(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。 </p>
<p>public String <strong>toString</strong>()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</p>
<p>public <strong>final native</strong> void <strong>notify</strong>()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会<strong>任意</strong>唤醒一个。 </p>
<p>public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 </p>
<p>public final native void <strong>wait</strong>(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。 </p>
<p>public final void <strong>wait</strong>(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示<strong>额外时间</strong>（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。 </p>
<p>public final void <strong>wait</strong>() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等 </p>
<p>待，没有超时时间这个概念 </p>
<p>protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作</p>
<h3 id="类集框架"><a href="#类集框架" class="headerlink" title="类集框架"></a>类集框架</h3><p><strong>集合框架底层数据结构总结</strong></p>
<p><strong>Collection</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> Object[] toArray();</span><br></pre></td></tr></table></figure>

<p><strong>1. List</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">扩充的方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Arraylist</strong>：Object数组</p>
<p><strong>Vector</strong>：Object数组</p>
<p><strong>LinkedList</strong>： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) 详细可阅读JDK1.7-LinkedList循环链表优化</p>
<p><strong>2. Set</strong></p>
<p><strong>HashSet</strong>（无序，唯一）基于 HashMap 实现的，底层采用 HashMap 来保存元素</p>
<p><strong>LinkedHashSet</strong>： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类</p>
<p>似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</p>
<p><strong>TreeSet</strong>（有序，唯一）：红黑树(自平衡的排序二叉树。</p>
<p><strong>Map</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span> <span class="params">(K key, V value)</span></span>; <span class="comment">//如果重复会替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>; <span class="comment">//将key转换成set</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object Key)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>HashMap</strong>：JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希</p>
<p>冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默</p>
<p>认为8）时，将链表转化为红黑树，以减少搜索时间</p>
<p><strong>LinkedHashMap:</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和</p>
<p>链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以</p>
<p>保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
<p><strong>HashTable:</strong> 同步操作，读写安全，不允许储存null</p>
<p><strong>TreeMap:</strong> 红黑树（自平衡的排序二叉树）</p>
<h3 id="数组和链表对比"><a href="#数组和链表对比" class="headerlink" title="数组和链表对比"></a>数组和链表对比</h3><ul>
<li>链表不用扩容，增删方便；</li>
<li>数组查找快，链表要遍历；</li>
</ul>
<p>/*</p>
<h3 id="集合的工具类-Collections"><a href="#集合的工具类-Collections" class="headerlink" title="* 集合的工具类 (Collections):"></a>* 集合的工具类 (Collections):</h3><p> * 笔试题：说出 Collection 与 Collections 的区别？<br> *   1.Collection 是一个单列集合的跟接口，Collections 是操作集合对象的一个工具类<br> * Collections 常见方法：<br> *   1. 对 list 进行排序：<br> *     sort(List<T> list)<br> *     sort(List<T> list, Comparator c)<br> *   2. 对 list 进行二分查找：<br> *     binarySearch(List<? extends Comparable<? super T>> list, T key)
 \*     binarySearch(List<? extends T> list, T key, Comparator<? super T> c)
 \*   3. 对集合取最大值或最小值
 \*     max(Collection<? extends T> coll)
 \*     max(Collection<? extends T> coll, Comparator<? super T> comp)
 \*     min(Collection<? extends T> coll)
 \*     min(Collection<? extends T> coll, Comparator<? super T> comp)
 \*   4. 对 list 集合进行反转
 \*     reverse(List<?> list<br> *   5. 可以将不同步的集合变成同步的集合<br> *     synchronizedCollection(Collection<T> c)<br> *     synchronizedList(List<T> list)<br> *     synchronizedMap(Map&lt;K,V&gt; m)<br> *     synchronizedSet(Set<T> s)</p>
<p> * */</p>
<h3 id="数组的工具类-Arrays"><a href="#数组的工具类-Arrays" class="headerlink" title="数组的工具类 (Arrays)"></a>数组的工具类 (Arrays)</h3><p> *    1. 复制数组：<br> *     copyOf(boolean[] original, int newLength)<br> *      original: 源数组</p>
<p> *      newLength: 新数组长度<br> *    2. 复制部分数组<br> *     copyOfRange<br> *    3. 比较两个数组是否相同<br> *     equals(int[],int[])<br> *    4. 将数组变成集合<br> *     List aslist(T[])</p>
<p>*    5、返回成字符串toString()；</p>
<p>*    6.Array.sort()</p>
<h3 id="Java-中-amp-amp-和-amp"><a href="#Java-中-amp-amp-和-amp" class="headerlink" title="Java 中 &amp;&amp; 和 &amp;"></a><strong>Java 中 &amp;&amp; 和 &amp;</strong></h3><p>都是表示<strong>与的逻辑运算符</strong>，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算结果才为 true，否则为 false。 &amp;&amp; 的短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；&amp; 则两个表达式都执行。</p>
<p>持续更新ing</p>
<!--more-->

]]></content>
      <categories>
        <category>JAVA基础</category>
        <category>JAVA</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JAVA基础</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存分配小总结</title>
    <url>/2021/09/18/JVM%E5%88%86%E5%9D%97%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<center>JVM中各个变量存放的位置</center>

<span id="more"></span>

<p>需要储备的知识点</p>
<p>Java 中的变量根据不同的标准可以分为两类，以其<strong>引用的数据类型</strong>的不同来划分可分为 “原始数据类型变量和引用数据类型变量”，以其<strong>作用范围</strong>的不同来区分可分为 “局部变量，实例变量和静态变量”。</p>
<p><strong>实例方法和普通方法</strong></p>
<h3 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序| 进程 | 线程"></a>程序| 进程 | 线程</h3><ul>
<li> JVM 是一份本地化的程序，本质上是可执行的文件，是静态的概念。程序运行起来成为进程，是动态的概念。</li>
<li>JAVA进程（ java 程序）：一个 JVM 实例其实就是 JVM 跑起来的进程。</li>
<li>各个 JVM 实例之间是相互隔离的。eg：登录了多个QQ</li>
<li>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位。</li>
<li>线程：线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。线程之间共用一个进程的内存空存空间 (即 jvm 堆内存)，各个线程也有自己独立专有的内存空间 (即 jvm 栈帧空间)。看下图就明白了</li>
</ul>
<h3 id="首先确定一下jkd1-8之后的JVM内存模型"><a href="#首先确定一下jkd1-8之后的JVM内存模型" class="headerlink" title="首先确定一下jkd1.8之后的JVM内存模型"></a>首先确定一下jkd1.8之后的JVM内存模型</h3><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20180225003503739" alt="JVM内存模型" style="zoom:50%;" /><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210918141601102.png" style="zoom:50%;" /></p>
<h4 id="方法变量内存分配图"><a href="#方法变量内存分配图" class="headerlink" title="方法变量内存分配图"></a>方法变量内存分配图</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20190226181808168.jpg" alt="img" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> BigWaterMelon bigWaterMelon_1 = <span class="keyword">new</span> BigWaterMelon(x);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line">    BigWaterMelon bigWaterMelon_2 = <span class="keyword">new</span> BigWaterMelon(y);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Fruit fruit = <span class="keyword">new</span> Fruit();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">30</span>;</span><br><span class="line">        BigWaterMelon bigWaterMelon_3 = <span class="keyword">new</span> BigWaterMelon(z);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">100</span>;</span><br><span class="line">                setWeight(k);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> waterMelonWeight)</span> </span>&#123;</span><br><span class="line">                fruit.bigWaterMelon_2.weight = waterMelonWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigWaterMelon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigWaterMelon</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上图可得：</p>
<ul>
<li>每个 Java 方法在被调用的时候都会创建一个栈帧，并入栈。一旦完成调用，则出栈。所有的的栈帧都出栈后，线程也就完成了使命。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>本地方法栈为虚拟机使用到的 native 方法服务</li>
</ul>
<h4 id="JAVA-Stack"><a href="#JAVA-Stack" class="headerlink" title="JAVA Stack"></a>JAVA Stack</h4><p>​    栈中有栈帧，栈帧内存: </p>
<ul>
<li>8 中基本类型变量 （byte(8)、short(16)、int(32)、long(64)、float(12)、double(64)、char(16)、boolean；）</li>
<li>对象的引用变量(Fruit fruit ) 、</li>
<li>实例方法(方法出口)、</li>
<li>局部变量表；</li>
<li>操作数栈(程序计数器)、</li>
</ul>
<h5 id="Java-lang-StackOverflowError-栈内存溢出"><a href="#Java-lang-StackOverflowError-栈内存溢出" class="headerlink" title="Java.lang.StackOverflowError 栈内存溢出"></a>Java.lang.StackOverflowError 栈内存溢出</h5><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>一个JVM只存在一个堆内存，堆内存的大小是可以调节的。</p>
<ul>
<li>储存：运行时常量池(字符串拼接得到的P141)、<strong>实例变量</strong>eg:new Fruit、(也叫成员变量)、静态变量</li>
<li>两个区域：新生代（8：1：1）、老年代（）</li>
</ul>
<h4 id="PCR"><a href="#PCR" class="headerlink" title="PCR"></a>PCR</h4><ul>
<li><p>​    Java 虚拟机可以支持多个线程同时执行，<strong>每个线程都有自己的程序计数器</strong>。在任何时刻，每个线程都只会执行一个方法的代码，这个方法称为该线程的当前方法（current method）。</p>
<p>如果线程正在执行的是 Java 方法（不是 native 的），则程序计数器记录的是正在执行的 Java 虚拟机字节码指令的地址。如果正在执行的是本地（native）方法，那么计数器的值是空的（undefined）。</p>
</li>
</ul>
<h3 id="元空间（以前的永久代-方法区）"><a href="#元空间（以前的永久代-方法区）" class="headerlink" title="元空间（以前的永久代/方法区）"></a>元空间（以前的永久代/方法区）</h3><ul>
<li><p>Caused by: java.lang.OutOfMemoryError: Metaspace</p>
</li>
<li><p><strong>储存信息</strong>：</p>
<ul>
<li>类加载器读取了类文件后，需要把Class metadata（类元数据）、方法模板（构造方法）、常变量放到元空间中；</li>
</ul>
</li>
</ul>
<h3 id="Java-中有哪几种常量池？"><a href="#Java-中有哪几种常量池？" class="headerlink" title="Java 中有哪几种常量池？"></a>Java 中有哪几种常量池？</h3><p>class 文件常量池、运行时常量池、字符串常量池。</p>
<h4 id="class-文件常量池"><a href="#class-文件常量池" class="headerlink" title="class 文件常量池"></a>class 文件常量池</h4><p>class 文件常量池（class constant pool）属于 class 文件的其中一项，class 类文件包含：类的版本、常量池、访问标志、字段表集合、方法表等信息。</p>
<p>常量池用于存放编译期间生成的各种字面量（Literal）和符号引用（Symbolic References）。</p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20210704163359946.png"></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>class 文件常量池是在类被编译成 class 文件时生成的。而当类被加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时常量池中。</p>
<p>Java 虚拟机规范中对运行时常量池的定义如下：</p>
<blockquote>
<p>A run-time constant pool is a per-class or per-interface run-time representation of the constant_pool table in a class file.</p>
<p>运行时常量池是 class 文件中每一个类或接口的常量池表（constant_pool table）的运行时表示形式。</p>
</blockquote>
<p>因此，根据规范定义，可以说运行时常量池是 class 文件常量池的运行时表示，每个类在运行时都有自己的一个独立的运行时常量池。</p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>简单来说，HotSpot VM 里的字符串常量池（StringTable）是个哈希表，全局只有一份，被所有的类共享。</p>
<p>StringTable 具体存储的是 String 对象的引用，而不是 String 对象实例自身。String 对象实例在 JDK 6 及之前是在永久代里，从 JDK 7 开始放在堆里。</p>
<p>根据 Java 虚拟机规范的定义，堆是存储 Java 对象的地方，其他地方是不会有 Java 对象实体的，如果有的话，根据规范定义，这些地方也要算堆的一部分。</p>
<h2 id="jdk1-8之后永久代的变化"><a href="#jdk1-8之后永久代的变化" class="headerlink" title="jdk1.8之后永久代的变化"></a>jdk1.8之后永久代的变化</h2><p>永久代在 Java 8 被移除。根据官方提案的描述，移除的主要动机是：要将 JRockit 和 Hotspot 进行融合，而 JRockit 并没有永久代。</p>
<p>而据我们所了解的，还有另外一个重要原因是永久代本身也存在较多的问题，经常出现 OOM，还出过不少 bug。</p>
<p>根据官方提案的描述，永久代主要存储了三种数据： </p>
<p>1）<strong>Class metadata（类元数据）</strong>，也就是方法区中包含的数据，除了编译生成的字节码被放在 native memory（本地内存）。</p>
<p>2）<strong>interned Strings</strong>，也就是字符串常量池中驻留引用的字符串对象，字符串常量池只驻留引用，而实际对象是在永久代中。</p>
<p>3）<strong>class static variables</strong>，类静态变量。</p>
<p>移除永久代后，interned Strings 和 class static variables 被移动了堆中，Class metadata 被移动到了后来的元空间。</p>
<h2 id="为什么引入元空间？"><a href="#为什么引入元空间？" class="headerlink" title="为什么引入元空间？"></a>为什么引入元空间？</h2><p>在 Java 8 之前，Java 虚拟机使用永久代来存放类元信息，通过 - XX:PermSize、-XX:MaxPermSize 来控制这块内存的大小，随着动态类加载的情况越来越多，这块内存变得不太可控，到底设置多大合适是每个开发者要考虑的问题。</p>
<p>如果设置小了，容易出现内存溢出；如果设置大了，又有点浪费，尽管不会实质分配这么大的物理内存。</p>
<p>而元空间可以较好的解决内存设置多大的问题：当我们没有指定 -XX:MaxMetaspaceSize 时，元空间可以动态的调整使用的内存大小，以容纳不断增加的类。</p>
<h2 id="元空间（metaspace）"><a href="#元空间（metaspace）" class="headerlink" title="元空间（metaspace）"></a>元空间（metaspace）</h2><p>元空间在 Java 8 移除永久代后被引入，用来代替永久代，本质和永久代类似，都是对方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存（native memory）。</p>
<p>元空间主要用于存储 Class metadata（类元数据），根据其命名其实也看得出来。</p>
<p>可以通过 -XX:MaxMetaspaceSize 参数来限制元空间的大小，如果没有设置该参数，则元空间默认限制为机器内存。</p>
<!--more-->

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JAVA基础</tag>
      </tags>
  </entry>
  <entry>
    <title>String 直接赋值与使用 new String 的区别</title>
    <url>/2021/09/17/String-%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E4%B8%8E%E4%BD%BF%E7%94%A8-new-String-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis6框架学习</title>
    <url>/2021/09/07/2021-09-07-Redis/</url>
    <content><![CDATA[<center>NoSQL</center>

<span id="more"></span>

<h3 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h3><p>串行–</p>
<h4 id="1-1-1-NoSQL-适用场景"><a href="#1-1-1-NoSQL-适用场景" class="headerlink" title="1.1.1.  NoSQL****适用场景"></a><strong>1.1.1.</strong>  <strong>NoSQL****适用场景</strong></h4><p>l 对数据高并发的读写</p>
<p>l 海量数据的读写</p>
<p>l 对数据高可扩展性的</p>
<h4 id="1-1-2-NoSQL-不适用场景"><a href="#1-1-2-NoSQL-不适用场景" class="headerlink" title="1.1.2.  NoSQL****不适用场景"></a><strong>1.1.2.</strong>  <strong>NoSQL****不适用场景</strong></h4><p>l 需要事务支持</p>
<p>l 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
<p>l <strong>（用不着sql<strong><strong>的和用了sql</strong></strong>也不行的情况，请考虑用NoSql****）</strong></p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="1-1-1-多样的数据结构存储持久化数据"><a href="#1-1-1-多样的数据结构存储持久化数据" class="headerlink" title="1.1.1.  多样的数据结构存储持久化数据"></a><strong>1.1.1.</strong>  <strong>多样的数据结构存储持久化数据</strong></h4><p>​                               <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211005112702192.png" alt="image-20211005112702192"></p>
<h4 id="1-1-1-Redis-介绍相关知识"><a href="#1-1-1-Redis-介绍相关知识" class="headerlink" title="1.1.1.  Redis****介绍相关知识"></a><strong>1.1.1.</strong>  <strong>Redis****介绍相关知识</strong></h4><table>
<thead>
<tr>
<th>端口6379从何而来  <a href="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/6379.jpg">Alessia  Merz</a></th>
<th>默认16个数据库，类似数组下标从0开始，初始默认使用0号库  使用命令 select  <dbid>来切换数据库。如: select 8</th>
</tr>
</thead>
<tbody><tr>
<td>9宫格键</td>
<td>flushall通杀全部库</td>
</tr>
<tr>
<td></td>
<td>flushdb清空当前库</td>
</tr>
<tr>
<td></td>
<td>统一密码管理，所有库同样密码。</td>
</tr>
</tbody></table>
<p>Redis是单线程+多路IO复用技术</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>数据类型丰富</li>
<li>支持持久化存储</li>
<li>支持主从</li>
<li>支持分片 </li>
</ul>
<p>CAP的3进2</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>查找常用API <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h4 id="KEY"><a href="#KEY" class="headerlink" title="KEY"></a>KEY</h4><ul>
<li>keys *查看当前库所有key  (匹配：keys *1)</li>
<li>exists key判断某个key是否存在</li>
<li>type key 查看你的key是什么类型</li>
<li>del key    删除指定的key数据</li>
<li>unlink key  根据value选择非阻塞删除</li>
<li>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li>
<li>expire key 10  10秒钟：为给定的key设置过期时间</li>
<li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>setex <key>&lt;****过期时间****&gt;<value></strong></p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p>set  <key><value></p>
<p>get  <key>查询对应键值</p>
<p>append <key><value>将给定的<value> 追加到原值的末尾</p>
<p>strlen <key>获得值的长度</p>
<p>setnx <key><value>只有在 key 不存在时  设置 key 的值</p>
<p>mset <key1><value1><key2><value2> ….. </p>
<p>同时设置一个或多个 key-value对 </p>
<p>mget <key1><key2><key3> …..</p>
<p>同时获取一个或多个 value </p>
<p>msetnx <key1><value1><key2><value2> ….. </p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List的数据结构为快速链表quickList</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所有添加，删除，查找的*<em>复杂度都是</em>***O(1)**。</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p><strong>数据区域化</strong></p>
<p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h4 id="Zset-sorted-set"><a href="#Zset-sorted-set" class="headerlink" title="Zset(sorted set)"></a><strong>Zset(sorted set)</strong></h4><p>不同之处是有序集合的每个成员都关联了一个<strong>评分（<strong><strong>score</strong></strong>）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>zadd <key><score1><value1><score2><value2>…</p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
<p><strong>zrange <key><start><stop> [WITHSCORES]</strong>  </p>
<p>返回有序集 key 中，下标在<start><stop>之间的元素</p>
<p>带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscore key minmax [withscores] [limit offset count]</p>
<p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
<p>zrevrangebyscore key max min [withscores] [limit offset count]        </p>
<p>同上，改为从大到小排列。 </p>
<ul>
<li>如何利用zset实现一个文章访问量的排行榜？</li>
</ul>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h3 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a><strong>Bitmaps</strong></h4><p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><strong>HyperLogLog</strong></h4><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>快速计算基数并返回</p>
<p>比如每月活跃用户可以使用每天的活跃用户来合并计算</p>
<h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a><strong>Geospatial</strong></h4><p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p>
<h3 id="配置文件参数"><a href="#配置文件参数" class="headerlink" title="配置文件参数"></a>配置文件参数</h3><p>自定义目录：/myredis/redis.conf</p>
<ul>
<li><p><strong>###INCLUDES**<strong>包含</strong></strong>###**</p>
</li>
<li><p><strong>bind</strong></p>
</li>
</ul>
<p>默认情况bind=127.0.0.1只能接受本机的访问请求</p>
<p>不写的情况下，无限制接受任何ip地址的访问</p>
<ul>
<li>**protected-**mode</li>
</ul>
<p>将本机访问保护模式设置no</p>
<ul>
<li> <strong>Port</strong></li>
</ul>
<p>端口号，默认 6379</p>
<p><strong>tcp-backlog</strong></p>
<h3 id="Redis-的发布和订阅"><a href="#Redis-的发布和订阅" class="headerlink" title="Redis****的发布和订阅"></a><strong>Redis****的发布和订阅</strong></h3><p><strong>1.1.</strong>  <strong>什么是发布和订阅</strong></p>
<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道</p>
<p><strong>1.</strong>  **Redis_Jedis_**<strong>实例</strong></p>
<p><strong>1.1.</strong>  <strong>完成一个手机验证码功能</strong></p>
<p>要求：</p>
<p>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效</p>
<p>2、输入验证码，点击验证，返回成功或失败</p>
<p>3、每个手机号每天只能输入3次</p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/01-%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B.png"></p>
<h3 id="1-Redis-事务-锁机制-秒杀"><a href="#1-Redis-事务-锁机制-秒杀" class="headerlink" title="1.  **Redis_**事务 锁机制      秒杀"></a><strong>1.</strong>  **Redis_**<strong>事务</strong> <em><strong>锁机制</strong></em>      秒杀</h3><h4 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h4><p>eg：有很多人有你的账户,同时去参加双十一抢购；</p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211005175710985.png" alt="image-20211005175710985"></p>
<p>Multi:先组队 ，</p>
<ul>
<li>组队出错，则都不能<strong>提交</strong>；</li>
</ul>
<p>Exec：执行阶段</p>
<ul>
<li>一个出错，其他的照常运行，不会回滚；</li>
</ul>
<p>组队的过程中可以通过discard来放弃组队。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>​    无论什么情况，操作之前先上锁；</p>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>都可以同时操作，但是更新的时候比较版本</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong></p>
<p>​    Redis就是利用这种check-and-set机制实现事务的。</p>
<h4 id="事务三大特性"><a href="#事务三大特性" class="headerlink" title="事务三大特性"></a>事务三大特性</h4><ol>
<li>单独的隔离操作</li>
<li>没有隔离级别的概念</li>
<li>不保证原子性</li>
</ol>
<h4 id="秒杀案例"><a href="#秒杀案例" class="headerlink" title="秒杀案例"></a>秒杀案例</h4><p>使用ab增加模拟并发</p>
<p>连接超时问题使用连接池解决；</p>
<ol>
<li><p>超卖现象</p>
<ul>
<li>使用乐观锁解决，但是又有库存遗留问题；</li>
</ul>
</li>
<li><p>库存遗留</p>
<ul>
<li><p>使用LUA脚本</p>
</li>
<li><p>利用lua脚本淘汰用户，解决超卖和遗留问题。</p>
<p>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。      意思就是进行了排队</p>
</li>
</ul>
</li>
</ol>
<h3 id="Redis持久化之RDB"><a href="#Redis持久化之RDB" class="headerlink" title="Redis持久化之RDB"></a><strong>Redis持久化之RDB</strong></h3><p>Redis 提供了2个不同形式的持久化方式。</p>
<ol>
<li><p>RDB（Redis DataBase）</p>
<ol>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</li>
<li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB</strong>的缺点是最后一次持久化后的数据可能丢失**。</li>
<li><strong>bgsave</strong>：<strong>Redis</strong>会在后台异步进行快照操作，** <strong>快照同时还可以响应客户端请求。</strong></li>
<li></li>
</ol>
</li>
<li><p>AOF（Append Of File）</p>
<ol>
<li><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
</li>
<li><p> <strong>AOF****默认不开启</strong></p>
</li>
</ol>
<p>   可以在redis.conf中配置文件名称，默认为 appendonly.aof</p>
<p>   AOF文件的保存路径，同RDB的路径一致。</p>
<ol start="3">
<li><p>文件过大会进行Rewrite</p>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p>
</li>
<li><p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p>
</li>
</ol>
</li>
</ol>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master<strong><strong>以写为主，</strong></strong>Slave****以读为主</strong></p>
<p>读写分离性能扩展</p>
<ul>
<li>slave-priority 10  设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</li>
<li>slaveof <ip><port>        成为某个实例的从服务器</li>
<li>可以将配置增加到文件中。永久生效。</li>
</ul>
<h4 id="1-1-1-一主二仆"><a href="#1-1-1-一主二仆" class="headerlink" title="1.1.1.  一主二仆"></a><strong>1.1.1.</strong>  <strong>一主二仆</strong></h4><h4 id="1-1-1-薪火相传"><a href="#1-1-1-薪火相传" class="headerlink" title="1.1.1.  薪火相传**"></a><strong>1.1.1.</strong>  <strong>薪火相传</strong>**</h4><h4 id="1-1-1-反客为主"><a href="#1-1-1-反客为主" class="headerlink" title="1.1.1.**  反客为主"></a>1.1.1.**  <strong>反客为主</strong></h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="1-1-哨兵模式-sentinel"><a href="#1-1-哨兵模式-sentinel" class="headerlink" title="1.1.  哨兵模式(sentinel)"></a><strong>1.1.</strong>  <strong>哨兵模式</strong><strong>(sentinel)</strong></h4><ul>
<li><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
</li>
<li><p>sentinel monitor mymaster 127.0.0.1 6379 1</p>
<p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p>
<p><strong>1.1.1.</strong>  <strong>故障恢复</strong></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211006012539613.png" alt="image-20211006012539613"></p>
</li>
</ul>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a><strong>Redis</strong>集群</h3><p>容量不够，redis如何进行扩容？</p>
<p>并发写操作， redis如何分摊？</p>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<h4 id="普通方式登录"><a href="#普通方式登录" class="headerlink" title="普通方式登录"></a>普通方式登录</h4><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p>
<p>​                               </p>
<h4 id="c-采用集群策略连接，"><a href="#c-采用集群策略连接，" class="headerlink" title="-c 采用集群策略连接，"></a><strong>-c</strong> <strong>采用集群策略连接，</strong></h4><p><strong>设置数据会自动切换到相应的写主机</strong><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20211006012913267.png" alt="image-20211006012913267"></p>
<p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p>
<h3 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a><strong>Redis应用问题解决</strong></h3><h4 id="1-1-缓存穿透"><a href="#1-1-缓存穿透" class="headerlink" title="1.1.  缓存穿透"></a><strong>1.1.</strong>  <strong>缓存穿透</strong></h4><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。，可能是被攻击了</p>
<h4 id="1-1-缓存击穿"><a href="#1-1-缓存击穿" class="headerlink" title="1.1.  缓存击穿"></a><strong>1.1.</strong>  <strong>缓存击穿</strong></h4><p>key对应的数据存在，但在redis中过期，大量并发导致的</p>
<h4 id="1-1-缓存雪崩"><a href="#1-1-缓存雪崩" class="headerlink" title="1.1.  缓存雪崩"></a><strong>1.1.</strong>  <strong>缓存雪崩</strong></h4><p>很多key过期</p>
<h4 id="1-1-分布式锁"><a href="#1-1-分布式锁" class="headerlink" title="1.1.  分布式锁"></a><strong>1.1.</strong>  <strong>分布式锁</strong></h4><p>需要一种跨JVM的互斥机制来控制共享资源的访问</p>
<ol>
<li><p>set sku:1:info “OK” NX PX 10000</p>
<p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p>
</li>
<li><p>有个问题，set过程出错，导致锁没法被释放</p>
<p>优化之设置锁的自动施放时间</p>
</li>
<li><p>但是有个问题，因为有可能A没有执行完。锁被释放了。释放了别人的锁；</p>
<p>setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p>
</li>
<li><p>删除操作缺乏原子性；判断完uuid 锁过期</p>
<p><strong>优化之UUID防误删</strong>，</p>
</li>
</ol>
<p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p>
<p>- 互斥性。在任意时刻，只有一个客户端能持有锁。</p>
<p>- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p>
<p>- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p>
<p>- 加锁和解锁必须具有原子性。</p>
<h3 id="Redis6-0-新功能"><a href="#Redis6-0-新功能" class="headerlink" title="Redis6.0****新功能"></a><strong>Redis6.0****新功能</strong></h3><p>持续关注ing</p>
<h3 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h3><ol>
<li><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><ul>
<li><p>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作；</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p>
<p>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
<p>Redis单命令的原子性主要得益于Redis的单线程。</p>
</li>
</ul>
</li>
<li><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。</p>
<ul>
<li>Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</li>
</ul>
</li>
<li><p>求集合中不重复元素个数的问题称为基数问题。</p>
</li>
</ol>
<!--more-->

]]></content>
      <categories>
        <category>-高并发 -框架</category>
      </categories>
      <tags>
        <tag>Redis，框架</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap原理</title>
    <url>/2021/09/07/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<center>HashMap底层原理</center>

<span id="more"></span>

<h3 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h3><p>​        JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>​        <strong>HashMap</strong> <strong>通过</strong> <strong>key</strong> <strong>的</strong> <strong>hashCode</strong> <strong>经****过扰动函数处理过后得到</strong> <strong>hash</strong> <strong>值，然后通过</strong> (n <strong>-</strong> 1) &amp; hash <strong>判断当前元素存放的位置（这里的</strong> <strong>n</strong> *<em>指的是数组的</em>***长度）；</p>
<p>​        <strong>所谓扰动函数指的就是</strong> <strong>HashMap</strong> <strong>的</strong> <strong>hash</strong> <strong>方法。使用</strong> <strong>hash</strong> <strong>方法也就是扰动函数是为了防止一些实现比较差的****hashCode()</strong> <strong>方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p><strong>JDK 1.8 HashMap</strong> <strong>的</strong> <strong>hash</strong> <strong>方法源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode </span></span><br><span class="line">    <span class="comment">// ^ ：按位异或 </span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 </span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** Returns a power of two size for the given target capacity. */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span> n = cap - <span class="number">1</span>; </span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>



<p>小总结：hashMap在确定元素位置时，先调用 hashcode()算出一个值，然后再和它本身 右移16位得到的 值进行 异或运算 返回一个hash值，最后用这个值和数组长度减一进行与运算确定元素位置；</p>
<p>补充：</p>
<ol>
<li><p>ArrayList 的扩容机制：</p>
<p>三个构造器：</p>
<ul>
<li>无参构造器，返回一个默认大小为10的容器</li>
<li>一个参数构造器，返回指定大小的数组</li>
<li>还有一个是将collection转换成arraylst，再将值复制一份；</li>
</ul>
</li>
<li><p>int newCapacity = oldCapacity + (oldCapacity&gt;&gt; 1); 是最重要的一条语句，oldCapacity 为原来的容量，oldCapacity &gt;&gt; 1 表示向右移一位，相当于除以 2，即 newCapacity 是原来容量的 1.5 倍。如果扩大 1.5 倍后还不够，则直接将其扩大至 minCapacity 大小。判断 newCapacity 是否 超过了最大容量 MAX_ARRAY_SIZE ，</p>
</li>
<li><p>将原来数据复制到扩容后的数组中。elementData [size++] = e; 将新加入元素添加至数组中。（费空间时间）</p>
</li>
</ol>
<h3 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h3><ul>
<li>如果数组长度变化，hashmap的索引值也会变化</li>
<li>🙇</li>
</ul>
<!--more-->]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中单引号和双引号的区别</title>
    <url>/2021/09/05/JAVA%E4%B8%AD%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<center>JAVA中单引号和双引号的区别</center>

<span id="more"></span>

<p>今天在字符比较的时候发现的一个小问题,小总结一下</p>
<p>JAVA中单引号和双引号的区别：</p>
<ul>
<li><p>区别 1：java 中的 单引号 表示字符，java 中的 双引号 是字符串。</p>
</li>
<li><p> 区别 2： 单引号 引的数据一般是 char 类型的； 双引号 引的数据 是 String 类型的。</p>
</li>
<li><p>区别 3：java 中 单引号 里面只能放一个字母或数字或符号；java 中的 双引号 里面是 0 到多个字符构成。. </p>
</li>
<li><p>所以字符可以直接转换成字符串。. 字符串需要使用 charAt（n) 来获取第几个字符。. char 定义时用单引号，只能有一个字母，数字。. char c=’c’；而 String 用双引号，可以是一个，也可能是多个字母，汉字等。就是所谓的字符串。</p>
</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习</title>
    <url>/2021/09/02/2021-09-02-JVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<center></center>

<span id="more"></span>

<h3 id="JVM体系预览"><a href="#JVM体系预览" class="headerlink" title="JVM体系预览"></a>JVM体系预览</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902152852901.png" alt="image-20210902152852901" style="zoom:67%;" />

<p>Class loader是否加载class文件，识别开头 cafe babe</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902163158773.png" alt="image-20210902163158773" style="zoom:67%;" />

<p>jre就是java run environment</p>
<p>灰色代表线程私有，内存占用很少；（不存在垃圾回收机制）</p>
<h3 id="四种ClassLoader"><a href="#四种ClassLoader" class="headerlink" title="四种ClassLoader"></a>四种ClassLoader</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902162308851.png" alt="image-20210902162308851" style="zoom:67%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902164122286.png" alt="image-20210902164122286" style="zoom:67%;" />

<h5 id="双亲委派机制："><a href="#双亲委派机制：" class="headerlink" title="双亲委派机制："></a>双亲委派机制：</h5><ul>
<li>一般去父类找已经编译好的，找不到再自己做；（沙箱安全机制）</li>
</ul>
<h3 id="Native-Interface"><a href="#Native-Interface" class="headerlink" title="Native Interface"></a>Native Interface</h3><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902164409710.png" alt="image-20210902164409710"></p>
<img src="C:/Users/ZXH082600/AppData/Roaming/Typora/typora-user-images/image-20210902165519962.png" alt="image-20210902165519962" style="zoom:67%;" />

<h3 id="PC-Register寄存器"><a href="#PC-Register寄存器" class="headerlink" title="PC Register寄存器"></a>PC Register寄存器</h3><ul>
<li>每个线程的PCR指向下一个指令的指针</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902170127712.png" alt="image-20210902170127712" style="zoom:50%;" /></li>
</ul>
<h3 id="Method-Area-方法区"><a href="#Method-Area-方法区" class="headerlink" title="Method Area 方法区"></a>Method Area 方法区</h3><p>存储每个类的模板信息————绝对不是放方法的地方<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902171411560.png" alt="image-20210902171411560" style="zoom:50%;" /></p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902171754599.png" alt="image-20210902171754599" style="zoom:67%;" />









<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>栈管内存，堆管存储；</p>
<ul>
<li>栈帧保存哪些东东？<ul>
<li>8中基本类型变量+对象的引用变量+实例方法</li>
</ul>
</li>
</ul>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902173802047.png" alt="image-20210902173802047" style="zoom: 50%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210902173626117.png" alt="image-20210902173626117" style="zoom: 50%;" />

 <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903141446327.png" alt="栈中储存的东西" style="zoom: 67%;" />

<h5 id="Java-lang-StackOverflowError-栈内存溢出"><a href="#Java-lang-StackOverflowError-栈内存溢出" class="headerlink" title="Java.lang.StackOverflowError 栈内存溢出"></a>Java.lang.StackOverflowError 栈内存溢出</h5><h3 id="栈堆和方法区的交互关系"><a href="#栈堆和方法区的交互关系" class="headerlink" title="栈堆和方法区的交互关系"></a>栈堆和方法区的交互关系</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903142507858.png" alt="image-20210903142507858" style="zoom:67%;" />

<h3 id="堆heap"><a href="#堆heap" class="headerlink" title="堆heap"></a>堆heap</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903143020583.png" alt="image-20210903143020583" style="zoom:67%;" />

<ul>
<li><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><ul>
<li>YOUNY/NEW 8:1:1</li>
</ul>
<ol>
<li><p>伊甸园区</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903160020976.png" alt="image-20210903160020976" style="zoom: 67%;" /></li>
<li><p>幸存者0区</p>
</li>
<li><p>幸存者1区</p>
</li>
</ol>
</li>
<li><h4 id="老年代-Old-Tenure"><a href="#老年代-Old-Tenure" class="headerlink" title="老年代     Old/Tenure"></a>老年代     Old/Tenure</h4></li>
<li><h4 id="永久代-元空间-Perm"><a href="#永久代-元空间-Perm" class="headerlink" title="永久代/元空间      Perm"></a>永久代/元空间      Perm</h4><ul>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903154500064.png" alt="image-20210903154500064"></li>
</ul>
</li>
</ul>
<p>逻辑上新生养老元空间，物理上只有新生+养老</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903154731209.png" alt="image-20210903154731209" style="zoom:67%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903153757676.png" alt="image-20210903153757676" style="zoom: 50%;" />

<h4 id="Java8之后永久代和元空间的变化"><a href="#Java8之后永久代和元空间的变化" class="headerlink" title="Java8之后永久代和元空间的变化"></a>Java8之后永久代和元空间的变化</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903155348328.png" alt="image-20210903155348328" style="zoom:50%;" />

<h4 id="堆参数调优"><a href="#堆参数调优" class="headerlink" title="堆参数调优"></a>堆参数调优</h4><p>实际生产中Xms 和 Xmx必须调成一样，防止</p>
<p>最大分配的物理内存和初始化的内存设置成一样大小，避免GC和应用程序争抢内存，峰值和峰谷忽高忽低</p>
<h5 id="GC详细日志解读"><a href="#GC详细日志解读" class="headerlink" title="GC详细日志解读"></a>GC详细日志解读</h5><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903165929128.png" alt="image-20210903165929128"></p>
<h6 id="11个参数的意思"><a href="#11个参数的意思" class="headerlink" title="11个参数的意思"></a>11个参数的意思</h6><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903172405616.png" alt="image-20210903172405616"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903172135941.png" alt="image-20210903172135941"></p>
<h3 id="GC是什么"><a href="#GC是什么" class="headerlink" title="GC是什么"></a>GC是什么</h3><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><h6 id="次数上频繁收集Young区"><a href="#次数上频繁收集Young区" class="headerlink" title="次数上频繁收集Young区"></a>次数上频繁收集Young区</h6><h6 id="次数上较少收集Old区"><a href="#次数上较少收集Old区" class="headerlink" title="次数上较少收集Old区"></a>次数上较少收集Old区</h6><h6 id="基本不动元空间"><a href="#基本不动元空间" class="headerlink" title="基本不动元空间"></a>基本不动元空间</h6><h4 id="GC4大算法优缺点"><a href="#GC4大算法优缺点" class="headerlink" title="GC4大算法优缺点"></a>GC4大算法优缺点</h4><ol>
<li>引用计数法(一般不用)<ul>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210903173817688.png" alt="image-20210903173817688" style="zoom:67%;" /></li>
</ul>
</li>
<li>复制算法（copying）<ul>
<li>年轻代中</li>
<li>不会产生内存碎片</li>
<li>占用double内存</li>
</ul>
</li>
<li>标记清除（Mark-Sweep）<ul>
<li>老年代</li>
<li>两次扫描，耗时严重；不连续，会产生内存碎片</li>
<li>不需要额外空间</li>
</ul>
</li>
<li>标记压缩(Mark-Compact)<ul>
<li>老年代，耗时严重；</li>
<li><img src="C:/Users/ZXH082600/AppData/Roaming/Typora/typora-user-images/image-20210904141549770.png" alt="image-20210904141549770" style="zoom:67%;" /></li>
<li>标记-清除-压缩</li>
</ul>
</li>
</ol>
<p>综合</p>
<p>小总结<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210904141900014.png" alt="image-20210904141900014" style="zoom:67%;" /></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210904143900525.png" alt="image-20210904143900525"></p>
<h3 id="JMM——JAVA内存模型"><a href="#JMM——JAVA内存模型" class="headerlink" title="JMM——JAVA内存模型"></a>JMM——JAVA内存模型</h3><ol>
<li>原子性</li>
<li>可见性（通知机制）<ul>
<li>volatile</li>
</ul>
</li>
<li>有序性</li>
</ol>
<p>cpu&gt;内存&gt;硬盘</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210905110511766.png" alt="内存关系" style="zoom: 80%;" />

<p>i think开发中比较重要的 static(只编译一次) &gt; 构造方法块 &gt; 构造方法</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul>
<li><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3">Java 内存区域详解</a></li>
</ul>
<!--more-->

]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>栈</tag>
        <tag>堆</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>spring框架Review</title>
    <url>/2021/09/01/20210901-springReview/</url>
    <content><![CDATA[<h4 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a><center>Spring家族</center></h4><span id="more"></span>

<p>脑图在文末</p>
<h4 id="IOC控制反转原理"><a href="#IOC控制反转原理" class="headerlink" title="IOC控制反转原理"></a>IOC控制反转原理</h4><ul>
<li>​    上层决定下层而不是下层决定上层</li>
</ul>
<p>DI依赖注入 4种方式</p>
<ul>
<li>原理把底层类作为参数传递给上层类，实现上层对下层的“控制”；</li>
</ul>
<ol>
<li>Setter</li>
<li>Interface</li>
<li>Constructor构造方法</li>
<li>Annotation注解</li>
</ol>
<p>DL依赖查找（已抛弃）</p>
<h5 id="IOC、DI、DL的关系"><a href="#IOC、DI、DL的关系" class="headerlink" title="IOC、DI、DL的关系"></a>IOC、DI、DL的关系</h5><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901092920536.png" alt="image-20210901092920536"></p>
<h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><h5 id="IOC容器的优点"><a href="#IOC容器的优点" class="headerlink" title="IOC容器的优点"></a>IOC容器的优点</h5><ul>
<li>从上往下查找Config自动向上new依赖对象；</li>
</ul>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901093856919.png" alt="image-20210901093856919"></p>
<p>I think应用程序是由各个组件组成的；</p>
<h4 id="BEAN"><a href="#BEAN" class="headerlink" title="BEAN"></a>BEAN</h4><h5 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h5><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p>功能更强大</p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901094836005.png" alt="image-20210901094836005"></p>
<p>bean的配置方式</p>
<ul>
<li>xml<bean></li>
<li>java.class @Configuration</li>
<li>@Autowired根据bean的名称装配</li>
</ul>
<p>getBean</p>
<h5 id="SpringBean的作用域"><a href="#SpringBean的作用域" class="headerlink" title="SpringBean的作用域"></a>SpringBean的作用域</h5><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901100641979.png" alt="image-20210901100641979"></p>
<h5 id="SpringBean的生命周期"><a href="#SpringBean的生命周期" class="headerlink" title="SpringBean的生命周期"></a>SpringBean的生命周期</h5><ol>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ol>
<p>创建过程（与AOP相关）</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901100731525.png" alt="image-20210901100731525" style="zoom:67%;" />

<p>销毁过程<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901101148173.png" alt="image-20210901101148173"></p>
<h4 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h4><pre><code>  &lt;img src=&quot;https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901102025734.png&quot; alt=&quot;image-20210901102025734&quot; style=&quot;zoom:67%;&quot; /&gt;
</code></pre>
<h5 id="AOP的三种织入方式"><a href="#AOP的三种织入方式" class="headerlink" title="AOP的三种织入方式"></a>AOP的三种织入方式</h5><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901102134952.png" alt="image-20210901102134952"></p>
<h5 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h5><p>AOP主要名词概念 <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210901105055247.png" alt="image-20210901105055247" style="zoom:67%;" /></p>
<h4 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h4><ul>
<li><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">Spring Bean 的生命周期（非常详细）</a></li>
<li><a href="https://mm.edrawsoft.cn/template/22342">java 学习重点之 spring 家族脑图</a></li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习</title>
    <url>/2021/08/31/2021-08-31-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<center>稀疏数组</center>

<span id="more"></span>

<p>棋盘问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编写的五子棋程序中，有存盘退出和续上盘的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> chessArr1[][]= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> data : row)&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原始数组有多少个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">11</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存为文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\My文档\\IDEAdemo\\hexo-boot-2.3.0\\algorithm&quot;</span>+File.separator+<span class="string">&quot;chess.data&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        OutputStreamWriter write = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == sparseArr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                write.append(sparseArr[i][<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + sparseArr[i][<span class="number">1</span>] + <span class="string">&quot;,&quot;</span> + sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                write.append(sparseArr[i][<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + sparseArr[i][<span class="number">1</span>] + <span class="string">&quot;,&quot;</span> + sparseArr[i][<span class="number">2</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;写入文件中...&quot;</span>);</span><br><span class="line">        write.close();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新生成一个新chess数组</span></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//读取稀疏赋值给新chesss数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;打开文件中...&quot;</span>);</span><br><span class="line">        Desktop.getDesktop().open(file);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------先读取_chess.data&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建 FileReader 对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (reader.ready()) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) reader.read());<span class="comment">// 转成char加到StringBuffer对象中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        reader.close();<span class="comment">// 关闭读取流</span></span><br><span class="line">        fis.close();<span class="comment">// 关闭输入流,释放系统资源</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>首先思考：</p>
<ol>
<li>如何把这个数组变成二叉树？（定义根节点及其子节点）</li>
<li>遍历从哪里出发？</li>
<li>用递归还是非递归？每次递归做了什么？</li>
<li>节点有什么变化</li>
<li>最后考虑如何输出</li>
</ol>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul>
<li><a href="https://blog.csdn.net/itguangit/article/details/50063513">java 中 printf，print，println，区别及用法详解</a></li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2021/08/30/2021-08-30-JUC/</url>
    <content><![CDATA[<center>JUC学习</center>

<span id="more"></span>

<h4 id="JUC学习"><a href="#JUC学习" class="headerlink" title="JUC学习"></a>JUC学习</h4><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200624155932327.png" alt="在这里插入图片描述"></p>
<ul>
<li><h6 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span></span>&#123;</span><br><span class="line">	NEW,<span class="comment">//新建</span></span><br><span class="line">    RUNNABLE,<span class="comment">//可运行</span></span><br><span class="line">    BLOCK,<span class="comment">//wait(),sleep(),</span></span><br><span class="line">   	WAITING,<span class="comment">//不见不散</span></span><br><span class="line">    TIME_WAITING,<span class="comment">//过时不候</span></span><br><span class="line">    TERMINATED;	<span class="comment">//已终止</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210910161050744.png" alt="image-20210910161050744"></p>
</li>
<li><h6 id="Lambda-Express"><a href="#Lambda-Express" class="headerlink" title="Lambda  Express"></a>Lambda  Express</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 拷贝小括号，写死右箭头，落地大括号；() -&gt;&#123;sout&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>   <span class="meta">@FunctionalInterface</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 静态方法实现</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><h5 id="精准顺序访问控制（自己上锁）"><a href="#精准顺序访问控制（自己上锁）" class="headerlink" title="精准顺序访问控制（自己上锁）"></a>精准顺序访问控制（自己上锁）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//A:1,B:2,C:3</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printc1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>)&#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//通知第2个</span></span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printc2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//如何通知第3个</span></span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printc3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如何通知第1个</span></span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备注：多线程之间按顺序调用，实现A-&gt;B-&gt;C</span></span><br><span class="line"><span class="comment"> * 三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 接着</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 来10轮</span></span><br><span class="line"><span class="comment"> *      1.高内聚低耦合前提下，线程操作资源类</span></span><br><span class="line"><span class="comment"> *      2.判断/干活/通知</span></span><br><span class="line"><span class="comment"> *      3.多线程交互中，防止虚假唤醒(判断只能用while，不能用if)</span></span><br><span class="line"><span class="comment"> *      4.标志位（主要控制）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.printc1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.printc2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.printc3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="八🔒理论"><a href="#八🔒理论" class="headerlink" title="八🔒理论"></a>八🔒理论</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMs</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*******sendMs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*****sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.标准访问，先打印邮件</span></span><br><span class="line"><span class="comment"> * 2.邮件设置暂停4秒方法，先打印邮件</span></span><br><span class="line"><span class="comment"> *      对象锁sysc(this)</span></span><br><span class="line"><span class="comment"> *      一个对象里面如果有多个synchronized方法，某一个时刻内，只要			一个线程去调用其中的一个synchronized方法了，</span></span><br><span class="line"><span class="comment"> *      其他的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个		  线程去访问这些synchronized方法，</span></span><br><span class="line"><span class="comment"> *      锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象		的其他的synchronized方法</span></span><br><span class="line"><span class="comment"> * 3.新增sayHello方法，先打印sayHello</span></span><br><span class="line"><span class="comment"> *      加个普通方法后发现和同步锁无关</span></span><br><span class="line"><span class="comment"> * 4.两部手机，先打印短信</span></span><br><span class="line"><span class="comment"> *      换成两个对象后，不是同一把锁了，情况立刻变化</span></span><br><span class="line"><span class="comment"> * 5.两个静态同步方法，同一部手机，先打印邮件</span></span><br><span class="line"><span class="comment"> * 6.两个静态同步方法，同两部手机，先打印邮件，锁的同一个字节码对象</span></span><br><span class="line"><span class="comment"> *      全局锁</span></span><br><span class="line"><span class="comment"> *      synchronized实现同步的基础：java中的每一个对象都可以作为锁。</span></span><br><span class="line"><span class="comment"> *      具体表现为一下3中形式。</span></span><br><span class="line"><span class="comment"> *      对于普通同步方法，锁是当前实例对象，锁的是当前对象this，</span></span><br><span class="line"><span class="comment"> *      对于同步方法块，锁的是synchronized括号里配置的对象。</span></span><br><span class="line"><span class="comment"> *      对于静态同步方法，锁是当前类的class对象</span></span><br><span class="line"><span class="comment"> * 7.一个静态同步方法，一个普通同步方法，同一部手机，先打印短信</span></span><br><span class="line"><span class="comment"> * 8.一个静态同步方法，一个普通同步方法，同二部手机，先打印短信</span></span><br><span class="line"><span class="comment"> *      当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出			异常时必须释放锁。</span></span><br><span class="line"><span class="comment"> *      也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的			其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁，</span></span><br><span class="line"><span class="comment"> *      可是别的实例对象的普通同步方法因为跟该实例对象的普通同步方法			用的是不同的锁，</span></span><br><span class="line"><span class="comment"> *      所以无需等待该实例对象已获取锁的普通同步方法释放锁就可以获取			他们自己的锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      所有的静态同步方法用的也是同一把锁--类对象本身，</span></span><br><span class="line"><span class="comment"> *      这两把锁(this/class)是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有静态条件的。</span></span><br><span class="line"><span class="comment"> *      但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，</span></span><br><span class="line"><span class="comment"> *      而不管是同一个实例对象的静态同步方法之间，</span></span><br><span class="line"><span class="comment"> *      还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBDemo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendMs();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sayHello();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态同步方法锁的是.class 是类的模板（和锁this不一样）</p>
<h3 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h3><h4 id="集合是不安全的CopyOnWriteArrayList"><a href="#集合是不安全的CopyOnWriteArrayList" class="headerlink" title="集合是不安全的CopyOnWriteArrayList()"></a>集合是不安全的CopyOnWriteArrayList()</h4><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200612155134349.png" alt="img"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/2020061215515575.png" alt="在这里插入图片描述"></p>
<p>并发修改异常</p>
<ol>
<li><h5 id="解决办法new-Vector-lt-gt"><a href="#解决办法new-Vector-lt-gt" class="headerlink" title="解决办法new Vector&lt;&gt;();"></a>解决办法new Vector&lt;&gt;();</h5></li>
<li><h5 id="Collections-synchronizedList-new-ArrayList"><a href="#Collections-synchronizedList-new-ArrayList" class="headerlink" title="Collections.synchronizedList(new ArrayList());"></a>Collections.synchronizedList(new ArrayList());</h5></li>
<li><h5 id="new-CopyOnWriteArrayList-lt-gt-写时复制（底层用的unlock）"><a href="#new-CopyOnWriteArrayList-lt-gt-写时复制（底层用的unlock）" class="headerlink" title="new CopyOnWriteArrayList&lt;&gt;(); //写时复制（底层用的unlock）"></a>new CopyOnWriteArrayList&lt;&gt;(); //写时复制（底层用的unlock）</h5></li>
</ol>
<h4 id="不安全Set-解决CopyOnWriteArraySet-lt-gt"><a href="#不安全Set-解决CopyOnWriteArraySet-lt-gt" class="headerlink" title="不安全Set 解决CopyOnWriteArraySet&lt;&gt;();"></a>不安全Set 解决CopyOnWriteArraySet&lt;&gt;();</h4><h4 id="不安全Map-解决ConcurrentHashMap-lt-gt"><a href="#不安全Map-解决ConcurrentHashMap-lt-gt" class="headerlink" title="不安全Map 解决ConcurrentHashMap&lt;&gt;();"></a>不安全Map 解决ConcurrentHashMap&lt;&gt;();</h4><h3 id="第三种多线程方法Callable"><a href="#第三种多线程方法Callable" class="headerlink" title="第三种多线程方法Callable"></a>第三种多线程方法Callable</h3><p>思想：new Thread 需要传入一个runnable接口，找runnable接口实现子类，FutureTask既实现了runnable又实现callable接口</p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200623194826417.png" alt="java多态性"></p>
<h3 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h3><h5 id="CountDownLatchDemo（减法）"><a href="#CountDownLatchDemo（减法）" class="headerlink" title="CountDownLatchDemo（减法）"></a>CountDownLatchDemo（减法）</h5><p>​    保证一组子线程全部执行完毕之后再进行主线程的执行操作</p>
<h5 id="CyclicBarrierDemo-加法"><a href="#CyclicBarrierDemo-加法" class="headerlink" title="CyclicBarrierDemo      (加法)"></a>CyclicBarrierDemo      (加法)</h5><p>每运行多少次子线程运行一次CyclicBarrierDemo线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">14</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t收集到第&quot;</span>+ finalI +<span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210831165524207.png" alt="image-20210831165524207"></p>
<h5 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h5><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200701160521224.png" alt="并发线程的控制。eg:抢车位"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200701160549354.png" alt="运行结果"></p>
<h3 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h3><ul>
<li>写的上锁，读的可以不加锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile:，保证可见性，不保证原子性，一个线程修改后，通知更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t--写入数据&quot;</span> + key);</span><br><span class="line">            <span class="comment">//暂停一会线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t--写入完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t读取数据&quot;</span>);</span><br><span class="line">            Object result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t读取完成&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。</span></span><br><span class="line"><span class="comment"> * 但是，如果有一个线程想去写共享资源来，就不应该再有其他线程可以对改资源进行读或写</span></span><br><span class="line"><span class="comment"> * 小总结：</span></span><br><span class="line"><span class="comment"> *      读-读能共存</span></span><br><span class="line"><span class="comment"> *      读-写不能共存</span></span><br><span class="line"><span class="comment"> *      写-写不能共存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(tempInt+<span class="string">&quot;&quot;</span>,tempInt+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(tempInt+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7种BlockingQueue阻塞队列"><a href="#7种BlockingQueue阻塞队列" class="headerlink" title="7种BlockingQueue阻塞队列"></a>7种BlockingQueue阻塞队列</h3><ul>
<li>对阻塞队列进行管理</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20200702211141754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpem9uZ3hpYW8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200702211229753.png" alt="在这里插入图片描述"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200702211714115.png" alt="在这里插入图片描述"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200702212932216.png" alt="在这里插入图片描述"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200702213012839.png" alt="在这里插入图片描述"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200703110900155.png" alt="在这里插入图片描述"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200706114548466.png" alt="线程池"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200707143131109.png" alt="无"></p>
<h4 id="线程池的三大方法"><a href="#线程池的三大方法" class="headerlink" title="线程池的三大方法"></a>线程池的三大方法</h4><ul>
<li><p>ExecutorService threadpool = Executors.newFixedThreadpool(n);</p>
<p>//执行长期任务性能好，创建一个线程池，一池有N个固定线程，有固定的线程数</p>
</li>
<li><p> newSingleThreadExecutor();//一个任务一个任务的执行，一池一线程</p>
</li>
<li><p>newCacheThreadPool()</p>
<p>//执行很多短期异步任务，线程池根据需要创建新线程，<br>但在先前构建的线程可用时将重用它们。可扩容，遇强则强</p>
</li>
</ul>
<h4 id="ThreadPoolExecutor底层原理"><a href="#ThreadPoolExecutor底层原理" class="headerlink" title="ThreadPoolExecutor底层原理"></a>ThreadPoolExecutor底层原理</h4><img src="https://img-blog.csdnimg.cn/20200708112457871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpem9uZ3hpYW8=,size_16,color_FFFFFF,t_70" alt="ThreadPoolExecutor底层原理" style="zoom:67%;" />

<h4 id="线程池的7大参数"><a href="#线程池的7大参数" class="headerlink" title="线程池的7大参数"></a>线程池的7大参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//常驻核心线程数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,//线程池中能够容纳同时执行的最大线程数，必须大于等于<span class="number">1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,//多余线程存活时间</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,//keepAliveTime的时间单位</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞任务队列，被提交但未执行的任务</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,//生成工厂 	一般用默认 </span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;<span class="comment">//线程拒绝策略</span></span><br><span class="line">    <span class="comment">//构造方法实现略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程池底层运行原理"><a href="#线程池底层运行原理" class="headerlink" title="线程池底层运行原理"></a>线程池底层运行原理</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200709121721658.png" alt="线程池底层运行原理"  />

<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200709144823678.png" alt="img"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200709145210674.png" alt="在这里插入图片描述"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200709145729530.png" alt="在这里插入图片描述"></p>
<p>实际工作中只用自定义的线程池，不能用JDK的（防止内存被挤爆、资源耗尽）</p>
<h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200710191545314.png" alt="在这里插入图片描述"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200710194801205.png" alt="在这里插入图片描述"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得cup核数</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Runtime</span>.</span></span>get<span class="constructor">Runtime()</span>.available<span class="constructor">Processors()</span>);</span><br></pre></td></tr></table></figure>

<p>cup 密集型 几核就是几 保存 cup 运行最高效率</p>
<p>Io 密集型 判断程序十分耗 io 的线程 线程大于 2 倍</p>
<h3 id="JUF四大函数式接口"><a href="#JUF四大函数式接口" class="headerlink" title="JUF四大函数式接口"></a>JUF四大函数式接口</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200713162653977.png" alt="四大函数式接口" style="zoom:67%;" />

<h3 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h3><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200714143828357.png" alt="在这里插入图片描述"></p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/2020071414350274.png" alt="WWW" style="zoom:67%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/2020071415135572.png" alt="贼牛逼链式编程+流式计算" style="zoom:67%;" />

<h3 id="ForkJoinPool分支合并框架"><a href="#ForkJoinPool分支合并框架" class="headerlink" title="ForkJoinPool分支合并框架"></a>ForkJoinPool分支合并框架</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200715151928617.png" alt="在这里插入图片描述" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUST_VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - begin) &lt;= ADJUST_VALUE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (end + begin) / <span class="number">2</span>;</span><br><span class="line">            MyTask task01 = <span class="keyword">new</span> MyTask(begin, middle);</span><br><span class="line">            MyTask task02 = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            result = task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并框架</span></span><br><span class="line"><span class="comment"> * ForkJoinPool</span></span><br><span class="line"><span class="comment"> * ForkJoinTask</span></span><br><span class="line"><span class="comment"> * RecursiveTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo15</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        ForkJoinPool threadPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = threadPool.submit(myTask);</span><br><span class="line">        System.out.println(forkJoinTask.get());</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CompletableFuture异步回调"><a href="#CompletableFuture异步回调" class="headerlink" title="CompletableFuture异步回调"></a>CompletableFuture异步回调</h3><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200716150622985.png" alt="有返回值和无返回值" style="zoom:67%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/20200716150646204.png" alt="搞个坏error" style="zoom:67%;" />

<p>完结撒花</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others:"></a>Others:</h3><ul>
<li>idea 中自定义生成代码快捷键</li>
<li><a href="https://www.lagou.com/lgeduarticle/141121.html">JAVA 线程虚假唤醒</a></li>
<li><a href="https://segmentfault.com/a/1190000022705651">深度分析：理解Java中的多态机制，一篇直接帮你掌握！</a></li>
<li><a href="https://github.com/MaJesTySA/JVM-JUC-Core">阳哥JUC、JMM 核心知识点笔记</a></li>
<li><a href="https://blog.csdn.net/hejjunlin/article/details/106342669">聊一聊 Java 泛型中的通配符 T，E，K，V，？</a></li>
<li>kpi：工作绩效的意思，通俗来讲就是你的任务完成程度或者说你工作分数。kpi 高低决定了你的能力和薪资涨幅。</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>JUC</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>并发</tag>
        <tag>链表</tag>
        <tag>JUC</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>Lambda</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>set</tag>
        <tag>map</tag>
        <tag>list</tag>
        <tag>queue</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习</title>
    <url>/2021/08/27/2021-08-27-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<center>关系数据库管理系统</center>

<center>索引</center>

<span id="more"></span>

<h4 id="RDBMS数据库的设计"><a href="#RDBMS数据库的设计" class="headerlink" title="RDBMS数据库的设计"></a>RDBMS数据库的设计</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827091357390.png" alt="image-20210827091357390" style="zoom:67%;" />

<h4 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h4><h5 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h5><ul>
<li>快速查询数据</li>
</ul>
<h5 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h5><ul>
<li>生成索引，建立二叉查找树进行二分查找；</li>
<li>生成索引，建立B-树结构进行查找；</li>
<li>生成索引，建立B+树结构进行查找；</li>
<li>生成索引，建立Hash结构进行查找；</li>
</ul>
<h4 id="优化索引"><a href="#优化索引" class="headerlink" title="优化索引"></a>优化索引</h4><p>树的高度决定了IO次数，所以为了降低IO次数，减少时间复杂度，我们要降低树的高度，使用<strong>B树</strong>；</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>定义 <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827093415124.png" alt="image-20210827093415124" style="zoom:67%;" /></p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827093438280.png" alt="image-20210827093438280" style="zoom:67%;" />

<p>合并打乱上借下移保持平衡</p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827094011929.png" alt="image-20210827094011929" style="zoom:67%;" />

<p>Q代表指针</p>
<h6 id="B-树更适合用来做储存索引"><a href="#B-树更适合用来做储存索引" class="headerlink" title="B+树更适合用来做储存索引"></a>B+树更适合用来做储存索引</h6><ul>
<li>b+树的磁盘读写代价更低；</li>
<li>B+树查询效率更加稳定</li>
<li>b+树更有利于对数据库的扫描；</li>
</ul>
<h5 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h5><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827094523203.png" alt="image-20210827094523203" style="zoom:67%;" />

<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>仅仅能满足“=”，“in”，不能使用范围查询；</li>
<li>无法被用来避免数据的排序操作；</li>
<li>不能利用部分索引键查询；eg:组合索引；</li>
<li>不能避免表扫描；</li>
<li>遇到大量Hash值相等的情况后性能并不一定就会比B+效率高；</li>
</ul>
<h5 id="BitMap索引位图索引"><a href="#BitMap索引位图索引" class="headerlink" title="BitMap索引位图索引"></a>BitMap索引位图索引</h5><p>orcle</p>
<p>优点：一个节点能储存大量数据，类似于叠加cpu；</p>
<p>缺点：锁特别多；不适合高并发；</p>
<h4 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h4><ul>
<li>密集索引文件中的每个搜索码值都对应<strong>一个</strong>索引值；</li>
<li>稀疏索引文件只为索引码的某些值建立索引项；（叶子节点只保存了叶子节点的zhu键值和地址信息）</li>
</ul>
<p>Mysql都是稀疏索引；</p>
<p>InnoDB都是密集索引</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827095635682.png" alt="image-20210827095635682" style="zoom:67%;" />

<h6 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h6><p>相同点：都不支持hash索引</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827095907794.png" alt="image-20210827095907794" style="zoom:67%;" />

<p>密集索引直接在节点存储行，通过主键可以直接查询，使用辅助查询的话运行两次B+树即可；</p>
<p>而稀疏索引，主树和辅助树储存的信息都一样，所以不用访问主树即可找到；索引和数据是分开的；</p>
<h4 id="如何调优索引"><a href="#如何调优索引" class="headerlink" title="如何调优索引"></a>如何调优索引</h4><h5 id="定位并优化慢查询Sql"><a href="#定位并优化慢查询Sql" class="headerlink" title="定位并优化慢查询Sql;"></a>定位并优化慢查询Sql;</h5><p>思路</p>
<ul>
<li><h6 id="根据慢日志定位慢查询sql；"><a href="#根据慢日志定位慢查询sql；" class="headerlink" title="根据慢日志定位慢查询sql；"></a>根据慢日志定位慢查询sql；</h6><ul>
<li><pre><code class="mysql">show variables like &#39;%quer%&#39;
set global slow_query_log = on;
set global slow_query_time = 1;
show status like &#39;%slow_queries%&#39;
</code></pre>
<p>改配置文件</p>
</li>
</ul>
</li>
<li><h6 id="使用explain等工具分析sql-（在语句前加上explain）"><a href="#使用explain等工具分析sql-（在语句前加上explain）" class="headerlink" title="使用explain等工具分析sql （在语句前加上explain）"></a>使用explain等工具分析sql （在语句前加上explain）</h6><p>Explain关键字段解释</p>
<p>type：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827101928786.png" alt="image-20210827101928786" style="zoom:67%;" /></p>
<p>extra：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827102024813.png" alt="image-20210827102024813" style="zoom:67%;" /></p>
</li>
<li><p>修改sql或者尽量让sql走索引</p>
<ul>
<li>​    走index效率提高33%<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827102803560.png" alt="image-20210827102803560" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>最左匹配原则<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827111109861.png" alt="image-20210827111109861"  /></p>
<p>成因</p>
<h4 id="索引是建立得越多越好吗？"><a href="#索引是建立得越多越好吗？" class="headerlink" title="索引是建立得越多越好吗？"></a>索引是建立得越多越好吗？</h4><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827111437715.png" alt="image-20210827111437715"></p>
<!--more-->

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>hash</tag>
        <tag>B树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习1</title>
    <url>/2021/08/27/20210827-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<center>锁模块</center>

  <span id="more"></span>

<h4 id="MyISAM-与InnoDB关于锁方面得区别是什么？"><a href="#MyISAM-与InnoDB关于锁方面得区别是什么？" class="headerlink" title="MyISAM 与InnoDB关于锁方面得区别是什么？"></a>MyISAM 与InnoDB关于锁方面得区别是什么？</h4><ul>
<li><h5 id="MyISAM默认用的是表级锁-不支持行级锁；"><a href="#MyISAM默认用的是表级锁-不支持行级锁；" class="headerlink" title="MyISAM默认用的是表级锁,不支持行级锁；"></a>MyISAM默认用的是表级锁,不支持行级锁；</h5><ul>
<li><p>范围查询的时候默认给表上read🔒(共享锁)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock tables students read <span class="operator">|</span> write;</span><br></pre></td></tr></table></figure>

<p>write🔒（排他锁）</p>
<p>上锁之后读和写都要等 </p>
</li>
</ul>
</li>
<li><h5 id="InnoDB默认用的是行级锁，也支持表级锁；"><a href="#InnoDB默认用的是行级锁，也支持表级锁；" class="headerlink" title="InnoDB默认用的是行级锁，也支持表级锁；"></a>InnoDB默认用的是行级锁，也支持表级锁；</h5><ul>
<li><p>手动上锁，只对该行上锁；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students_innodb <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>共享锁可以兼容；</p>
<p>当查找不走索引的时候上的是表级锁；</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827142925274.png" alt="image-20210827142925274" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h4 id="那是不是锁越细越多越好？"><a href="#那是不是锁越细越多越好？" class="headerlink" title="那是不是锁越细越多越好？"></a>那是不是锁越细越多越好？</h4><p>🔒越多花费的资源越多；在数据较少的情况下用非聚集索引MyISAM很快</p>
<h4 id="MyISAM适合的场景"><a href="#MyISAM适合的场景" class="headerlink" title="MyISAM适合的场景"></a>MyISAM适合的场景</h4><ol>
<li>频繁执行全表count语句；</li>
<li>对数据进行增删改的频率不高，查询非常频繁；</li>
<li>没有事务；</li>
</ol>
<h4 id="InnoDB适合的场景"><a href="#InnoDB适合的场景" class="headerlink" title="InnoDB适合的场景"></a>InnoDB适合的场景</h4><ol>
<li>增删改查都比较频繁；</li>
<li>可靠性要求较高，要求支持事务；</li>
</ol>
<h4 id="数据库🔒的分类："><a href="#数据库🔒的分类：" class="headerlink" title="数据库🔒的分类："></a>数据库🔒的分类：</h4><ul>
<li>按照粒度划分：表级锁，行级锁，页级🔒；</li>
<li>按照级别划分：共享锁、排它锁；</li>
<li>按照枷锁方式：自动锁、显式锁；</li>
<li>按操作划分：DML锁、DDL锁；</li>
<li>按使用方式划分：乐观锁，悲观锁；</li>
</ul>
<p>悲观锁:一般用数据库自己带的锁；</p>
<p>乐观锁:使用数据版本控制，只有在增删改查的时候才会去判断冲突；</p>
<h4 id="数据库事务的四大特征：ACID"><a href="#数据库事务的四大特征：ACID" class="headerlink" title="数据库事务的四大特征：ACID"></a>数据库事务的四大特征：ACID</h4><ul>
<li>A原子性(Atomic)</li>
<li>一致性（Consistency）</li>
<li><strong>隔离性(Isolation)</strong></li>
<li>持久性（Durability)</li>
</ul>
<h4 id="事务隔离级别以及各级别下的并发访问问题"><a href="#事务隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务隔离级别以及各级别下的并发访问问题"></a>事务隔离级别以及各级别下的并发访问问题</h4><p>MySQL默认是repeatable-read Orcal默认是read-committed</p>
<ul>
<li>更新 丢失———mysql所有事务隔离级别在数据库层面上均可避免；<ul>
<li>eg:存钱失败</li>
</ul>
</li>
<li>脏读——设置read-committed事务隔离级别以上可避免；<ul>
<li>指的是一个session读取了另一个未提交的事务，另一个事务回滚之后造成翻车；</li>
<li>解决：set session transaction level read committed;</li>
</ul>
</li>
<li>不可重复读——repeatable-read事务隔离级别以上可避免；<ul>
<li>多次查询结果变化了超出预期；</li>
</ul>
</li>
<li> 幻读——serializable事务隔离级别可避免； </li>
<li>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</li>
</ul>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827153216400.png" alt="image-20210827153216400" style="zoom:67%;" />

<h4 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h4> <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827154029335.png" alt="image-20210827154029335" style="zoom:67%;" />

<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827160905898.png" alt="image-20210827160905898"></p>
<h4 id="RR级别下如何避免幻读"><a href="#RR级别下如何避免幻读" class="headerlink" title="RR级别下如何避免幻读"></a>RR级别下如何避免幻读</h4><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827161106338.png" alt="image-20210827161106338"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827161358934.png" alt="image-20210827161358934"></p>
<p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210827161434810.png" alt="image-20210827161434810"></p>
<!--more-->

<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><p>讲的很透彻的一篇好文：<a href="https://www.huaweicloud.com/articles/ffc11869bfea5f6793631f9b30369be0.html">理解事务的 4 种隔离级别</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>🔒</tag>
        <tag>数据库</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL树</title>
    <url>/2021/08/25/20210825-AVL%E6%A0%91/</url>
    <content><![CDATA[<center>设置一个机制来防止二叉树最坏情况变成链表；优化二分搜索树</center>

<p>AVL中<strong>平衡二叉树定义</strong>：对于任意一个节点，左子树和右子树的高度差不能超过1</p>
<p>eg:满二叉树，完全二叉树，线段树</p>
<span id="more"></span>

<p>标注节点的高度</p>
<p><strong>计算平衡因子</strong>：左右子树高度差相减；<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825094757417.png" alt="image-20210825094757417" style="zoom:50%;" /></p>
<p>判断是否为平衡二叉树并计算平衡因子<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825100642246.png" alt="image-20210825100642246" style="zoom:80%;" /></p>
<h4 id="在数据插入时维护二叉树平衡"><a href="#在数据插入时维护二叉树平衡" class="headerlink" title="在数据插入时维护二叉树平衡"></a>在数据插入时维护二叉树平衡</h4><p>右旋转原理：插入的元素在不平衡的节点的左侧的左侧<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825102959561.png" alt="image-20210825102959561" style="zoom:50%;" /></p>
<p>旋转之后既维持了二分搜索树的性质又实现了平衡；</p>
<p> 方法实现：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825104604755.png" alt="image-20210825104604755" style="zoom: 80%;" /></p>
<p><strong>左旋转</strong>：插入的元素在不平衡的节点的右侧的右侧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.left = y;</span><br><span class="line">y.right = T3</span><br></pre></td></tr></table></figure>

<p>当节点都比X大时，不能单纯的进行左旋转右旋转</p>
<p><strong>LL</strong>（左旋转）：</p>
<p><strong>RR</strong>（右旋转）：</p>
<p><strong>LR</strong>（先左旋转后右旋转）：</p>
<ul>
<li><p>插入的元素在不平衡的节点的左侧的右侧</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825113128961.png" alt="image-20210825113128961" style="zoom:50%;" />

<ul>
<li>​    转化成了LL的情况<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825113303838.png" alt="image-20210825113303838" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<p><strong>RL</strong>（先右旋转后左旋转）：</p>
<ul>
<li>添加的节点在不平衡节点的右子树的左侧，先对右节点进行右旋转化为RR，然后对RR进行左旋转<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825113410716.png" alt="image-20210825113410716"></li>
<li>转换成RR的情况<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825113434322.png" alt="image-20210825113434322" style="zoom:50%;" /></li>
</ul>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>删除一个元素后，会往上回溯</p>
<p>和BST删除一样，remove之后会返回一个根节点，再对这个node进行平衡得到平衡的node；</p>
<p>会有点耗时，因为每次删除完都要平衡遍历；</p>
<h4 id="基于AVL树的Set和Map"><a href="#基于AVL树的Set和Map" class="headerlink" title="基于AVL树的Set和Map"></a>基于AVL树的Set和Map</h4><p>AVL树的局限性</p>
<p>红黑树和AVL树的时间复杂度一致，但是红黑树旋转操作更少；</p>
<!--more-->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡二叉树</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/08/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<center>并查集UnionFind一种奇怪的树形结构</center>

<ul>
<li><p>非常高效的解决连接问题</p>
</li>
<li><p>判断网络中节点的链接状态</p>
</li>
<li><p>数学中集合并的实现</p>
</li>
</ul>
<span id="more"></span>

<h4 id="并查集的定义"><a href="#并查集的定义" class="headerlink" title="并查集的定义"></a>并查集的定义</h4><ul>
<li>判断是否连接，只需要判根节点是否一样</li>
</ul>
<p>指向树的根节点</p>
<p>并查集主要实现的方法：</p>
<ul>
<li>判断是否连接isConnected</li>
<li>把两个集合并起来</li>
</ul>
<h4 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h4><p><strong>设计思想</strong>：定义一个数组，给里面每个值定义一个标识符，标识是否在一个集合中；并操作，如果不在一个集合中，使用for循环让他们的标识符一致，这就形成了并操作</p>
<p><strong>具体实现</strong>: <img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824233819160.png" alt="image-20210824233819160" style="zoom:50%;" /></p>
<h4 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h4><p>改善并操作O(n)的时间复杂度，使用树来实现平均复杂度为O(logn)</p>
<p><strong>设计思想</strong>：将每一个元素看作一个节点，判断是不是连接，就判断他们的指向的根节点是否一样；并操作：将这个树的根节点指向另一棵树的根节点即可；</p>
<p><strong>具体实现</strong>：初始化数组，使每个元素指向它自己</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824234558192.png" alt="image-20210824234558192" style="zoom: 80%;" />

<p>find方法<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824235303840.png" alt="image-20210824235303840" style="zoom:50%;" /></p>
<p>find方法因为是树形结构所以查找过程中不是相邻的，是索引的查找，需要在不同的地址之间跳转；</p>
<p>union操作<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824235737247.png" alt="image-20210824235737247"></p>
<p> 缺点：这棵树可能会很大，很深；时间复杂度很高</p>
<p>优化：考虑size；将高度低的那棵树指向高度高的那棵树，这样来控制树的高度；<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825001742406.png" alt="image-20210825001742406" style="zoom:80%;" /></p>
<p>性能提升大概500倍<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825001855868.png" alt="image-20210825001855868" style="zoom:80%;" /></p>
<p>  让9指向8而不指向4的原因是：防止成为链表</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824221259227.png" alt="image-20210824221259227" style="zoom:50%;" />

<h4 id="基于RANK的优化"><a href="#基于RANK的优化" class="headerlink" title="基于RANK的优化"></a>基于RANK的优化</h4><p>rank[i]表示根节点为I的树的高度；</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825091001839.png" alt="image-20210825091001839" style="zoom:50%;" />

<h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parent[p] = parent[parent[p]];</span><br></pre></td></tr></table></figure>

<p><strong>设计思想</strong>：让该节点指向父亲节点的父亲节点，以降低树的高度；</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825092108468.png" alt="image-20210825092108468" style="zoom:80%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825092132678.png" alt="image-20210825092132678" style="zoom:67%;" />

<h5 id="递归实现："><a href="#递归实现：" class="headerlink" title="递归实现："></a>递归实现：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825091914244.png" alt="image-20210825091914244" style="zoom:50%;" /></h5><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>并不是严格意思上的二叉树，所以时间复杂度做<strong>了解</strong>即可</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210825092616066.png" alt="image-20210825092616066" style="zoom:50%;" />

<p>总结：树结构的变种堆、线段树、trie、并查集；</p>
<h4 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h4><ul>
<li>leetcode</li>
</ul>
<!--more-->

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie前缀树</title>
    <url>/2021/08/24/Trie/</url>
    <content><![CDATA[<center>Trie前缀树</center>

<h3 id="什么是Trie"><a href="#什么是Trie" class="headerlink" title="什么是Trie?"></a>什么是Trie?</h3><p>又被称为：多叉树、字典；通常用来处理字符串</br></p>
<p>问：同样是遍历为什么时间复杂度只和要查找的字符长度有关；</p>
<p>​        是一棵上面挂着很多单词子树的树？</p>
</br>

<span id="more"></span>

<p>查询的时间复杂度与一共有多少条无关，与查找的字符串的长度有关；</p>
<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824141531294.png" alt="image-20210824141531294" style="zoom:50%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824141823532.png" alt="image-20210824141823532" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 	<span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isWord;<span class="comment">//标志是不是，不用存c</span></span><br><span class="line">	Map&lt;<span class="keyword">char</span>,Node&gt; next;<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加操作："><a href="#添加操作：" class="headerlink" title="添加操作："></a>添加操作：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824151651138.png" alt="image-20210824151651138" style="zoom:50%;" /></h3><h3 id="查找存在："><a href="#查找存在：" class="headerlink" title="查找存在："></a>查找存在：<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824151908909.png" alt="image-20210824151908909" style="zoom:50%;" /></h3><h4 id="前缀搜索"><a href="#前缀搜索" class="headerlink" title="前缀搜索"></a>前缀搜索</h4><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824153154638.png" alt="image-20210824153154638" style="zoom:50%;" />

<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210824161346343.png" alt="image-20210824161346343" style="zoom:50%;" />

<h4 id="Trie的局限性"><a href="#Trie的局限性" class="headerlink" title="Trie的局限性"></a>Trie的局限性</h4><ul>
<li><p>最大的问题：空间！</p>
</li>
<li><p>因为trie中每个node中只储存一个字符，26个字母就要26个Node，孩子太多</p>
</li>
<li><p>结局办法：压缩字典树–合并、三分搜索树TST</p>
</li>
</ul>
<p>Others：</p>
<ul>
<li>leetcode第208题实现一个trie树</li>
<li>leetcode第211题添加与搜索单词</li>
<li>leetcode第677题 包含某个单词前缀的value的和 </li>
</ul>
<p>更多字符串问题</p>
<ul>
<li><p>后缀树–字符串模式识别（了解）</p>
</li>
<li><p>字串查询Ctrl+F</p>
</li>
<li><p>文件压缩</p>
</li>
<li><p>编译原理</p>
</li>
<li><p>DNA</p>
</li>
</ul>
<!-- more -->
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>前缀树</tag>
        <tag>眏射</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>堆和优先队列</title>
    <url>/2021/08/23/%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<center>堆和优先队列</center>

<p>优先队列：出队顺序和入队顺序无关，和优先级相关；</p>
<span id="more"></span>

<p>使用堆这种底层数据结构来实现优先队列，它的时间复杂度最好最坏都是O(log n )，极高的提高了性能</p>
<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822202808409.png" alt="image-20210822202808409" style="zoom: 67%;" />

<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><h4 id="定义：使用二叉树实现的堆；"><a href="#定义：使用二叉树实现的堆；" class="headerlink" title="定义：使用二叉树实现的堆；"></a>定义：使用二叉树实现的堆；</h4><p>堆通常是一个可以被看做一棵完全二叉树的数组对象</p>
<p>二叉堆是一颗完全二叉树</p>
<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822203336635.png" alt="image-20210822203336635" style="zoom: 67%;" />

<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li><strong>堆中的某个结点的值总是不大于其父节点的值；</strong>（最大堆）</li>
</ul>
<h5 id="堆的时间复杂度"><a href="#堆的时间复杂度" class="headerlink" title="堆的时间复杂度"></a>堆的时间复杂度</h5><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822225440370.png" alt="image-20210822225440370" style="zoom:50%;" />

<h5 id="优先对列—自定义优先级"><a href="#优先对列—自定义优先级" class="headerlink" title="优先对列—自定义优先级"></a>优先对列—自定义优先级</h5><ol>
<li><p>经典问题，时间复杂度</p>
<ul>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823095849862.png" alt="image-20210823095849862"></li>
</ul>
</li>
<li><p>思路：每次遍历取出元素进行储存，需要剔除最小值，所以需要一个最小堆，取出最小值，剩下的堆就是我们需要的优先队列； </p>
</li>
<li><p>自定义优先级</p>
<ul>
<li><p>自定义一个比较器</p>
</li>
<li><p><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823100344450.png" alt="image-20210823100344450"></p>
</li>
</ul>
</li>
<li><p>具体的函数实现<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823101359895.png" alt="image-20210823101359895" style="zoom: 80%;" /></p>
</li>
<li><p>使用import java.util.PriorityQueue;</p>
<ul>
<li>因为有比较器接口，直接实现，省去自定义</li>
<li><img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823111207782.png" alt="image-20210823111207782"></li>
</ul>
</li>
</ol>
<p>二叉堆的扩展：</p>
<ul>
<li><p>d叉堆—-时间复杂度为logd(n)<img src="https://2haotong-1301561974.cos.ap-chengdu.myqcloud.com/image-20210823111528542.png" alt="image-20210823111528542" style="zoom:67%;" /></p>
</li>
<li><p>索引堆和图论有关（了解）</p>
</li>
<li><p>二项堆和斐波那契堆（了解）</p>
</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other:"></a>Other:</h3><ul>
<li>leetcode第347题</li>
</ul>
<!-- more -->
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>leetcode</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的 “==”、“compareTo ()” 和 “equals ()” 的区别</title>
    <url>/2021/08/22/%E2%80%9C==%E2%80%9D%E3%80%81%E2%80%9CcompareTo-()%E2%80%9D-%E5%92%8C-%E2%80%9Cequals-()%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在比较两个对象或者数据大小的时候，经常会用到 ==、compareTo () 和 equals (), 尤其是在接入了 Comparable 接口后重写 compareTo 方法等场景，所以我们来理一下这三个的区别。</p>
<span id="more"></span>

<h3 id="等号-“-”："><a href="#等号-“-”：" class="headerlink" title="等号 “==”："></a>等号 “==”：</h3><p>　　等号是最简单也最容易理解的，如果等号的两边是基本数据类型，比如 int，double，那么等号就用来单纯的比较他们的数值大小</p>
<p>　　如果等号两边放的是两个对象，那么就会比较他们在内存当中的地址。</p>
<p>　　例如：</p>
<p>　　String a=”abc”;</p>
<p>　　String b=”abc”;</p>
<p>　　System.out.println(a==b);</p>
<p>　　答案是：true</p>
<p>　　因为相同的字符串内容，在地址上是一样。在 Java 中，String 是有一个 String pool 的，里面存放了可以共享的字符串对象，在声明一个 String 对象后，会首先去找是否存在相同的 String 内容，如果有的话是不会创建新的对象的。在这里 b 实际上是引用了 a 的对象的值，他自己并没有创建对象，所以这里的答案是 true。</p>
<p>　　但是如果我们接着</p>
<p>　　String c=new String(“abc”);</p>
<p>　　再</p>
<p>　　System.out.println(a==c);</p>
<p>　　那答案就是 false，因为这二者的地址并不是一致的。</p>
<h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h3><p>　　在 Java 里观察 compareTo () 的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> len1 = value.length;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> v1[] = value;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> c1 = v1[k];</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> c2 = v2[k];</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">　　<span class="keyword">return</span> c1 - c2;</span><br><span class="line">　　&#125;</span><br><span class="line">　　k++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> len1 - len2;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　可以观察出，这里实际上是获取的字符串 (也可以是其他对象) 的长度，然后作减法，这里的减法就是 ASCII 码的减法，所以 compareTo () 会返回数字，如果两个字符串内容相同，会返回 0，字符串 a 大于字符串 b，会返回相差的 ASCII 码的正数，字符串 a 小于字符串 b，会返回相差的 ASCII 码的负数。</p>
<p>　　所以 System.out.println (a.compareTo (b)) 的答案是：0</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">　　String anotherString = (String)anObject;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> n = value.length;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> v1[] = value;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">　　i++;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>　　依旧是来观察 Java 中 equals () 的源码</p>
<p>　　可以观察出，equals 是先用等号 (==) 直接来比较两个对象在内存当中的地址，如果相等会直接返回 true，如果这两个对象的地址不一样，就会考虑这两个对象是不是 String 类型的，如果是 String 类型的，那先比较两个字符串长度是否一样，如果长度不一致，那 100% 不相等，直接返回 false。长度一致则逐个比较</p>
<h3 id="compareTo-和-equals-的区别"><a href="#compareTo-和-equals-的区别" class="headerlink" title="compareTo () 和 equals 的区别"></a>compareTo () 和 equals 的区别</h3><p>　　compareTo () 会返回二者的差值，即返回的是一个数字；而 equals 就简单一些，只返回 true 或者 false。</p>
<p>　　最后，compareTo () 和 equals () 都可以判断其他基本数据类型，比如说 Integer，Java 的源码中对这两者方法都做了一些重载，可以根据参数的类型去自动匹配相应的方法，他们的原理也非常简单，只是一些简单的减法或者 (?：) 这类判断。</p>
<!-- more -->]]></content>
      <categories>
        <category>比较</category>
      </categories>
      <tags>
        <tag>equals</tag>
        <tag>compareTo</tag>
      </tags>
  </entry>
  <entry>
    <title>集合和眏射</title>
    <url>/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0Day4/</url>
    <content><![CDATA[<center>摘要：集合和眏射</center>

<p><escape><span id="more"></span></escape></p>
<h3 id="集合和眏射更像是一个定义好的接口实现数据结构；"><a href="#集合和眏射更像是一个定义好的接口实现数据结构；" class="headerlink" title="集合和眏射更像是一个定义好的接口实现数据结构；"></a>集合和眏射更像是一个定义好的接口实现数据结构；</h3><ol>
<li><h3 id="集合的应用eg：词汇统计、用户统计"><a href="#集合的应用eg：词汇统计、用户统计" class="headerlink" title="集合的应用eg：词汇统计、用户统计"></a>集合的应用eg：词汇统计、用户统计</h3></li>
<li><h4 id="二分搜索树和链表分别实现set："><a href="#二分搜索树和链表分别实现set：" class="headerlink" title="二分搜索树和链表分别实现set："></a>二分搜索树和链表分别实现set：</h4><ol>
<li><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822100933883.png" alt="image-20210822100933883" style="zoom:50%;" /></li>
<li><p><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822101430246.png" alt="image-20210822101430246"></p>
</li>
<li><h5 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h5><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822104120052.png" alt="image-20210822104120052" style="zoom:50%;" />

<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822102220739.png" alt="image-20210822102220739" style="zoom:50%;" />

<p>本质是因为二分搜索树是层序遍历的，而链表是依次遍历。</p>
</li>
<li><h5 id="最坏的情况h-n按照顺序退化成链表"><a href="#最坏的情况h-n按照顺序退化成链表" class="headerlink" title="最坏的情况h=n按照顺序退化成链表"></a>最坏的情况h=n按照顺序退化成链表</h5><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822104055949.png" alt="image-20210822104055949" style="zoom:50%;" />

<p>多重集合（了解）</p>
</li>
</ol>
</li>
</ol>
<h3 id="Map–-gt-dict（Key，Value）定义"><a href="#Map–-gt-dict（Key，Value）定义" class="headerlink" title="Map–&gt;dict（Key，Value）定义"></a>Map–&gt;dict（Key，Value）定义</h3><p>​        形象点说就是一个xx和一个zz相对应</p>
<h4 id="基于链表和二分搜索树的实现"><a href="#基于链表和二分搜索树的实现" class="headerlink" title="基于链表和二分搜索树的实现"></a>基于链表和二分搜索树的实现</h4><ul>
<li><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822105831953.png" alt="image-20210822105831953" style="zoom:50%;" /></li>
<li><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822105844028.png" alt="image-20210822105844028" style="zoom:50%;" /></li>
<li><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822121555244.png" alt="image-20210822121555244" style="zoom:50%;" /></li>
<li><p>多重眏射–多重眏射中的🗡可以重复</p>
</li>
</ul>
<h3 id="集合和眏射的关系"><a href="#集合和眏射的关系" class="headerlink" title="集合和眏射的关系"></a>集合和眏射的关系</h3><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822121716475.png" alt="image-20210822121716475" style="zoom: 80%;" />





<h4 id="Other"><a href="#Other" class="headerlink" title="Other:"></a>Other:</h4><ul>
<li><h6 id="满二叉树O-h-O-log2n-的推导"><a href="#满二叉树O-h-O-log2n-的推导" class="headerlink" title="满二叉树O(h)=O(log2n)的推导"></a>满二叉树O(h)=O(log2n)的推导</h6></li>
</ul>
<img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822103151953.png" alt="image-20210822103151953" style="zoom: 80%;" />

<ul>
<li><h6 id="leetcode第804题唯一的摩斯码；"><a href="#leetcode第804题唯一的摩斯码；" class="headerlink" title="leetcode第804题唯一的摩斯码；"></a>leetcode第804题唯一的摩斯码；</h6></li>
<li><h6 id="leetcode第349题两个数组的交集；"><a href="#leetcode第349题两个数组的交集；" class="headerlink" title="leetcode第349题两个数组的交集；"></a>leetcode第349题两个数组的交集；</h6><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822123556094.png" alt="image-20210822123556094" style="zoom: 80%;" /></li>
<li><h6 id="leetcode第350题两个数组的交集；"><a href="#leetcode第350题两个数组的交集；" class="headerlink" title="leetcode第350题两个数组的交集；"></a>leetcode第350题两个数组的交集；</h6><img src="https://1haotong-1301561974.cos.ap-beijing.myqcloud.com/image-20210822123528682.png" alt="image-20210822123528682" style="zoom: 80%;" /></li>
</ul>
<!-- more -->

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>眏射</tag>
        <tag>leetcode</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2021/08/14/20210814-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<center>接触线程的开始</center>

<span id="more"></span>

<h3 id="为什么多线程这么重要？"><a href="#为什么多线程这么重要？" class="headerlink" title="为什么多线程这么重要？"></a>为什么多线程这么重要？</h3><ol>
<li>摩尔定律失效，CPU主频从2003年不再翻倍；</li>
<li>在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。</li>
<li>高并发系统：异步+回调</li>
</ol>
<h3 id="多线程相关概念"><a href="#多线程相关概念" class="headerlink" title="多线程相关概念"></a>多线程相关概念</h3><ol>
<li><strong>进程</strong>：是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</li>
<li><strong>线程</strong>：在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程；</li>
<li>管程：Monitor(监视器)，也就是我们平时所说的锁</li>
</ol>
<h4 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 | 并行"></a>并发 | 并行</h4><ul>
<li>并发，指的是多个事情，在同一时间段内同时发生了。</li>
<li>并行，指的是多个事情，在同一时间点上同时发生了。并发的多个任务之间是互相抢占资源的。 并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。并行的多个任务之间是不互相抢占资源的、只有在多 CPU 的情况中，才会发生并行。</li>
</ul>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><ol>
<li>在高内聚低耦合的条件下，<strong>线程</strong>      <strong>操作</strong>        <strong>资源类</strong></li>
<li>判断/干活/通知</li>
<li>防止虚假唤醒(判断只能用while，不能用if)<ul>
<li>知识小总结：多线程编程套路+while判断+新版写法</li>
</ul>
</li>
<li>标志位</li>
</ol>
<!--more-->]]></content>
      <categories>
        <category>-JAVA -多线程 -面试</category>
      </categories>
      <tags>
        <tag>-JAVA基础 -多线程</tag>
      </tags>
  </entry>
</search>
